> [Documentation](../../README.md) >
> [Vulnerability Management](../vulnerability-management.md) >
> [Vulnerability Data Mirror](vulnerability-data-mirror.md) >
> Indexers

# Indexers

The indexers extract and process data from the downloads, organizing it into searchable formats for further use.
Each indexer processes data differently depending on the structure and type of data received from its associated
downloads.
A detailed overview of the dependencies between downloads and indexes is available on the individual index chapters
as seen below.

- [NVD CVE API](#nvd-cve-api)
- [NVD CPE API](#nvd-cpe-api)
- [NVD CPE API Vendor Product](#nvd-cpe-api-vendor-product)
- [MSRC Product](#msrc-product)
- [MSRC Advisor](#msrc-advisor)
- [MSRC KB Chain](#msrc-kb-chain)
- [GHSA Advisor](#ghsa-advisor)
- [CERT-SEI Advisor](#cert-sei-advisor)
- [CERT-FR Advisor](#cert-fr-advisor)
- [CERT-EU Advisor](#cert-eu-advisor)
- [KEV](#kev)
- [EPSS](#epss)
- [EOL](#eol)

#### Deprecated Downloaders

- [_NVD Vulnerability (deprecated)_](#nvd-vulnerability-deprecated)
- [_CPE Dictionary (deprecated)_](#cpe-dictionary-deprecated)
- [_CPE Dictionary Vendor Product (deprecated)_](#cpe-dictionary-vendor-product-deprecated)

## Indexing Workflow

The indexing process is responsible for transforming downloaded data into Lucene Indexes,
where each index consists of a set of documents structured as key-value pairs.
The specific data captured in these documents varies between indexes, based on the type of data they handle.

Indexers may depend on one or more downloads or other indexes.
If any required data or index is missing, the indexing process will not proceed.

Indexing is initiated under the following conditions:

- The index has not been created before.
- The index has failed in its last run.
- The index is older than a configured threshold.
- Any of the downloads or indexes it depends on have been updated since the last indexing.

<!--### Common Steps in the Indexing Process

While each indexer functions differently depending on the type of data it handles,
the following general steps are followed:

1. **Wait for Directory Unlock**: Before indexing, the directory must be unlocked to ensure other processes are not
   accessing or modifying the data.
2. **Lock Directory**: Once available, the directory is locked to prevent concurrent read/write operations.
3. **Check for Updates**: The system checks whether indexing is necessary based on the defined conditions. If no update
   is required, the process is aborted.
4. **Backup Existing Index**: A backup of the current index is made to prevent data loss in case of failure.
5. **Clear Current Index**: The existing index data is fully removed to prepare for the new data.
6. **Create Index**:
    - Validate that all required downloads and dependencies are available.
    - Generate the index documents, which differ by indexer.
    - Write the documents to the index directory if at least one document has been created.
7. **Handle Exceptions**: If an error occurs, the system reverts to the backup. Regardless of the outcome, the backup is
   removed after the process.
8. **Unlock Directory**: Once the indexing process is complete, the directory is unlocked to allow other processes
   access.-->

It cannot be stressed enough that since each indexer works with different data formats and sources,
they each require very specialized parsing methods.
These sources vary widely and may lack a consistent or machine-readable format, making the indexing process complex.
This is why a clear and defined preprocessing in form of a mapping of source fields to target fields in the Lucene index
is so important to the process.

# Indexers Details

## NVD CVE API

`nvd-cve` / `nvdVulnerabilityIndex`

<details>

<summary>Source Code for <code>NvdCveApiIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

final File[] files = super.requiredDownloads[0].listFiles(f -> f.isFile() && f.getName().endsWith(".json"));

if (files == null) {
    throw new RuntimeException("Unable to list files in " + super.requiredDownloads[0]);
}

for (File file : files) {
    super.executor.submit(() -> documents.putAll(processFile(file)));
}

super.executor.setSize(6);
super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for indexing to complete.", e);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [NVD CVE API](download.md#nvd-cve-api) |


## NVD CPE API

`cpe-dict` / `nvdCpeIndex`

<details>

<summary>Source Code for <code>NvdCpeApiIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new HashMap<>();

final File[] files = super.requiredDownloads[0].listFiles(f -> f.isFile() && f.getName().endsWith(".json"));

if (files == null) {
    throw new RuntimeException("Unable to list files in " + super.requiredDownloads[0]);
}

for (File file : files) {
    super.executor.submit(() -> {
        synchronized (documents) {
            documents.putAll(processFile(file));
        }
    });
}

super.executor.setSize(6);
super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for indexing to complete.", e);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [NVD CPE API](download.md#nvd-cpe-api) |


## NVD CPE API Vendor Product

`cpe-dict-vp` / `nvdCpeVendorProductIndex`

<details>

<summary>Source Code for <code>NvdCpeApiVendorProductIndex.createIndexDocuments</code> </summary>

```java
final NvdCpeApiIndexQuery indexQuery = new NvdCpeApiIndexQuery(getRequiredIndex(NvdCpeApiIndex.class));

final Map<String, Document> documents = new HashMap<>();

LOG.info("Parsing all [Vendor Products] / [Product Vendors] pairs");
final Map<String, Set<String>> vendorProductsMap = new HashMap<>();
final Map<String, Set<String>> productVendorsMap = new HashMap<>();

indexQuery.getIndex().findAndProcessAllDocuments(document -> {
    vendorProductsMap.computeIfAbsent(document.get("vendor"), k -> new HashSet<>()).add(document.get("product"));
    productVendorsMap.computeIfAbsent(document.get("product"), k -> new HashSet<>()).add(document.get("vendor"));
});
LOG.info("Extracted [{} Vendor Products] and [{} Product Vendors]", vendorProductsMap.size(), productVendorsMap.size());

LOG.info("Building Vendor Products map");
for (Map.Entry<String, Set<String>> vendorProducts : vendorProductsMap.entrySet()) {
    final StringJoiner productJoiner = new StringJoiner(", ");

    for (String product : vendorProducts.getValue()) {
        productJoiner.add(product);
    }

    final Document document = new Document();

    document.add(new StringField("type", "vp", Field.Store.YES));
    document.add(new TextField("vendor", vendorProducts.getKey(), Field.Store.YES));
    document.add(new TextField("product", productJoiner.toString(), Field.Store.YES));

    documents.put("vp" + vendorProducts.getKey(), document);
}

LOG.info("Building Product Vendors map");
for (Map.Entry<String, Set<String>> productVendors : productVendorsMap.entrySet()) {
    final StringJoiner vendorJoiner = new StringJoiner(", ");

    for (String vendor : productVendors.getValue()) {
        vendorJoiner.add(vendor);
    }

    final Document document = new Document();

    document.add(new StringField("type", "pv", Field.Store.YES));
    document.add(new TextField("product", productVendors.getKey(), Field.Store.YES));
    document.add(new TextField("vendor", vendorJoiner.toString(), Field.Store.YES));

    documents.put("pv" + productVendors.getKey(), document);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Index** | [NVD CPE API Index.c](#nvd-cpe-api-indexc) |


## MSRC Product

`msrc-products` / `msrcProductIndex`

<details>

<summary>Source Code for <code>MsrcProductIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

final List<File> files = super.getAllFilesInSubDirectories(super.requiredDownloads[0]);

final Set<String> productIdsWithFullContent = new HashSet<>();

for (File file : files) {
    if (file.getName().endsWith(".xml")) {
        super.executor.submit(() -> {
            final List<MsrcProduct> products = parseMsProductsFromFile(file);

            for (MsrcProduct product : products) {
                if (productIdsWithFullContent.contains(product.getId())) {
                    continue;
                } else if (product.getVendor() != null && product.getFamily() != null) {
                    productIdsWithFullContent.add(product.getId());
                }

                documents.put(product.getId(), product.toDocument());
            }
        });
    }
}

super.executor.setSize(16);
super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for indexing to complete.", e);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [MSRC](download.md#msrc) |


## MSRC Advisor

`msrc-advisors` / `msrcAdvisorIndex`

<details>

<summary>Source Code for <code>MsrcAdvisorIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

final List<File> files = super.getAllFilesInSubDirectories(super.requiredDownloads[0]);

for (File file : files) {
    if (file.getName().endsWith(".xml")) {
        super.executor.submit(() -> {
            try {
                final List<String> lines = FileUtils.readLines(file, StandardCharsets.UTF_8);

                if (lines.isEmpty() || lines.size() < 3 && StringUtils.isEmpty(String.join("", lines))) {
                    return;
                }

                final org.w3c.dom.Document document = parseXmlDocument(String.join("\n", lines));

                final List<MsrcAdvisorEntry> parsedEntries = MsrcAdvisorEntry.fromDownloadXml(document);

                for (MsrcAdvisorEntry entry : parsedEntries) {
                    if (documents.containsKey(entry.getId())) {
                        if (StringUtils.isEmpty(entry.getSummary())) {
                            continue;
                        }
                    }
                    documents.put(entry.getId(), entry.toDocument());
                }
            } catch (IOException e) {
                throw new RuntimeException("Unable to read file contents during indexing: " + file.getAbsolutePath(), e);
            } catch (Exception e) {
                throw new RuntimeException("Unable to parse file content during indexing: " + file.getAbsolutePath(), e);
            }
        });
    }
}

super.executor.setSize(16);
super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for indexing to complete.", e);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [MSRC](download.md#msrc) |


## MSRC KB Chain

`msrc-kb-chains` / `msrcKbChainIndex`

<details>

<summary>Source Code for <code>MsrcKbChainIndex.createIndexDocuments</code> </summary>

```java
final MsrcAdvisorIndexQuery advisorQuery = new MsrcAdvisorIndexQuery(getRequiredIndex(MsrcAdvisorIndex.class));
final MsrcProductIndexQuery productQuery = new MsrcProductIndexQuery(getRequiredIndex(MsrcProductIndex.class));

final List<File> allMsrcUpdateGuideCsvFiles = getAllMsrcUpdateGuideCsvFiles();
final List<File> allMsrcUpdateGuideJsonFiles = getAllMsrcUpdateGuideJsonFiles();

LOG.info("");
LOG.info("Parsing KB nodes from:");
LOG.info("  - the MSRC Api Advisor Mirror");
if (!allMsrcUpdateGuideCsvFiles.isEmpty()) {
    // total entries as of 2023-02-28: 114781
    LOG.info("  - [{}] MSRC Security Update Guide CSV files", allMsrcUpdateGuideCsvFiles.size());
}
if (!allMsrcUpdateGuideJsonFiles.isEmpty()) {
    // total entries as of 2023-07-11: 127517
    LOG.info("  - [{}] MSRC Security Update Guide JSON files", allMsrcUpdateGuideJsonFiles.size());
}
LOG.info("");
LOG.info("- - - - - - - -");


// from the MSRC Api Advisor Mirror
final List<MsrcSupersedeNode> msrcApiNodes = createMsrcApiNodes(advisorQuery);

// from the MSRC Security Update Guide CSV files
final Map<File, List<MsrcSupersedeNode>> msrcUpdateGuideNodes = createMsrcUpdateGuideNodes(productQuery, allMsrcUpdateGuideCsvFiles);

// from the MSRC Security Update Guide JSON files
final Map<File, List<MsrcSupersedeNode>> msrcUpdateGuideJsonNodes = createMsrcUpdateGuideJsonNodes(productQuery, allMsrcUpdateGuideJsonFiles);


// combine the lists into a single list
final List<MsrcSupersedeNode> parsedNodes = new ArrayList<>(msrcApiNodes);
for (Map.Entry<File, List<MsrcSupersedeNode>> fileEntry : msrcUpdateGuideNodes.entrySet()) {
    parsedNodes.addAll(fileEntry.getValue());
}
for (Map.Entry<File, List<MsrcSupersedeNode>> fileEntry : msrcUpdateGuideJsonNodes.entrySet()) {
    parsedNodes.addAll(fileEntry.getValue());
}

// merge the nodes together
final Map<String, MsrcSupersedeNode> uniqueNodes = MsrcSupersedeNode.mergeNodes(Collections.singleton(parsedNodes));
LOG.info("Deduplicated parsed KB entries [{} --> {}]", parsedNodes.size(), uniqueNodes.size());


// create documents
final Map<String, Document> documents = new HashMap<>();
for (Map.Entry<String, MsrcSupersedeNode> entry : uniqueNodes.entrySet()) {
    documents.put(entry.getKey(), entry.getValue().toDocument());
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [ MSRC Security Guide](download.md#-msrc-security-guide) |
| **Index** | [MSRC Advisor](#msrc-advisor), [MSRC Product](#msrc-product) |
| **Optional Download** | [ MSRC Manual CSV](download.md#-msrc-manual-csv) |


## GHSA Advisor

`github-advisory-database` / `githubAdvisorIndex`

<details>

<summary>Source Code for <code>GhsaAdvisorIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

LOG.info("Searching for files in repository, this may take a while {}", super.requiredDownloads[0].getAbsolutePath());
final Collection<File> files = super.getAllFilesRecursively(super.requiredDownloads[0]);
LOG.info("Found [{}] files in repository", files.size());

for (File file : files) {
    if (!file.getName().endsWith(".json")) {
        continue;
    }

    super.executor.submit(() -> {
        try {
            final String contents = FileUtils.readFileToString(file, StandardCharsets.UTF_8);

            final GhsaAdvisorEntry parsedEntry;
            try {
                parsedEntry = GhsaAdvisorEntry.fromGitRepoJson(new JSONObject(contents));
            } catch (Exception e) {
                LOG.error("Unable to parse file content during indexing: {}\n{}", file.getAbsolutePath(), contents, e);
                throw e;
            }

            if (documents.containsKey(parsedEntry.getId())) {
                LOG.warn("Duplicate entry found, skipping: {}", parsedEntry.toJson());
            } else {
                documents.put(parsedEntry.getId(), parsedEntry.toDocument());
            }
        } catch (IOException e) {
            throw new RuntimeException("Unable to read file contents during indexing: " + file.getAbsolutePath(), e);
        } catch (Exception e) {
            throw new RuntimeException("Unable to parse file content during indexing: " + file.getAbsolutePath(), e);
        }
    });
}

executor.setSize(16);
executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for all vulnerability sheets to be created", e);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [GHSA](download.md#ghsa) |


## CERT-SEI Advisor

`certsei-advisors` / `certSeiAdvisorIndex`

<details>

<summary>Source Code for <code>CertSeiAdvisorIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new HashMap<>();

final List<File> files = super.getAllFilesInSubDirectories(super.requiredDownloads[0]);

for (File file : files) {
    try {
        final List<String> contents = FileUtils.readLines(file, StandardCharsets.UTF_8);
        final JSONObject jsonContent = new JSONObject(String.join("", contents));

        final CertSeiAdvisorEntry parsedEntry = CertSeiAdvisorEntry.fromDownloadJson(jsonContent);

        documents.put(parsedEntry.getId(), parsedEntry.toDocument());
    } catch (IOException e) {
        throw new RuntimeException("Unable to read file contents during indexing ", e);
    }
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [CERT-SEI](download.md#cert-sei) |


## CERT-FR Advisor

`certfr-advisors` / `certFrAdvisorIndex`

<details>

<summary>Source Code for <code>CertFrAdvisorIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

final List<File> files = super.getAllFilesInSubDirectories(super.requiredDownloads[0]);

for (File file : files) {
    super.executor.submit(() -> {
        try {
            final CertFrAdvisorEntry parsedEntry;

            if (file.getName().endsWith(".txt")) {
                final List<String> contents = FileUtils.readLines(file, StandardCharsets.UTF_8);
                parsedEntry = CertFrAdvisorEntry.fromDownloadText(contents);
            } else if (file.getName().endsWith(".json")) {
                parsedEntry = CertFrAdvisorEntry.fromApiJson(file);
            } else {
                LOG.warn("Unsupported file format, skipping: {}", file.getAbsolutePath());
                return;
            }

            if (documents.containsKey(parsedEntry.getId())) {
                LOG.warn("Duplicate entry found, skipping: {}", parsedEntry.toJson());
            } else {
                documents.put(parsedEntry.getId(), parsedEntry.toDocument());
            }
        } catch (IOException e) {
            throw new RuntimeException("Unable to read file contents during indexing: " + file.getAbsolutePath(), e);
        } catch (Exception e) {
            throw new RuntimeException("Unable to parse file content during indexing: " + file.getAbsolutePath(), e);
        }
    });
}

super.executor.setSize(16);
super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for indexing to complete.", e);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [CERT-FR](download.md#cert-fr) |


## CERT-EU Advisor

`certeu-advisors` / `certEuAdvisorIndex`

<details>

<summary>Source Code for <code>CertEuAdvisorIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new HashMap<>();

final List<File> files = super.getAllFilesInSubDirectories(new File(super.requiredDownloads[0], "publications"));
LOG.info("Found [{}] CERT-EU advisory files", files.size());

for (File file : files) {
    try {
        final List<String> contents = FileUtils.readLines(file, StandardCharsets.UTF_8);
        final JSONObject jsonContent = new JSONObject(String.join("", contents));

        final CertEuAdvisorEntry parsedEntry = CertEuAdvisorEntry.fromDownloadJson(jsonContent);

        documents.put(parsedEntry.getId(), parsedEntry.toDocument());
    } catch (IOException e) {
        throw new RuntimeException("Unable to read file contents during indexing ", e);
    }
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [CERT-EU](download.md#cert-eu) |


## KEV

`kev` / `kevIndex`

<details>

<summary>Source Code for <code>KevIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

final Collection<File> files = super.getAllFilesRecursively(super.requiredDownloads[0]);

for (File file : files) {
    if (!file.getName().endsWith(".json")) {
        continue;
    }
    LOG.info("Processing file: {}", file.getName());

    try {
        final String contents = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
        final JSONObject parsedContents = new JSONObject(contents);
        final JSONArray kevEntries = parsedContents.getJSONArray("vulnerabilities");
        final List<Document> kevEntriesDocs = fromJson(kevEntries);


        for (Document document : kevEntriesDocs) {
            String uldid = document.get("vulnerability");
            if (documents.containsKey(uldid)) {
                LOG.warn("Duplicate entry found, skipping: {}", document);
            } else {
                documents.put(uldid, document);
            }
        }
    } catch (IOException e) {
        throw new RuntimeException("Failed to read file: " + file.getAbsolutePath(), e);
    }
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [CISA KEV](download.md#cisa-kev) |


## EPSS

`epss` / `epssIndex`

<details>

<summary>Source Code for <code>EpssIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

final Collection<File> files = super.getAllFilesRecursively(super.requiredDownloads[0]);
for (File file : files) {
    if (!file.getName().endsWith(".csv")) {
        continue;
    }

    log.info("Processing file: {}", file.getName());

    try {
        String contents = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
        contents = contents.substring(contents.indexOf("\n") + 1);
        contents = contents.substring(contents.indexOf("\n") + 1);

        for (String line : contents.split("\n")) {
            String[] fields = line.split(",");
            EpssData epssData = new EpssData(fields[0], Float.parseFloat(fields[1]), Float.parseFloat(fields[2]));
            documents.put(fields[0], epssData.toDocument());
        }

    } catch (IOException e) {
        throw new RuntimeException("Failed to read file: " + file.getAbsolutePath(), e);
    }
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [EPSS](download.md#epss) |


## EOL

`eol` / `eolIndex`

<details>

<summary>Source Code for <code>EolIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

final Collection<File> files = super.getAllFilesRecursively(super.requiredDownloads[0]);
LOG.info("Found [{}] files in repository", files.size());

for (File file : files) {
    if (!file.getName().endsWith(".json")) {
        continue;
    }

    final String product = file.getName().replace(".json", "");

    try {
        final String contents = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
        final JSONArray parsedContents = new JSONArray(contents);
        final EolLifecycle productInfo = EolLifecycle.fromJson(product, parsedContents);

        for (Document document : productInfo.toDocuments()) {
            String uldid = product + "-" + document.get("cycle");
            if (documents.containsKey(uldid)) {
                uldid = uldid + "-" + document.get("link");
                if (documents.containsKey(uldid)) {
                    LOG.warn("Duplicate entry found, skipping: {}", document);
                }
            } else {
                documents.put(uldid, document);
            }
        }
    } catch (IOException e) {
        throw new RuntimeException("Failed to read file: " + file.getAbsolutePath(), e);
    }
}

if (!files.isEmpty()) {
    LOG.info("Average of [{}] cycles per product", documents.size() / files.size());
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | [EOL](download.md#eol) |


## _NVD Vulnerability (deprecated)_

`nvd-cve` / `nvdLegacyVulnerabilityIndex`

<details>

<summary>Source Code for <code>NvdVulnerabilityIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new ConcurrentHashMap<>();

final File[] files = super.requiredDownloads[0].listFiles(f -> f.isFile() && f.getName().startsWith("nvd-") && f.getName().endsWith(".json"));

if (files == null) {
    throw new RuntimeException("Unable to list files in " + super.requiredDownloads[0]);
}

for (File file : files) {
    super.executor.submit(() -> documents.putAll(processFile(file)));
}

super.executor.setSize(6);
super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for indexing to complete.", e);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | _NVD_ |


## _CPE Dictionary (deprecated)_

`cpe-dict` / `cpeDictionaryIndex`

<details>

<summary>Source Code for <code>CpeDictionaryIndex.createIndexDocuments</code> </summary>

```java
final Map<String, Document> documents = new HashMap<>();

final File downloadsDirectory = super.requiredDownloads[0];

final File cpeDictionary = new File(downloadsDirectory, "cpe-dict.xml");
if (!cpeDictionary.isFile()) {
    throw new RuntimeException("Could not find cpe-dict.xml in " + downloadsDirectory.getAbsolutePath());
}

final File cpeMatch = new File(downloadsDirectory, "cpe-match.json");
if (!cpeMatch.isFile()) {
    throw new RuntimeException("Could not find cpe-match.json in " + downloadsDirectory.getAbsolutePath());
}

parseCpeMatch(cpeMatch, documents);
// to prevent all the CPE information being stored in memory, write the existing documents into the index
super.writeIndexDocuments(documents);

parseCpeDict(cpeDictionary, documents);

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Download** | _CPE Dictionary_ |


## _CPE Dictionary Vendor Product (deprecated)_

`cpe-dict-vp` / `cpeDictionaryVendorProductIndex`

<details>

<summary>Source Code for <code>CpeDictionaryVendorProductIndex.createIndexDocuments</code> </summary>

```java
final CpeDictionaryIndexQuery indexQuery = new CpeDictionaryIndexQuery(getRequiredIndex(CpeDictionaryIndex.class));

final Map<String, Document> documents = new HashMap<>();

LOG.info("Parsing all [Vendor Products] / [Product Vendors] pairs");
final Map<String, Set<String>> vendorProductsMap = new HashMap<>();
final Map<String, Set<String>> productVendorsMap = new HashMap<>();

indexQuery.getIndex().findAndProcessAllDocuments(document -> {
    vendorProductsMap.computeIfAbsent(document.get("vendor"), k -> new HashSet<>()).add(document.get("product"));
    productVendorsMap.computeIfAbsent(document.get("product"), k -> new HashSet<>()).add(document.get("vendor"));
});
LOG.info("Extracted [{} Vendor Products] and [{} Product Vendors]", vendorProductsMap.size(), productVendorsMap.size());

LOG.info("Building Vendor Products map");
for (Map.Entry<String, Set<String>> vendorProducts : vendorProductsMap.entrySet()) {
    final StringJoiner productJoiner = new StringJoiner(", ");

    for (String product : vendorProducts.getValue()) {
        productJoiner.add(product);
    }

    final Document document = new Document();

    document.add(new StringField("type", "vp", Field.Store.YES));
    document.add(new TextField("vendor", vendorProducts.getKey(), Field.Store.YES));
    document.add(new TextField("product", productJoiner.toString(), Field.Store.YES));

    documents.put("vp" + vendorProducts.getKey(), document);
}

LOG.info("Building Product Vendors map");
for (Map.Entry<String, Set<String>> productVendors : productVendorsMap.entrySet()) {
    final StringJoiner vendorJoiner = new StringJoiner(", ");

    for (String vendor : productVendors.getValue()) {
        vendorJoiner.add(vendor);
    }

    final Document document = new Document();

    document.add(new StringField("type", "pv", Field.Store.YES));
    document.add(new TextField("product", productVendors.getKey(), Field.Store.YES));
    document.add(new TextField("vendor", vendorJoiner.toString(), Field.Store.YES));

    documents.put("pv" + productVendors.getKey(), document);
}

return documents;
```

</details>

| Dependency Type | Depends on |
| --- | --- |
| **Index** | _CPE Dictionary Index.c_ |

