# Building the Vulnerability Documentation

## What?

Portions of the vulnerability documentation are automatically generated.
This system uses template files (in [`data-mirror/template`](../data-mirror/template) and other directories)
which are then populated with dynamic content using placeholders like `$gen{index-list-active}`.
Approximately 50% of pages are static (manually written),
while the rest are dynamically generated with some manual segments.

## Why?

- Documentation is available alongside source code, where it is most relevant to developers.
- Eliminates duplication, preventing outdated versions on both sides.
- Code changes automatically propagate to documentation after regeneration, reducing manual effort.

## How?

You're already in the directory of the maven project that can build the documentation.

Setup:

- Update the variables in [`documentation-generator.properties`](src/main/resources/documentation-generator.properties)
  with your own using the comments above each value.
- Ensure your local data mirror has the latest vulnerability index (used for example extraction and statistics).
- Import the Maven project into your IDE.

Generation:

- Execute the `main` method in
  [`DocumentationGenerator.java`](src/main/java/com/metaeffekt/documentation/DocumentationGenerator.java).
- Generation might take a while, after that review the changes in the git diff.

<!--
- If files in [`individual-detail-overview-diagram-html`](../diagrams/individual-detail-overview-diagram-html) are
  modified/new:
  1. Open each file in a browser.
  2. Press `p` to export the diagram as a PNG.
  3. Move the generated PNGs to [`individual-detail-overview-diagram-rendered`](../diagrams/individual-detail-overview-diagram-rendered).
-->

Install the `chromium` command via brew or otherwise gain access to the chromium engine.

Run the [render-diagrams.sh](../diagrams/render-diagrams.sh) to automatically update all files

This will render every image except for the [large-overview-diagram.html](../large-overview-diagram.html):

```shell
chromium --headless --disable-gpu --screenshot=large-overview-diagram.png --window-size=3000,4500 large-overview-diagram.html
```

Run the [`DocumentationGenerator.java`](src/main/java/com/metaeffekt/documentation/DocumentationGenerator.java) again,
but this time use the `cropImages` method.

## How to create generated documentation pages

If you were to add a new page or set of pages to the documentation, you would have to add a new generator class
extending [`IDocumentationGenerator`](src/main/java/com/metaeffekt/documentation/IDocumentationGenerator.java) and
implement the `public void generateDocumentation(JavaProjectBuilder project)` method.
Then, add an instance of your generator to the list in the main function of the DocumentationGenerator class:

<!-- @formatter:off -->
```java
for (IDocumentationGenerator generator : Arrays.asList(
    new MirrorDocumentationGenerator(),
    // ... more generators
    new YourOwnGenerator()
)) {
    generator.generateDocumentation(project);
}
```

You can view the other generators for examples on how to implement your own.
This part is what is responsible for filling the templated files and generating the documentation.

The most important point is that you are being passed a
[`JavaProjectBuilder`](https://github.com/paul-hammant/qdox/blob/master/src/main/java/com/thoughtworks/qdox/JavaProjectBuilder.java),
which you can use to access the source code of the project you are documenting (artifact analysis or core).
It contains all the classes and methods together with their JavaDoc comments and annotations.

See [`InventoryEnrichmentStepsDocumentationGenerator.java`](src/main/java/com/metaeffekt/documentation/generator/InventoryEnrichmentStepsDocumentationGenerator.java)
for some examples:

```java
// find classes extending some class
DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.artifact.enrichment.InventoryEnricher")

// find an annotation on a class
final JavaAnnotation mirrorMetadata = clazz.getAnnotations().stream()
        .filter(a -> a.getType().getValue().equals("EnricherMetadata"))
        .findFirst()
        .orElseThrow(() -> new RuntimeException("No @EnricherMetadata annotation found on " + clazz.getName()));

// construct an instance of a class using the fully qualified name (no-args constructor used here)
final Class<?> clazzClass = Class.forName(directConfiguration.getFullyQualifiedName());
final Object instance = clazzClass.getDeclaredConstructor().newInstance();

// populate a template file with values
final Map<String, String> templateReplacements = new HashMap<>();
templateReplacements.put("enrichment-steps-active", inventoryEnrichersList.toString());
final List<String> downloadTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("inventory-enrichment/template/inventory-enrichment-steps.md"), templateReplacements);
DocumentationGenerator.assertTemplateFullyFilled("inventory-enrichment-steps.md", downloadTargetLines);
FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("inventory-enrichment/inventory-enrichment-steps.md"), downloadTargetLines);
```
<!-- @formatter:on -->

If you need a template to fill your data into, create one in the nearest appropriate template directory.
Use `$gen{...}` placeholders to indicate where dynamic content should be inserted.
They will be processed by the `DocumentationGenerator.fillTemplate` method automatically.

Since most of the documentation pages are one-off processes,
you will likely not produce the most reusable or modular code, but I feel like that's fine.
It's better to have some documentation rather than none at all.

Remember to link to your page from the relevant pages and from the [main page](../vulnerability-management.md),
which serves as a hub to quickly navigate to the different parts of the documentation.
