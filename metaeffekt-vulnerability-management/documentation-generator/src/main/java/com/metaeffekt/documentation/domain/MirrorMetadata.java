package com.metaeffekt.documentation.domain;

import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

import java.util.*;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class MirrorMetadata {

    private final DocumentedType documentedType;

    public String getDirectoryName() {
        return documentedType.getAnnotationStringValue("MirrorMetadata", "directoryName").orElse("???");
    }

    public String getMavenPropertyName() {
        return documentedType.getAnnotationStringValue("MirrorMetadata", "mavenPropertyName").orElse("???");
    }

    public List<ResourceLocationEntry> getResourceLocations() {
        List<ResourceLocationEntry> entries = new ArrayList<>();

        // Find nested ResourceLocation enum. Traverse hierarchy if not found in concrete class.
        JavaClass resEnum = null;
        JavaClass current = documentedType.getJavaClass();

        while (current != null && !current.getName().equals("java.lang.Object")) {
            resEnum = current.getNestedClasses().stream()
                    .filter(c -> c.isEnum() && c.getName().contains("ResourceLocation"))
                    .findFirst()
                    .orElse(null);

            if (resEnum != null) break;
            current = current.getSuperJavaClass();
        }

        if (resEnum != null) {
            for (JavaField c : resEnum.getEnumConstants()) {
                if (!c.getEnumConstantArguments().isEmpty()) {
                    String val = c.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "");
                    String comment = c.getComment();
                    entries.add(new ResourceLocationEntry(c.getName(), val, comment));
                }
            }
        }
        return entries;
    }

    public Map<String, List<DocumentedType>> getIndexDependencies() {
        Map<String, List<DocumentedType>> map = new LinkedHashMap<>();

        // Look for any annotation ending with IndexDependencies (e.g. NvdIndexDependencies, etc.)
        JavaAnnotation ann = documentedType.getJavaClass().getAnnotations().stream()
                .filter(a -> a.getType().getValue().endsWith("IndexDependencies"))
                .findFirst().orElse(null);

        map.put("Download", resolveDeps(ann, "requiredDownloads"));
        map.put("Index", resolveDeps(ann, "requiredIndexes"));
        map.put("Optional Download", resolveDeps(ann, "optionalDownloads"));
        map.put("Optional Index", resolveDeps(ann, "optionalIndexes"));

        return map;
    }

    private List<DocumentedType> resolveDeps(JavaAnnotation ann, String prop) {
        if (ann == null) return Collections.emptyList();
        AnnotationValue val = ann.getProperty(prop);
        if (val == null) return Collections.emptyList();

        List<String> names = (val.getParameterValue() instanceof List) ?
                (List<String>) val.getParameterValue() :
                Collections.singletonList(val.getParameterValue().toString());

        return names.stream()
                .map(s -> s.replace(".class", "").replace("\"", "").trim())
                .filter(s -> !s.isEmpty())
                .map(s -> documentedType.getContext().getType(s))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    @Getter
    @RequiredArgsConstructor
    public static class ResourceLocationEntry {
        private final String name;
        private final String value;
        private final String description;
    }
}