package com.metaeffekt.documentation.generator;

import com.metaeffekt.artifact.analysis.utils.TimeUtils;
import com.metaeffekt.documentation.DocumentationGenerator;
import com.metaeffekt.documentation.IDocumentationGenerator;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.metaeffekt.documentation.util.MarkdownDocUtils;
import com.metaeffekt.mirror.contents.advisory.AdvisoryEntry;
import com.metaeffekt.mirror.contents.advisory.MsrcAdvisorEntry;
import com.metaeffekt.mirror.contents.base.Reference;
import com.metaeffekt.mirror.contents.msrcdata.MsrcProduct;
import com.metaeffekt.mirror.contents.msrcdata.MsrcRemediation;
import com.metaeffekt.mirror.contents.msrcdata.MsrcSupersedeNode;
import com.metaeffekt.mirror.query.MsrcAdvisorIndexQuery;
import com.metaeffekt.mirror.query.MsrcKbChainIndexQuery;
import com.metaeffekt.mirror.query.MsrcProductIndexQuery;
import com.thoughtworks.qdox.JavaProjectBuilder;
import lombok.Data;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ObjectUtils;

import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class MsrcKbChainForProducts implements IDocumentationGenerator {

    @Override
    public void generateDocumentation(JavaProjectBuilder project) throws Exception {
        final MsrcKbChainIndexQuery chainQuery = new MsrcKbChainIndexQuery(DocumentationProperties.getMirrorPath());
        final MsrcAdvisorIndexQuery advisorQuery = new MsrcAdvisorIndexQuery(DocumentationProperties.getMirrorPath());
        final MsrcProductIndexQuery productQuery = new MsrcProductIndexQuery(DocumentationProperties.getMirrorPath());

        final List<ProductQueryInformation> queryForProducts = Arrays.asList(
                new ProductQueryInformation("Windows 10", Pattern.compile("^Windows 10.+"), "Windows 10", Arrays.asList("Windows 10 Mobile"))
        );

        final Map<ProductQueryInformation, List<MsrcProduct>> products = queryForProducts.stream()
                .collect(Collectors.toMap(query -> query, query -> query.findProducts(productQuery)));

        final Map<String, KbInformation> cachedKbInformation = new HashMap<>();

        final Map<String, String> templateReplacements = new HashMap<>();
        final StringJoiner productInfo = new StringJoiner("\n\n");
        final StringJoiner toc = new StringJoiner("\n- ", "- ", "");
        templateReplacements.put("gen-date", TimeUtils.formatNormalizedDate(new Date(chainQuery.getIndex().getDirectoryLastModified())));

        for (Map.Entry<ProductQueryInformation, List<MsrcProduct>> entry : products.entrySet()) {
            final StringBuilder productEntry = new StringBuilder();
            productEntry.append("### ").append(entry.getKey().getDisplayName()).append("\n\n");
            toc.add("[" + entry.getKey().getDisplayName() + "](#" + MarkdownDocUtils.toMarkdownId(entry.getKey().getDisplayName()) + ")");

            final ProductQueryInformation query = entry.getKey();
            final List<MsrcProduct> foundProducts = entry.getValue();

            System.out.println("Found " + foundProducts.size() + " products for query: " + query.getQueryString());
            for (MsrcProduct product : foundProducts) {
                productEntry.append("<details>\n<summary>").append(product.getName()).append(" (").append(product.getId()).append(")</summary>\n\n")
                        .append("| KB ID | Date Range | Advisories |\n")
                        .append("|-------|------------|------------|\n");

                final List<KbInformation> kbInformation = chainQuery.findNodesByProductId(product.getId()).stream()
                        .map(kbNode -> cachedKbInformation.computeIfAbsent(kbNode.getKbId(), kbId -> KbInformation.construct(kbNode, advisorQuery)))
                        .sorted(Comparator.comparing(KbInformation::getFirstCreateTime).reversed())
                        .collect(Collectors.toList());

                System.out.println("  - " + product.getName() + " (" + kbInformation.size() + " KBs)");
                System.out.println("    - " + kbInformation.stream().map(KbInformation::getKbNode).map(MsrcSupersedeNode::getKbId).collect(Collectors.joining(", ")));

                for (KbInformation kb : kbInformation) {
                    productEntry
                            .append("| ")
                            .append("[").append(kb.getKbNode().getKbId()).append("](")
                            .append(ObjectUtils.firstNonNull(
                                    kb.getKbNode().getArticleUrl(),
                                    kb.getKbNode().getDownloadUrl(),
                                    kb.getAdvisories().stream().map(MsrcAdvisorEntry::getMsRemediations).filter(r -> r.stream().anyMatch(e -> e.getDescription().equals(kb.getKbNode().getKbId()))).flatMap(Collection::stream).map(MsrcRemediation::getUrl).filter(Objects::nonNull).map(Reference::getUrl).filter(Objects::nonNull).findFirst().orElse(null),
                                    "https://www.catalog.update.microsoft.com/Search.aspx?q=KB" + kb.getKbNode().getKbId()
                            ))
                            .append(")")
                            .append(" | ")
                            .append(TimeUtils.formatNormalizedDate(kb.getFirstCreateTime())).append(" - ").append(TimeUtils.formatNormalizedDate(kb.getLastUpdateTime()))
                            .append(" | ")
                            .append(kb.getAdvisories().size())
                            .append(!kb.getAdvisories().isEmpty() ? " (" + kb.getAdvisories().stream().sorted(AdvisoryEntry.UPDATE_CREATE_TIME_COMPARATOR).limit(2).map(e -> "[" + e.getId() + "](" + e.getUrl() + ")").collect(Collectors.joining(", ")) + (kb.getAdvisories().size() > 2 ? ", ..." : "") + ")" : "")
                            .append(" |\n");
                }

                productEntry.append("</details>\n");
            }

            productInfo.add(productEntry);
        }

        templateReplacements.put("toc", toc.toString());
        templateReplacements.put("products", productInfo.toString());

        final List<String> downloadTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/template/msrc-product-kbs.md"), templateReplacements);
        DocumentationGenerator.assertTemplateFullyFilled("msrc-product-kbs.md", downloadTargetLines);
        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/msrc/msrc-product-kbs.md"), downloadTargetLines);
    }

    @Data
    private static class ProductQueryInformation {
        private final String queryString;
        private final Pattern namePattern;
        private final String displayName;
        private final List<String> excludeProductNames;

        public List<MsrcProduct> findProducts(MsrcProductIndexQuery query) {
            return query.findProductByNameFuzzyIfNoExactMatch(queryString).stream()
                    .filter(product -> namePattern == null || namePattern.matcher(product.getName()).matches())
                    .filter(product -> excludeProductNames == null || excludeProductNames.stream().noneMatch(exclude -> product.getName().equals(exclude)))
                    .sorted(Comparator.comparing(MsrcProduct::getName))
                    .collect(Collectors.toList());
        }
    }

    @Data
    private static class KbInformation {
        private final MsrcSupersedeNode kbNode;
        private final List<MsrcAdvisorEntry> advisories;
        private final Date firstCreateTime;
        private final Date lastUpdateTime;

        public static KbInformation construct(MsrcSupersedeNode kbNode, MsrcAdvisorIndexQuery advisorQuery) {
            final List<MsrcAdvisorEntry> relatedAdvisories = advisorQuery.findAdvisorsByMsrcRemediationSupersededByKbId(kbNode.getKbId());
            final long firstCreateTime = relatedAdvisories.stream().map(MsrcAdvisorEntry::getCreateDate).map(Date::getTime).min(Long::compareTo).orElse(0L);
            final long lastUpdateTime = relatedAdvisories.stream().map(MsrcAdvisorEntry::getUpdateDate).map(Date::getTime).max(Long::compareTo).orElse(0L);

            return new KbInformation(kbNode, relatedAdvisories, TimeUtils.tryParse(firstCreateTime), TimeUtils.tryParse(lastUpdateTime));
        }
    }
}
