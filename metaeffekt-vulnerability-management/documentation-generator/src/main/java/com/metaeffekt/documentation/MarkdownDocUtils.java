package com.metaeffekt.documentation;

import com.thoughtworks.qdox.model.JavaClass;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public abstract class MarkdownDocUtils {

    public static List<JavaClass> excludeAllThatAreExtendedByOthers(List<JavaClass> classes) {
        final Set<String> extendedClasses = new HashSet<>();
        for (JavaClass clazz : classes) {
            for (JavaClass other : classes) {
                if (other.getSuperJavaClass() != null && other.getSuperJavaClass().getName().equals(clazz.getName())) {
                    extendedClasses.add(clazz.getName());
                    System.out.println("Excluding " + clazz.getName() + " because it is extended by " + other.getName());
                }
            }
        }

        return classes.stream().filter(c -> !extendedClasses.contains(c.getName())).collect(Collectors.toList());
    }

    public static boolean isDeprecated(JavaClass clazz) {
        return clazz.getAnnotations().stream().anyMatch(a -> a.getType().getValue().equals("Deprecated"));
    }

    public static final Set<String> FORMAT_CLASS_UPPERCASE_NAMES = new HashSet<>(Arrays.asList("msrc", "cert", "cve", "nist", "cwe", "cvss", "cpe", "cve", "nvd", "nist", "cwe", "cvss", "cpe", "csv", "api", "kb", "kev", "ghsa", "epss", "eol", "csaf", "cisa"));
    public static final Set<String> FORMAT_CLASS_LOWERCASE_NAMES = new HashSet<>(Arrays.asList("from", "by", "filling"));

    /**
     * Formats a mirror class name such that it is human-readable:
     * <p>
     * MsrcSecurityGuideDownload becomes "MSRC Security Guide"<br>
     * CertEuIndex becomes "CERT-EU Index"
     *
     * @param clazz The class to format
     * @return The formatted class name
     */
    public static String formatClassName(String clazz) {
        if (clazz == null || clazz.isEmpty()) {
            return "";
        }
        final String[] parts = clazz.split("(?=[A-Z])");
        final StringJoiner joiner = new StringJoiner(" ");
        for (String part : parts) {
            if (part.equals("Download") || part.equals("Index") || part.equals("Query") || part.equals("Enrichment")) {
                continue;
            }

            if (FORMAT_CLASS_UPPERCASE_NAMES.contains(part.toLowerCase())) {
                joiner.add(part.toUpperCase());
            } else if (FORMAT_CLASS_LOWERCASE_NAMES.contains(part.toLowerCase())) {
                joiner.add(part.toLowerCase());
            } else {
                joiner.add(part.substring(0, 1).toUpperCase() + part.substring(1).toLowerCase());
            }
        }

        final String baseValue = joiner.toString();
        String transformedValue = baseValue;

        transformedValue = transformedValue.replace("Post Processing", "post-processing");

        // CERT Eu --> CERT-EU and other CERTs
        final Pattern certPattern = Pattern.compile("(.*)(cert[ -]?[a-z0-9]+)(.*)", Pattern.CASE_INSENSITIVE);
        final Matcher certMatcher = certPattern.matcher(transformedValue);
        if (certMatcher.matches()) {
            transformedValue = certMatcher.group(1) + "CERT-" + certMatcher.group(2).substring(5).toUpperCase() + certMatcher.group(3);
        }

        return transformedValue;
    }

    public static String formatClassName(JavaClass clazz) {
        final String enricherName = InventoryEnrichmentStepsDocumentationGenerator.getEnricherName(clazz);
        if (enricherName != null && !enricherName.isEmpty()) {
            return enricherName;
        }
        return formatClassName(clazz.getName());
    }

    public static String formatClassNameApplyDeprecated(JavaClass clazz) {
        return isDeprecated(clazz) ? "_" + formatClassName(clazz) + " (deprecated)_" : formatClassName(clazz);
    }

    public static String toMarkdownId(String name) {
        return name.toLowerCase().replace(" ", "-").replaceAll("[^a-z0-9-]", "");
    }

    public static String unindentCodeBlock(String codeBlock, int indent) {
        final String[] lines = codeBlock.split("\n");

        // remove the smallest indentation from all lines
        final StringBuilder unindented = new StringBuilder();
        for (String line : lines) {
            final boolean shouldUnindent = line.length() >= indent && line.substring(0, indent).chars().allMatch(c -> c == ' ');
            if (shouldUnindent) {
                unindented.append(line.substring(indent)).append("\n");
            } else {
                unindented.append(line).append("\n");
            }
        }

        return trimNewlinesAndSpaces(unindented.toString());
    }

    public static String trimNewlinesAndSpaces(String input) {
        return input.replaceAll("^\\s+", "").replaceAll("\\s+$", "");
    }

    public static String retainMiddlePart(String input, String start, String end) {
        return input.substring(input.indexOf(start) + start.length(), input.lastIndexOf(end));
    }

    public static String xmlEncode(String input) {
        return input.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace("\"", "&quot;").replace("'", "&apos;");
    }

    public static String indent(String input, int indent) {
        final String[] lines = input.split("\n");
        final StringBuilder indented = new StringBuilder();
        final String indentStr = IntStream.range(0, indent).mapToObj(i -> " ").collect(Collectors.joining());
        for (String line : lines) {
            indented.append(indentStr).append(line).append("\n");
        }
        return indented.toString();
    }

    public static <T> T firstNonNull(T... values) {
        for (T value : values) {
            if (value != null) {
                return value;
            }
        }
        return null;
    }

    public static String unwrapJavaDocLink(String input) {
        if (input.contains("{@link")) {
            return input.replaceAll("\\{@link ([^}]+)}", "<code>$1</code>");
        } else {
            return input;
        }
    }
}
