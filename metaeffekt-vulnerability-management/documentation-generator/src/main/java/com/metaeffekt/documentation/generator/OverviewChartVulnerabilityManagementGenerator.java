package com.metaeffekt.documentation.generator;

import com.metaeffekt.documentation.DocumentationGenerator;
import com.metaeffekt.documentation.IDocumentationGenerator;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.metaeffekt.mirror.index.Index;
import com.metaeffekt.mirror.query.IndexQuery;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.JavaType;
import com.thoughtworks.qdox.model.impl.DefaultJavaParameterizedType;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class OverviewChartVulnerabilityManagementGenerator implements IDocumentationGenerator {

    public void generateDocumentation(JavaProjectBuilder project) throws IOException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        final List<JavaClass> inventoryEnrichmentClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderEnrichmentClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.artifact.enrichment.InventoryEnricher")));
        inventoryEnrichmentClasses.removeIf(c -> InventoryEnrichmentStepsDocumentationGenerator.EXCLUDED_ENRICHERS.contains(c.getFullyQualifiedName()));
        final Map<String, List<JavaClass>> enrichersByPhase = InventoryEnrichmentStepsDocumentationGenerator.groupEnrichersByPhases(inventoryEnrichmentClasses);
        for (String phase : InventoryEnrichmentStepsDocumentationGenerator.POM_EXCLUDED_ENRICHMENT_PHASES) {
            inventoryEnrichmentClasses.removeAll(enrichersByPhase.get(phase));
        }
        enrichersByPhase.keySet().removeAll(InventoryEnrichmentStepsDocumentationGenerator.POM_EXCLUDED_ENRICHMENT_PHASES);

        final List<JavaClass> downloadClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.download.Download")));
        final List<JavaClass> indexClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.index.Index")));

        final Map<JavaClass, Map<String, List<JavaClass>>> indexClassDependencies = new LinkedHashMap<>();
        for (JavaClass indexClass : indexClasses) {
            indexClassDependencies.put(indexClass, MirrorDocumentationGenerator.getIndexDependencies(project, indexClass));
        }

        final List<JavaClass> indexQueryClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.query.IndexQuery")));
        final Map<JavaClass, List<JavaClass>> indexQueryUsages = new LinkedHashMap<>();
        for (JavaClass enrichmentClass : inventoryEnrichmentClasses) {
            indexQueryUsages.put(enrichmentClass, getEnricherIndexQueryUsages(enrichmentClass, indexQueryClasses));
        }

        final Map<JavaClass, Index> indexUsageInIndexQuery = new LinkedHashMap<>();
        for (JavaClass indexQuery : indexQueryClasses) {
            if (indexQuery.getFullyQualifiedName().contains("CustomVulnerabilityIndexQuery")) continue;

            try {
                final Class<?> indexQueryClass = DocumentationGenerator.loadClass(indexQuery.getFullyQualifiedName());
                final Object indexQueryInstance = indexQueryClass.getConstructor(File.class).newInstance(DocumentationProperties.getMirrorPath());
                final IndexQuery typedIndexQueryInstance = (IndexQuery) indexQueryInstance;
                indexUsageInIndexQuery.put(indexQuery, typedIndexQueryInstance.getIndex());
            } catch (Exception e) {
                log.error("Failed to create query instance for class {}", indexQuery, e);
            }
        }

        final JSONArray nodes = new JSONArray();
        final JSONArray edges = new JSONArray();

        // Create swimlanes/groups
        JSONObject downloadersGroup = new JSONObject();
        downloadersGroup.put("data", new JSONObject().put("id", "downloadersGroup").put("label", "Downloaders")).put("classes", new JSONArray().put("graph-container"));
        nodes.put(downloadersGroup);

        JSONObject indexesGroup = new JSONObject();
        indexesGroup.put("data", new JSONObject().put("id", "indexesGroup").put("label", "Indexes")).put("classes", new JSONArray().put("graph-container"));
        nodes.put(indexesGroup);

        JSONObject indexQueriesGroup = new JSONObject();
        indexQueriesGroup.put("data", new JSONObject().put("id", "indexQueriesGroup").put("label", "Index Queries")).put("classes", new JSONArray().put("graph-container"));
        nodes.put(indexQueriesGroup);

        JSONObject enrichersGroup = new JSONObject();
        enrichersGroup.put("data", new JSONObject().put("id", "enrichersGroup").put("label", "Enrichment Pipeline")).put("classes", new JSONArray().put("graph-container"));
        nodes.put(enrichersGroup);

        // Swimlanes for Enrichment Phases (under Enrichers)
        for (String phase : enrichersByPhase.keySet()) {
            nodes.put(new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", "phaseGroup_" + phase)
                            .put("label", InventoryEnrichmentPhase.valueOf(phase).displayName())
                            .put("parent", "enrichersGroup"))
                    .put("classes", new JSONArray().put("graph-container").put("enricher-phase")));
        }

        // Nodes for Downloaders
        for (JavaClass downloader : downloadClasses) {
            final JavaAnnotation metadata = MirrorDocumentationGenerator.getMirrorMetadata(downloader);
            final String directoryName = MirrorDocumentationGenerator.getAnnotationStringValue(metadata, "directoryName");
            final String mavenPropertyName = MirrorDocumentationGenerator.getAnnotationStringValue(metadata, "mavenPropertyName");
            final String displayName = formatClassName(downloader.getName());
            final JSONArray classes = new JSONArray().put("graph-node").put("downloader");
            if (isDeprecated(downloader)) classes.put("deprecated");
            nodes.put(new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", downloader.getFullyQualifiedName())
                            .put("label", "<b>" + displayName + "</b><br>" + directoryName + " / " + mavenPropertyName)
                            .put("parent", "downloadersGroup"))
                    .put("classes", classes));
        }

        // Nodes for Indexes
        for (JavaClass index : indexClasses) {
            final JavaAnnotation metadata = MirrorDocumentationGenerator.getMirrorMetadata(index);
            final String directoryName = MirrorDocumentationGenerator.getAnnotationStringValue(metadata, "directoryName");
            final String mavenPropertyName = MirrorDocumentationGenerator.getAnnotationStringValue(metadata, "mavenPropertyName");
            final String displayName = formatClassName(index.getName());
            final JSONArray classes = new JSONArray().put("graph-node").put("index");
            if (isDeprecated(index)) classes.put("deprecated");
            nodes.put(new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", index.getFullyQualifiedName())
                            .put("label", "<b>" + displayName + "</b><br>" + directoryName + " / " + mavenPropertyName)
                            .put("parent", "indexesGroup"))
                    .put("classes", classes));
        }

        // Nodes for IndexQueries
        for (JavaClass indexQuery : indexQueryClasses) {
            final JSONArray classes = new JSONArray().put("graph-node").put("index-query");
            if (isDeprecated(indexQuery)) classes.put("deprecated");
            nodes.put(new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", indexQuery.getFullyQualifiedName())
                            .put("label", "<b>" + formatClassName(indexQuery) + "</b>")
                            .put("parent", "indexQueriesGroup"))
                    .put("classes", classes));
        }

        // Nodes for Enrichers, grouped by phase
        for (Map.Entry<String, List<JavaClass>> entry : enrichersByPhase.entrySet()) {
            final String phase = entry.getKey();
            final String phaseGroupId = "phaseGroup_" + phase;
            final List<JavaClass> enrichersInPhase = entry.getValue();

            for (JavaClass enricher : enrichersInPhase) {
                final String intermediateFileSuffix = InventoryEnrichmentStepsDocumentationGenerator.getEnricherIntermediateFileSuffix(enricher);
                final String mavenPropertyName = InventoryEnrichmentStepsDocumentationGenerator.getEnricherMavenPropertyName(enricher);
                nodes.put(new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", enricher.getFullyQualifiedName())
                                .put("label", "<b>" + formatClassName(enricher) + "</b><br>" + intermediateFileSuffix + " / " + mavenPropertyName)
                                .put("parent", phaseGroupId))
                        .put("classes", new JSONArray().put("graph-node").put("enricher")));
            }
        }

        // connection between Downloaders and Indexes using indexClassDependencies
        for (JavaClass index : indexClasses) {
            final Map<String, List<JavaClass>> dependencies = indexClassDependencies.get(index);
            for (Map.Entry<String, List<JavaClass>> entry : dependencies.entrySet()) {
                final String dependencyType = entry.getKey();
                final List<JavaClass> dependentClasses = entry.getValue();
                for (JavaClass dependentClass : dependentClasses) {
                    edges.put(new JSONObject()
                            .put("data", new JSONObject()
                                    .put("source", dependentClass.getFullyQualifiedName())
                                    .put("target", index.getFullyQualifiedName())
                                    .put("label", dependencyType)));
                }
            }
        }

        // connection between Indexes and IndexQueries
        for (Map.Entry<JavaClass, List<JavaClass>> entry : indexQueryUsages.entrySet()) {
            final JavaClass enricher = entry.getKey();
            final String enricherId = enricher.getFullyQualifiedName();
            final List<JavaClass> usedIndexQueries = entry.getValue();
            for (JavaClass indexQuery : usedIndexQueries) {
                final String indexQueryId = indexQuery.getFullyQualifiedName();
                edges.put(new JSONObject()
                        .put("data", new JSONObject()
                                .put("source", indexQueryId)
                                .put("target", enricherId)));
            }
        }

        // connection between Indexes and IndexQueries, there is a 1:1 relationship
        for (Map.Entry<JavaClass, Index> entry : indexUsageInIndexQuery.entrySet()) {
            final JavaClass indexQuery = entry.getKey();
            final String indexQueryId = indexQuery.getFullyQualifiedName();
            final Index indexInstanceInstance = entry.getValue();
            final String indexId = indexInstanceInstance.getClass().getName();
            edges.put(new JSONObject()
                    .put("data", new JSONObject()
                            .put("source", indexId)
                            .put("target", indexQueryId)));
        }

        // iterate over all phases and add edges between the previous and the next phase
        /*final ArrayList<String> enrichmentPhases = new ArrayList<>(enrichersByPhase.keySet());
        for (int i = 0; i < enrichmentPhases.size() - 1; i++) {
            final String sourcePhase = enrichmentPhases.get(i);
            final String targetPhase = enrichmentPhases.get(i + 1);
            edges.put(new JSONObject()
                    .put("data", new JSONObject()
                            .put("source", "phaseGroup_" + sourcePhase)
                            .put("target", "phaseGroup_" + targetPhase)));
        }*/


        final Map<String, String> templateReplacements = new HashMap<>();

        templateReplacements.put("nodes", nodes.toString().replace("\\/", "/"));
        templateReplacements.put("edges", edges.toString().replace("\\/", "/"));
        templateReplacements.put("png-save-scale", "3");
        templateReplacements.put("download-name", "large-overview-diagram");

        final List<String> targetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("template/large-overview-diagram.html"), templateReplacements);
        DocumentationGenerator.assertTemplateFullyFilled("large-overview-diagram.html", targetLines);
        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("large-overview-diagram.html"), targetLines);
    }

    public static List<JavaClass> getEnricherIndexQueryUsages(JavaClass enricherClass, List<JavaClass> indexQueryClasses) {
        final List<JavaClass> usages = new ArrayList<>();

        final Map<JavaClass, List<JavaField>> aggregatedFields = new LinkedHashMap<>();
        recursiveFindAllFields(enricherClass, aggregatedFields);

        for (Map.Entry<JavaClass, List<JavaField>> reference : aggregatedFields.entrySet()) {
            for (JavaField field : reference.getValue()) {
                for (JavaClass type : getAllTypes(field)) {
                    if (indexQueryClasses.contains(type)) {
                        usages.add(type);
                    }
                }
            }
        }

        return usages;
    }

    private static void recursiveFindAllFields(JavaClass clazz, Map<JavaClass, List<JavaField>> aggregatedFields) {
        if (aggregatedFields.containsKey(clazz)) {
            return;
        }

        try {
            aggregatedFields.put(clazz, new ArrayList<>(clazz.getFields()));
        } catch (Exception e) {
            if (!clazz.getFullyQualifiedName().startsWith("?")) {
                System.err.println("Error processing class " + clazz.getFullyQualifiedName());
            }
            return;
        }

        // superclass
        if (clazz.getSuperJavaClass() != null) {
            recursiveFindAllFields(clazz.getSuperJavaClass(), aggregatedFields);
        }

        // go into fields
        for (JavaField field : clazz.getFields()) {
            final JavaClass type = field.getType();
            recursiveFindAllFields(type, aggregatedFields);

            if (type instanceof DefaultJavaParameterizedType) {
                final DefaultJavaParameterizedType parameterizedType = (DefaultJavaParameterizedType) type;
                for (JavaType typeArgument : parameterizedType.getActualTypeArguments()) {
                    if (typeArgument instanceof JavaClass) {
                        recursiveFindAllFields((JavaClass) typeArgument, aggregatedFields);
                    }
                }
            }
        }
    }

    private static List<JavaClass> getAllTypes(JavaField field) {
        final List<JavaClass> types = new ArrayList<>();
        types.add(field.getType());

        if (field.getType() instanceof DefaultJavaParameterizedType) {
            final DefaultJavaParameterizedType parameterizedType = (DefaultJavaParameterizedType) field.getType();
            for (JavaType typeArgument : parameterizedType.getActualTypeArguments()) {
                if (typeArgument instanceof JavaClass) {
                    types.add((JavaClass) typeArgument);
                }
            }
        }

        return types;
    }
}
