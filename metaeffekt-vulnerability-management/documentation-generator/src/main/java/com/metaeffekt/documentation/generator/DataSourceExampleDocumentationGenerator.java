package com.metaeffekt.documentation.generator;

import com.metaeffekt.artifact.analysis.utils.StringUtils;
import com.metaeffekt.artifact.analysis.utils.TimeUtils;
import com.metaeffekt.documentation.DocumentationGenerator;
import com.metaeffekt.documentation.IDocumentationGenerator;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.metaeffekt.mirror.index.Index;
import com.metaeffekt.mirror.query.IndexQuery;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaMethod;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.apache.lucene.document.Document;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class DataSourceExampleDocumentationGenerator implements IDocumentationGenerator {

    private final static int AMOUNT_EXAMPLES_PER_INDEX = 40;

    private final static boolean TESTING = false;
    private final static int MAX_SKIP_COUNT = TESTING ? 100 : 6000;

    private final static int AMOUNT_DISPLAY_EXAMPLES_PER_INDEX = 5;
    private final static int MAX_EXAMPLE_LENGTH = 1300;

    private final static List<String> FIELD_NAME_DISPLAY_ORDER = Arrays.asList(
            "id",
            "name",
            "url",
            "link",
            "summary",
            "description",
            "cwe",
            "cpe23Uri",
            "product",
            "vendor",
            "type",
            "family",
            "vulnerability",
            "cvssVectors",
            "cvss",
            "severity",
            "threat",
            "affectedProducts",
            "createDate",
            "updateDate",
            "lastModified",
            "releaseDate",
            "publishDate",
            "dueDate",
            "nvdPublishedAt",
            "knownRansomwareCampaignUse",
            "eol",
            "lts",
            "support",
            "cycle",
            "latestReleaseDate",
            "latest",
            "deprecated",
            "references",
            "kbId",
            "rel",
            "recommendations",
            "recommendation",
            "workarounds",
            "msRemediations",
            "implementation",
            "sourceImplementation",
            "other",
            "vulnerable_software",
            "vulnerable_software_vp",
            "titles",
            "version",
            "language",
            "part",
            "edition",
            "update",
            "sources",
            "acknowledgements",
            "keywords",
            "percentile",
            "epssScore"
    );

    public void generateDocumentation(JavaProjectBuilder project) throws IOException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        final List<JavaClass> indexJavaClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.index.Index")));
        final List<Class<? extends Index>> indexClasses = findClasses(indexJavaClasses);

        final List<JavaClass> indexQueryClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.query.IndexQuery")));
        final Map<Class<? extends Index>, JavaClass> indexUsageInIndexQuery = new LinkedHashMap<>();
        for (JavaClass indexQuery : indexQueryClasses) {
            if (indexQuery.getFullyQualifiedName().contains("CustomVulnerabilityIndexQuery")) continue;
            if (indexQuery.getFullyQualifiedName().contains("GhsaAdvisorIndexQuery")) continue;

            try {
                final Class<?> indexQueryClass = DocumentationGenerator.loadClass(indexQuery.getFullyQualifiedName());
                final Object indexQueryInstance = indexQueryClass.getConstructor(File.class).newInstance(DocumentationProperties.getMirrorPath());
                final IndexQuery typedIndexQueryInstance = (IndexQuery) indexQueryInstance;
                indexUsageInIndexQuery.put(typedIndexQueryInstance.getIndex().getClass(), indexQuery);
            } catch (Exception e) {
                log.error("Failed to create query instance for class {}", indexQuery, e);
            }
        }

        final List<IndexExample> indexQueryExampleDocuments = selectExampleDocuments(indexClasses);
        final Map<String, String> templateReplacements = new HashMap<>();

        final StringBuilder indexExamples = new StringBuilder();

        for (IndexExample indexExample : indexQueryExampleDocuments) {
            final Index index = indexExample.getIndex();
            final int documentCount = indexExample.getDocumentCount();
            final String indexTime = indexExample.getIndexTime();
            final List<Document> documents = indexExample.getDocuments();

            final String name = formatClassNameApplyDeprecated(index.getClass());
            final String directoryName = index.getMirrorMetadata().directoryName();
            final String mavenPropertyName = index.getMirrorMetadata().mavenPropertyName();
            indexExamples.append("## ").append(name).append("\n\n")
                    .append("`").append(directoryName).append("`").append(" / `").append(mavenPropertyName)
                    .append("`  \n`").append(documentCount).append("` documents as of `").append(indexTime).append("`\n\n");


            final Map<String, Set<String>> fields = new HashMap<>();
            for (Document document : documents) {
                document.getFields()
                        .forEach(field -> {
                            final String fieldName = field.name();
                            fields.computeIfAbsent(fieldName, k -> new LinkedHashSet<>()).add(field.stringValue().trim().replace("\n", "<br>"));
                        });
            }

            indexExamples.append("| Field | Random Examples |\n")
                    .append("| --- | --- |\n");
            fields.entrySet().stream()
                    .sorted(Comparator.comparingInt(entry -> FIELD_NAME_DISPLAY_ORDER.indexOf(entry.getKey())))
                    .forEach(entry -> {
                        final String fieldName = entry.getKey();

                        final Set<String> examples = entry.getValue().stream().filter(StringUtils::notEmpty).collect(LinkedHashSet::new, LinkedHashSet::add, LinkedHashSet::addAll);
                        final StringJoiner examplesJoiner = new StringJoiner("`<br>`", "`", "`").setEmptyValue("No examples found");
                        examples.stream()
                                // randomize order
                                .sorted(Comparator.comparingInt(String::hashCode))
                                .limit(AMOUNT_DISPLAY_EXAMPLES_PER_INDEX)
                                .filter(example -> example.length() < MAX_EXAMPLE_LENGTH)
                                .forEach(examplesJoiner::add);

                        final Set<String> detectedTypes = examples.stream()
                                .map(this::tryToDetectFieldType)
                                .collect(LinkedHashSet::new, LinkedHashSet::add, LinkedHashSet::addAll);

                        indexExamples.append("| `").append(fieldName).append("`")
                                .append(detectedTypes.size() == 1 ? "<br>â†’ " + detectedTypes.iterator().next() : "")
                                .append(" | ").append(examplesJoiner).append(" |\n");
                    });

            indexExamples.append("\n");

            final JavaClass indexQuery = indexUsageInIndexQuery.get(index.getClass());
            if (indexQuery != null) {
                indexExamples.append("Used in Index Query **").append(formatClassName(indexQuery)).append("**, which provides the following query methods:\n\n");

                for (MirrorDocumentationGenerator.Pair<JavaClass, JavaMethod> method : findRelevantQueryMethods(indexQuery)) {
                    final MirrorDocumentationGenerator.Pair<String, JavaMethod> sourceCodeExpandable = MirrorDocumentationGenerator.createSourceCodeExpandable(method.getKey(), method.getValue());
                    indexExamples.append(sourceCodeExpandable.getKey());
                }

                indexExamples.append("\n");
            } else {
                indexExamples.append("Not used in any Index Query\n\n");
            }
        }

        templateReplacements.put("index-structure", indexExamples.toString());

        // toc
        final StringJoiner tocJoiner = new StringJoiner("\n");
        indexQueryExampleDocuments.forEach(indexExample -> {
            final Index index = indexExample.getIndex();
            final String name = formatClassNameApplyDeprecated(index.getClass());
            final String id = toMarkdownId(name);
            tocJoiner.add("- [" + name + "](#" + id + ")");
        });
        templateReplacements.put("toc", tocJoiner.toString());

        final List<String> targetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/template/index-examples.md"), templateReplacements);
        DocumentationGenerator.assertTemplateFullyFilled("index-examples.md", targetLines);
        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/index-examples.md"), targetLines);
    }

    private List<MirrorDocumentationGenerator.Pair<JavaClass, JavaMethod>> findRelevantQueryMethods(JavaClass indexQuery) {
        final List<MirrorDocumentationGenerator.Pair<JavaClass, JavaMethod>> relevantQueryMethods = new ArrayList<>();
        for (JavaMethod method : indexQuery.getMethods()) {
            if (!method.isAbstract() && method.getName().startsWith("find")) {
                relevantQueryMethods.add(new MirrorDocumentationGenerator.Pair<>(indexQuery, method));
            }
        }

        final JavaClass superClass = indexQuery.getSuperJavaClass();
        if (superClass != null) {
            if (superClass.getName().equals("IndexQuery")) return relevantQueryMethods;
            relevantQueryMethods.addAll(findRelevantQueryMethods(superClass));
        }

        return relevantQueryMethods;
    }

    private String tryToDetectFieldType(String value) {
        if (value == null) return "String";

        // timestamp (1618504804000, 2005-05-09, 2024-01-31T13:16:23.030)
        if (value.matches("\\d{13}")) return "timestamp";
        if (value.matches("\\d{4}-\\d{2}-\\d{2}")) return "timestamp";
        if (value.matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}")) return "timestamp";

        // general types
        if (value.matches("\\d+")) return "number";
        if (value.matches("\\d+\\.\\d+")) return "number";
        if (value.matches("true|false")) return "boolean";

        // json
        if (value.startsWith("{") && value.endsWith("}")) return "JSON Object";
        if (value.startsWith("[") && value.endsWith("]")) return "JSON Array";

        // link
        if (value.startsWith("http")) return "link";

        // cpe
        if (value.startsWith("cpe:")) return "CPE URI";

        return "String";
    }

    private static List<Class<? extends Index>> findClasses(List<JavaClass> classes) {
        return classes.stream().map(clazz -> {
            try {
                return (Class<? extends Index>) Class.forName(clazz.getFullyQualifiedName());
            } catch (ClassNotFoundException e) {
                throw new IllegalStateException("Class not found: " + clazz.getFullyQualifiedName(), e);
            }
        }).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
    }

    private List<IndexExample> selectExampleDocuments(List<Class<? extends Index>> indexQueryClasses) {
        final List<IndexExample> indexQueryExampleDocuments = new ArrayList<>();

        for (Class<? extends Index> indexClass : indexQueryClasses) {
            if (indexClass.getName().contains("CustomVulnerabilityIndexQuery")) continue;
            if (indexClass.getName().contains("GhsaAdvisorIndex")) continue;

            try {
                final Index index;
                try {
                    index = constructIndexInstance(indexClass);
                } catch (Exception e) {
                    if (isDeprecated(indexClass)) {
                        System.err.println("Could not construct deprecated index instance for class [" + indexClass + "] due to: " + e.getMessage());
                        continue;
                    }
                    throw new IllegalStateException("Could not construct index instance for class [" + indexClass + "]", e);
                }

                final AtomicInteger remainingExamples = new AtomicInteger(AMOUNT_EXAMPLES_PER_INDEX);
                final int skipPerExample = Math.max(0, Math.min(MAX_SKIP_COUNT, index.documentCount() / AMOUNT_EXAMPLES_PER_INDEX - remainingExamples.get()));
                final AtomicInteger skip = new AtomicInteger(skipPerExample);

                final IndexExample indexExample = new IndexExample(index);
                indexQueryExampleDocuments.add(indexExample);
                indexExample.setDocumentCount(index.documentCount());

                System.out.println("Processing index query: " + index + " with " + index.documentCount() + " documents, skipping " + skipPerExample + " documents per example.");

                index.findAndProcessAllDocumentsCancelable(document -> {
                    if (skip.getAndDecrement() > 0) return true;
                    skip.set(skipPerExample);

                    indexExample.getDocuments().add(document);
                    return remainingExamples.decrementAndGet() > 0;
                });
            } catch (Exception e) {
                throw new IllegalStateException("Failed to select example documents for [" + indexClass.getName() + "]: " + e.getMessage(), e);
            }
        }

        return indexQueryExampleDocuments;
    }

    @Data
    protected static class IndexExample {
        private final Index index;
        private List<Document> documents;
        private int documentCount;
        private String indexTime;

        public IndexExample(Index index) {
            this.index = index;
            this.documents = new ArrayList<>();
            this.documentCount = 0;
            this.indexTime = TimeUtils.formatNormalizedDate(new Date(index.getDirectoryLastUpdated()));
        }
    }

    private Index constructIndexInstance(Class<? extends Index> indexClass) {
        try {
            return indexClass.getConstructor(File.class).newInstance(DocumentationProperties.getMirrorPath());
        } catch (Exception e) {
            throw new IllegalStateException("Could not construct index class: " + indexClass, e);
        }
    }
}
