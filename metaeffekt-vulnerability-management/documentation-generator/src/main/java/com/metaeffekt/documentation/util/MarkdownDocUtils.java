package com.metaeffekt.documentation.util;

import com.metaeffekt.documentation.domain.DocumentedType;
import com.thoughtworks.qdox.model.JavaClass;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public abstract class MarkdownDocUtils {

    public static List<DocumentedType> excludeAllThatAreExtendedByOthers(List<DocumentedType> classes) {
        final Set<String> extendedClasses = new HashSet<>();
        for (DocumentedType clazz : classes) {
            for (DocumentedType other : classes) {
                JavaClass superClass = other.getJavaClass().getSuperJavaClass();
                if (superClass != null && superClass.getFullyQualifiedName().equals(clazz.getFullyQualifiedName())) {
                    extendedClasses.add(clazz.getFullyQualifiedName());
                }
            }
        }

        return classes.stream()
                .filter(c -> !extendedClasses.contains(c.getFullyQualifiedName()))
                .collect(Collectors.toList());
    }

    public static boolean isDeprecated(DocumentedType type) {
        return type.isDeprecated();
    }

    // Kept for compatibility if raw JavaClass is used in other contexts not yet refactored,
    // though internally we should move to DocumentedType.
    public static boolean isDeprecated(JavaClass clazz) {
        return clazz.getAnnotations().stream().anyMatch(a -> a.getType().getValue().equals("Deprecated"));
    }

    public static boolean isDeprecated(Class<?> clazz) {
        return clazz.isAnnotationPresent(Deprecated.class);
    }

    public static final Set<String> FORMAT_CLASS_UPPERCASE_NAMES = new HashSet<>(Arrays.asList("msrc", "cert", "cve", "nist", "cwe", "cvss", "cpe", "cve", "nvd", "nist", "cwe", "cvss", "cpe", "csv", "api", "kb", "kev", "ghsa", "epss", "eol", "csaf", "cisa", "osv", "capec"));
    public static final Set<String> FORMAT_CLASS_LOWERCASE_NAMES = new HashSet<>(Arrays.asList("from", "by", "filling"));

    /**
     * Formats a class name such that it is human-readable.
     * Uses EnricherMetadata name if present.
     */
    public static String formatClassName(DocumentedType type) {
        // Check for EnricherMetadata name override
        Optional<String> enricherName = type.getAnnotationStringValue("EnricherMetadata", "name");
        if (enricherName.isPresent() && !enricherName.get().isEmpty()) {
            return enricherName.get();
        }
        return formatClassName(type.getJavaClass().getName());
    }

    public static String formatClassName(String clazz) {
        if (clazz == null || clazz.isEmpty()) {
            return "";
        }
        if (clazz.contains(".")) {
            clazz = clazz.substring(clazz.lastIndexOf('.') + 1);
        }

        final String[] parts = clazz.split("(?=[A-Z])");
        final StringJoiner joiner = new StringJoiner(" ");
        for (String part : parts) {
            if (part.equals("Download") || part.equals("Index") || part.equals("Query") || part.equals("Enrichment")) {
                continue;
            }

            if (FORMAT_CLASS_UPPERCASE_NAMES.contains(part.toLowerCase())) {
                joiner.add(part.toUpperCase());
            } else if (FORMAT_CLASS_LOWERCASE_NAMES.contains(part.toLowerCase())) {
                joiner.add(part.toLowerCase());
            } else {
                joiner.add(part.substring(0, 1).toUpperCase() + part.substring(1).toLowerCase());
            }
        }

        String transformedValue = joiner.toString();
        transformedValue = transformedValue.replace("Post Processing", "post-processing");

        // CERT Eu --> CERT-EU and other CERTs
        final Pattern certPattern = Pattern.compile("(.*)(cert[ -]?[a-z0-9]+)(.*)", Pattern.CASE_INSENSITIVE);
        final Matcher certMatcher = certPattern.matcher(transformedValue);
        if (certMatcher.matches()) {
            transformedValue = certMatcher.group(1) + "CERT-" + certMatcher.group(2).substring(5).toUpperCase() + certMatcher.group(3);
        }

        return transformedValue;
    }

    public static String formatClassNameApplyDeprecated(DocumentedType type) {
        return type.isDeprecated() ? "_" + formatClassName(type) + " (deprecated)_" : formatClassName(type);
    }

    public static String formatClassNameApplyDeprecated(Class<?> clazz) {
        return isDeprecated(clazz) ? "_" + formatClassName(clazz.getSimpleName()) + " (deprecated)_" : formatClassName(clazz.getSimpleName());
    }

    public static String toMarkdownId(String name) {
        return name.toLowerCase().replace(" ", "-").replaceAll("[^a-z0-9-]", "");
    }

    public static String unindentCodeBlock(String codeBlock, int indent) {
        final String[] lines = codeBlock.split("\n");

        // remove the smallest indentation from all lines
        final StringBuilder unindented = new StringBuilder();
        for (String line : lines) {
            final boolean shouldUnindent = line.length() >= indent && line.substring(0, indent).chars().allMatch(c -> c == ' ');
            if (shouldUnindent) {
                unindented.append(line.substring(indent)).append("\n");
            } else {
                unindented.append(line).append("\n");
            }
        }

        return trimNewlinesAndSpaces(unindented.toString());
    }

    public static String trimNewlinesAndSpaces(String input) {
        return input.replaceAll("^\\s+", "").replaceAll("\\s+$", "");
    }

    public static String retainMiddlePart(String input, String start, String end) {
        try {
            return input.substring(input.indexOf(start) + start.length(), input.lastIndexOf(end));
        } catch (Exception e) {
            return input;
        }
    }

    public static String xmlEncode(String input) {
        return input.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace("\"", "&quot;").replace("'", "&apos;");
    }

    public static String indent(String input, int indent) {
        final String[] lines = input.split("\n");
        final StringBuilder indented = new StringBuilder();
        final String indentStr = IntStream.range(0, indent).mapToObj(i -> " ").collect(Collectors.joining());
        for (String line : lines) {
            indented.append(indentStr).append(line).append("\n");
        }
        return indented.toString();
    }

    public static <T> T firstNonNull(T... values) {
        for (T value : values) {
            if (value != null) {
                return value;
            }
        }
        return null;
    }

    public static String unwrapJavaDocLink(String input) {
        if (input.contains("{@link")) {
            return input.replaceAll("\\{@link ([^}]+)}", "<code>$1</code>");
        } else {
            return input;
        }
    }
}
