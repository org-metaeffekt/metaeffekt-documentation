package com.metaeffekt.documentation.generator;

import com.metaeffekt.documentation.DocumentationGenerator;
import com.metaeffekt.documentation.IDocumentationGenerator;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.DocletTag;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.*;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.unwrapJavaDocLink;

public class CspDocumentationGenerator implements IDocumentationGenerator {

    private final Map<String, MavenCoordinates> pomCache = new HashMap<>();

    @Override
    public void generateDocumentation(JavaProjectBuilder project) throws IOException {
        final Map<String, String> templateReplacements = new HashMap<>();

        final String cspUsageTable = constructCspUsageTable(project);
        final String cspParamDocs = constructParameterDocumentation(project);

        templateReplacements.put("csp-loader-usage-table", cspUsageTable);
        templateReplacements.put("csp-configuration-parameters", cspParamDocs);
        templateReplacements.put("index-pom-default-security-policy", new JSONObject(new CentralSecurityPolicyConfiguration().getProperties()).toString(4));

        final List<String> targetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("inventory-enrichment/template/central-security-policy.md"), templateReplacements);
        DocumentationGenerator.assertTemplateFullyFilled("central-security-policy.md", targetLines);

        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("inventory-enrichment/central-security-policy.md"), targetLines);
    }

    private String constructParameterDocumentation(JavaProjectBuilder project) {
        final StringBuilder doc = new StringBuilder();

        // access the source class via QDox to get javadoc and types
        final JavaClass configClass = project.getClassByName(CentralSecurityPolicyConfiguration.class.getName());

        // access the runtime instance to get the resolved default values
        final CentralSecurityPolicyConfiguration defaultConfigInstance = new CentralSecurityPolicyConfiguration();
        final Map<String, Object> defaultProperties = defaultConfigInstance.getProperties();

        // filter fields: must exist in the source class AND be exposed in getProperties()
        final List<JavaField> fields = configClass.getFields().stream()
                .filter(f -> defaultProperties.containsKey(f.getName()))
                .sorted(Comparator.comparing(JavaField::getName))
                .collect(Collectors.toList());

        if (fields.size() != defaultProperties.size()) {
            System.err.println("Found a different amount of fields in the java code compared to the amount of properties: " + fields.size() + "!=" + defaultProperties.size());
        }

        for (JavaField field : fields) {
            final String name = field.getName();
            final Object defaultValue = defaultProperties.get(name);
            String description = field.getComment();

            // -- Extract "Default:" info from JavaDoc --
            String extractedDefaultNote = null;
            if (description != null && description.contains("Default:")) {
                StringBuilder descriptionBuilder = new StringBuilder();
                String[] lines = description.split("\\r?\\n");
                for (String line : lines) {
                    // Check if line contains "Default:", strip HTML tags for the check to handle "Default: ... <p>"
                    String plainText = line.replaceAll("<[^>]+>", "").trim();
                    if (plainText.startsWith("Default:")) {
                        extractedDefaultNote = plainText.substring("Default:".length()).trim();
                        // Clean up the extracted note (unwrap links, etc.)
                        extractedDefaultNote = unwrapJavaDocLink(extractedDefaultNote);
                    } else {
                        descriptionBuilder.append(line).append("\n");
                    }
                }
                description = descriptionBuilder.toString().trim();
            }

            // Wrap in details/summary for readability
            doc.append("<details>\n <summary><code>").append(name).append("</code></summary>\n\n");

            // default value formatting
            if (defaultValue != null) {
                String defaultStr;
                boolean isComplex = false;

                if (defaultValue instanceof Collection || defaultValue instanceof Map || defaultValue instanceof JSONObject || defaultValue instanceof JSONArray) {
                    isComplex = true;
                    // complex types get a json code block
                    if (defaultValue instanceof JSONObject) {
                        defaultStr = ((JSONObject) defaultValue).toString(2);
                    } else if (defaultValue instanceof JSONArray) {
                        defaultStr = ((JSONArray) defaultValue).toString(2);
                    } else if (defaultValue instanceof Map) {
                        defaultStr = new JSONObject((Map<?, ?>) defaultValue).toString(2);
                    } else if (defaultValue instanceof Collection) {
                        defaultStr = new JSONArray((Collection<?>) defaultValue).toString(2);
                    } else {
                        defaultStr = defaultValue.toString();
                    }

                    doc.append("**Default:**");
                    if (StringUtils.isNotEmpty(extractedDefaultNote)) {
                        doc.append(" _(").append(extractedDefaultNote).append(")_");
                    }
                    doc.append("\n\n```json\n").append(defaultStr).append("\n```\n");

                } else {
                    // simple types get inline code
                    doc.append("**Default:** `").append(defaultValue).append("`");
                    if (StringUtils.isNotEmpty(extractedDefaultNote)) {
                        doc.append(" _(").append(extractedDefaultNote).append(")_");
                    }
                    doc.append("\n");
                }
            } else {
                doc.append("**Default:** `null`");
                if (StringUtils.isNotEmpty(extractedDefaultNote)) {
                    doc.append(" _(").append(extractedDefaultNote).append(")_");
                }
                doc.append("\n");
            }

            doc.append("\n");

            // javadoc description
            if (StringUtils.isNotEmpty(description)) {
                // simple cleanup of javadoc tags to markdown
                String cleanDesc = unwrapJavaDocLink(description);
                doc.append(cleanDesc).append("\n\n");
            }

            doc.append("</details>\n\n");
        }

        return doc.toString();
    }

    private String constructCspUsageTable(JavaProjectBuilder project) {
        final List<String> lines = new ArrayList<>();

        // iterate all classes in the source tree
        final List<JavaClass> allClasses = project.getClasses().stream()
                .sorted(Comparator.comparing(JavaClass::getName))
                .collect(Collectors.toList());

        for (JavaClass javaClass : allClasses) {

            // determine if this class is a concrete Mojo
            final String mojoName = getMojoName(javaClass);

            if (mojoName == null) {
                // not a Mojo, or an abstract base Mojo without a specific goal
                continue;
            }

            // find fields of type CspLoader
            final List<JavaField> cspLoaderFields = getAllFields(javaClass).stream()
                    .filter(f -> f.getType().getValue().equals("CspLoader") || f.getType().getFullyQualifiedName().endsWith(".CspLoader"))
                    .collect(Collectors.toList());

            if (cspLoaderFields.isEmpty()) {
                continue;
            }

            final MavenCoordinates coordinates = getMavenCoordinates(javaClass);

            for (JavaField field : cspLoaderFields) {
                lines.add("\n| `" + coordinates.groupId + "`" +
                        " | `" + coordinates.artifactId + "`" +
                        " | `" + mojoName + "`");
            }
        }

        final StringBuilder tableContent = new StringBuilder();

        tableContent.append("| Group Id | Artifact Id | Mojo Goal |\n");
        tableContent.append("| :--- | :--- | :--- |");

        if (lines.isEmpty()) {
            tableContent.append("\n| - | - | - | - | - | No CspLoader usage found in Mojos |");
        } else {
            lines.sort(String::compareTo);
            lines.forEach(tableContent::append);
        }

        return tableContent.toString();
    }

    /**
     * Extracts the mojo goal name.
     * Supports both the Java 5 annotation: @Mojo(name = "goal")
     * And the JavaDoc tag: /** @goal goal * /
     */
    private String getMojoName(JavaClass clazz) {
        // 1. Try Java 5+ Annotation @Mojo
        for (JavaAnnotation annotation : clazz.getAnnotations()) {
            if (annotation.getType().getValue().endsWith("Mojo")) {
                Object nameValue = annotation.getNamedParameter("name");
                if (nameValue != null) {
                    return nameValue.toString().replace("\"", "");
                }
            }
        }

        // 2. Try JavaDoc Tag @goal (legacy maven-plugin-plugin style)
        DocletTag goalTag = clazz.getTagByName("goal");
        if (goalTag != null) {
            return goalTag.getValue().trim();
        }

        return null;
    }

    /**
     * Helper to get all fields including those from superclasses.
     */
    private List<JavaField> getAllFields(JavaClass clazz) {
        List<JavaField> fields = new ArrayList<>(clazz.getFields());
        JavaClass superClass = clazz.getSuperJavaClass();
        while (superClass != null && !superClass.getFullyQualifiedName().equals("java.lang.Object")) {
            fields.addAll(superClass.getFields());
            superClass = superClass.getSuperJavaClass();
        }
        return fields;
    }

    /**
     * Locates the pom.xml for the given JavaClass and parses the Group and Artifact IDs.
     */
    private MavenCoordinates getMavenCoordinates(JavaClass clazz) {
        try {
            final URL sourceUrl = clazz.getSource().getURL();
            if (sourceUrl == null) {
                return new MavenCoordinates("unknown", "unknown");
            }

            File currentDir = new File(sourceUrl.toURI()).getParentFile();
            while (currentDir != null && currentDir.exists()) {
                File pomFile = new File(currentDir, "pom.xml");
                if (pomFile.exists()) {
                    return parsePom(pomFile);
                }
                currentDir = currentDir.getParentFile();
            }
        } catch (Exception e) {
            System.err.println("Failed to determine maven coordinates for " + clazz.getName() + ": " + e.getMessage());
        }
        return new MavenCoordinates("unknown", "unknown");
    }

    /**
     * Parses the pom.xml using basic DOM to avoid external Maven dependencies.
     */
    private MavenCoordinates parsePom(File pomFile) {
        if (pomCache.containsKey(pomFile.getAbsolutePath())) {
            return pomCache.get(pomFile.getAbsolutePath());
        }

        String groupId = "unknown";
        String artifactId = "unknown";
        String parentGroupId = null;

        try {
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.parse(pomFile);
            doc.getDocumentElement().normalize();

            Element projectElement = doc.getDocumentElement();

            artifactId = getTagValue(projectElement, "artifactId");
            groupId = getTagValue(projectElement, "groupId");

            // parent if groupId is missing
            NodeList parents = projectElement.getElementsByTagName("parent");
            if (parents.getLength() > 0) {
                Element parent = (Element) parents.item(0);
                parentGroupId = getTagValue(parent, "groupId");
            }

            // inherit groupId from parent if not defined locally
            if ((groupId == null || groupId.isEmpty()) && parentGroupId != null) {
                groupId = parentGroupId;
            }

        } catch (Exception e) {
            System.err.println("Error parsing POM " + pomFile.getAbsolutePath() + ": " + e.getMessage());
        }

        MavenCoordinates coords = new MavenCoordinates(
                groupId != null ? groupId : "unknown",
                artifactId != null ? artifactId : "unknown"
        );
        pomCache.put(pomFile.getAbsolutePath(), coords);
        return coords;
    }

    private String getTagValue(Element element, String tagName) {
        NodeList nodeList = element.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(tagName)) {
                return node.getTextContent().trim();
            }
        }
        return null;
    }

    private static class MavenCoordinates {
        final String groupId;
        final String artifactId;

        public MavenCoordinates(String groupId, String artifactId) {
            this.groupId = groupId;
            this.artifactId = artifactId;
        }
    }
}
