package com.metaeffekt.documentation.provider;

import com.metaeffekt.artifact.enrichment.InventoryEnricher;
import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.documentation.domain.EnricherMetadata;
import com.metaeffekt.documentation.util.MirrorUtils;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.thoughtworks.qdox.model.JavaField;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONArray;
import org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class InventoryEnrichmentDataProvider implements DocumentationDataProvider {

    public static final Set<String> EXCLUDED_ENRICHERS = new HashSet<>(Collections.singletonList(
            "com.metaeffekt.artifact.enrichment.InventoryEnrichmentPipeline"
    ));

    public static final Set<String> POM_EXCLUDED_PHASES = new HashSet<>(Collections.singletonList(
            InventoryEnrichmentPhase.STANDALONE.name()
    ));

    private static final Set<String> UPPER_BOUND_CONFIG_CLASSES = new HashSet<>(Arrays.asList(
            "java.lang.Object", "org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration"
    ));

    private final static Map<String, String> CUSTOM_PLURAL_TO_SINGULAR = new HashMap<>();
    static {
        CUSTOM_PLURAL_TO_SINGULAR.put("additionalStatus", "status");
        CUSTOM_PLURAL_TO_SINGULAR.put("activeLabel", "label");
        CUSTOM_PLURAL_TO_SINGULAR.put("additionalValidators", "validator");
        CUSTOM_PLURAL_TO_SINGULAR.put("detailLevels", "level");
        CUSTOM_PLURAL_TO_SINGULAR.put("failOnUnreviewedAdvisoriesTypes", "advisoryType");
    }

    private final static Set<String> ASSUME_EMPTY_CONFIGURATION_FIELDS = new HashSet<>(Arrays.asList(
            "requireSecondaryIndicationTermsLimiters"
    ));

    private final static Set<String> EXCLUDED_CONFIGURATION_FIELDS = new HashSet<>(Arrays.asList(
            "LOG", "logger", "log", "configuration", "addonVulnerabilityKeywords"
    ));

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        Map<String, Supplier<String>> variables = new HashMap<>();

        // 1. Fetch and Filter
        List<DocumentedType> rawEnrichers = context.getType(InventoryEnricher.class).findSubtypes();

        List<DocumentedType> candidates = rawEnrichers.stream()
                .filter(t -> !EXCLUDED_ENRICHERS.contains(t.getFullyQualifiedName()))
                .collect(Collectors.toList());

        List<DocumentedType> filtered = excludeAllThatAreExtendedByOthers(candidates);

        // 2. Order
        List<DocumentedType> ordered = MirrorUtils.orderEnrichmentClasses(context, filtered);

        // 3. Group by Phase
        Map<String, List<DocumentedType>> enrichersByPhase = new LinkedHashMap<>();
        for (InventoryEnrichmentPhase phase : InventoryEnrichmentPhase.values()) {
            enrichersByPhase.put(phase.name(), new ArrayList<>());
        }

        for (DocumentedType type : ordered) {
            try {
                String phase = type.as(EnricherMetadata.class).getPhase();
                if (phase != null && enrichersByPhase.containsKey(phase)) {
                    enrichersByPhase.get(phase).add(type);
                }
            } catch (Exception e) {
                log.warn("Skipping enricher [{}] due to error reading metadata: {}", type.getFullyQualifiedName(), e.getMessage());
            }
        }

        // 4. Register Variables
        StringJoiner activeStepsList = new StringJoiner("\n", "", "");
        StringJoiner shortPom = new StringJoiner("\n");
        StringJoiner fullPom = new StringJoiner("\n");

        for (Map.Entry<String, List<DocumentedType>> entry : enrichersByPhase.entrySet()) {
            String phase = entry.getKey();
            List<DocumentedType> types = entry.getValue();
            String phaseDisplay = InventoryEnrichmentPhase.valueOf(phase).displayName();
            boolean includePom = !POM_EXCLUDED_PHASES.contains(phase);

            variables.put("enrichment-steps-full-doc-" + phase, () -> generatePhaseDetails(context, types));
            variables.put("enrichment-steps-phase-title-" + phase, () -> phaseDisplay);

            if (!types.isEmpty()) {
                activeStepsList.add("- **[" + phaseDisplay + "](#" + toMarkdownId(phaseDisplay) + ")**");
                for (DocumentedType type : types) {
                    activeStepsList.add("  - [" + formatClassNameApplyDeprecated(type) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(type)) + ")");
                }

                if (includePom) {
                    shortPom.add("<!-- " + phaseDisplay + " -->");
                    fullPom.add("<!-- " + phaseDisplay + " -->");

                    for (int i = 0; i < types.size(); i++) {
                        DocumentedType type = types.get(i);
                        DocumentedType config = type.as(EnricherMetadata.class).getConfigurationType()
                                .orElseThrow(() -> new IllegalStateException("No configuration found for " + type.getFullyQualifiedName()));

                        shortPom.add(generatePomEntry(context, type, config, false));
                        fullPom.add(generatePomEntry(context, type, config, true));

                        if (i < types.size() - 1) {
                            fullPom.add("");
                        }
                    }
                    shortPom.add("");
                    fullPom.add("");
                }
            }
        }

        variables.put("enrichment-steps-active", activeStepsList::toString);
        variables.put("enrichment-pom-short-configuration", () -> indent(shortPom.toString(), 20));
        variables.put("enrichment-pom-complete-configuration", () -> indent(fullPom.toString(), 20));

        return variables;
    }

    private String generatePhaseDetails(DocumentationContext context, List<DocumentedType> types) {
        StringJoiner joiner = new StringJoiner("\n\n");
        for (DocumentedType type : types) {
            joiner.add(generateSingleEnricherDoc(context, type));
        }
        return joiner.toString();
    }

    private String generateSingleEnricherDoc(DocumentationContext context, DocumentedType type) {
        StringBuilder sb = new StringBuilder();
        EnricherMetadata metadata = type.as(EnricherMetadata.class);

        String suffix = metadata.getIntermediateFileSuffix();
        String mavenProp = metadata.getMavenPropertyName();

        DocumentedType config = metadata.getConfigurationType()
                .orElseThrow(() -> new IllegalStateException("No configuration found for " + type.getFullyQualifiedName()));

        String defaultId = metadata.getDefaultId();

        sb.append("## ").append(formatClassNameApplyDeprecated(type)).append("\n\n");
        sb.append("`").append(suffix).append("` / `").append(mavenProp).append("` / `").append(defaultId).append("`\n\n");

        type.findMethod("performEnrichment").ifPresent(method ->
                sb.append(MirrorDataProvider.createSourceCodeExpandable(method).getKey()).append("\n")
        );

        if (type.getComment().isPresent() && !type.getComment().get().isEmpty()) {
            sb.append(unwrapJavaDocLink(type.getComment().get())).append("\n\n");
        }

        List<DocumentedType> configHierarchy = config.getTypeHierarchy(UPPER_BOUND_CONFIG_CLASSES);

        for (DocumentedType c : configHierarchy) {
            if (!c.getFields(false).isEmpty()) {
                sb.append("#### Configuration: ").append(formatClassName(c).replace(" Configuration", "").replace(" Inventory", "")).append("\n\n");
                if (c.getComment().isPresent()) {
                    sb.append(unwrapJavaDocLink(c.getComment().get().replaceAll("(\r?\n)+", " "))).append("\n\n");
                }
                sb.append(generateConfigTable(c)).append("\n\n");
            }
        }
        return sb.toString();
    }

    private String generateConfigTable(DocumentedType configType) {
        StringBuilder sb = new StringBuilder("<table><tr><th>Parameter</th><th>Default</th></tr>");
        for (JavaField field : configType.getFields(false)) {
            if (!isFieldIncluded(field.getName())) continue;
            String desc = field.getComment() != null ? field.getComment().replaceAll("(\r?\n)+", " ") : "";
            String def = field.getInitializationExpression() != null ? field.getInitializationExpression().toString().replace("\n", "").replace("\r", "") : "";

            sb.append("<tr><td><code>").append(field.getName()).append("</code></td><td><code>").append(def).append("</code></td></tr>");
            if (!desc.isEmpty()) {
                sb.append("<tr><td colspan=2>").append(unwrapJavaDocLink(desc)).append("</td></tr>");
            }
        }
        sb.append("</table>");
        return sb.toString();
    }

    private String generatePomEntry(DocumentationContext context, DocumentedType type, DocumentedType configType, boolean details) {
        String tagName = type.as(EnricherMetadata.class).getMavenPropertyName();
        if (!details) return "<" + tagName + "/>";

        try {
            Class<?> runtimeConfig = configType.getRuntimeClass().orElse(null);
            if (runtimeConfig == null || Modifier.isAbstract(runtimeConfig.getModifiers())) return "<" + tagName + "/>";

            Object instance = runtimeConfig.getDeclaredConstructor().newInstance();
            ProcessConfiguration cfg = (ProcessConfiguration) instance;

            StringJoiner props = new StringJoiner("\n");
            for (Field field : cfg.getClass().getDeclaredFields()) {
                field.setAccessible(true);
                String name = field.getName();

                if (!isFieldIncluded(name)) continue;

                Object val = field.get(cfg);

                if (val == null || ASSUME_EMPTY_CONFIGURATION_FIELDS.contains(name)) {
                    props.add("  <!-- <" + name + "/> --> <!-- type: " + field.getType().getSimpleName() + " -->");
                    continue;
                }

                if (val.getClass().isArray()) {
                    val = new ArrayList<>(Arrays.asList((Object[]) val));
                } else if (val instanceof JSONArray) {
                    val = ((JSONArray) val).toList();
                }

                String displayValue;

                if (val instanceof List) {
                    String fieldTagName = CUSTOM_PLURAL_TO_SINGULAR.getOrDefault(name, name.toLowerCase().contains("file") ? "file" : name.replaceAll("([a-zA-Z]+)s$", "$1"));
                    if (((List<?>) val).isEmpty()) {
                        displayValue = "\n    <!-- <" + fieldTagName + ">...</" + fieldTagName + "> -->\n  ";
                    } else {
                        StringJoiner listJoiner = new StringJoiner("\n", "\n", "\n  ");
                        for (Object listValue : (List<?>) val) {
                            listJoiner.add("    <" + fieldTagName + ">" + listValue + "</" + fieldTagName + ">");
                        }
                        displayValue = listJoiner.toString();
                    }
                } else {
                    displayValue = val.toString();
                }

                props.add("  <" + name + ">" + displayValue + "</" + name + ">");
            }

            if (props.length() == 0) return "<" + tagName + "/>";
            return "<" + tagName + ">\n" + props + "\n</" + tagName + ">";

        } catch (Exception e) {
            return "<" + tagName + "/> <!-- Error: " + e.getMessage() + " -->";
        }
    }

    private boolean isFieldIncluded(String name) {
        if (EXCLUDED_CONFIGURATION_FIELDS.contains(name)) return false;
        if (name.startsWith("cached")) return false;
        if (name.startsWith("lastCached")) return false;
        return true;
    }
}