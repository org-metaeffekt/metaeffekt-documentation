package com.metaeffekt.documentation.provider;

import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.util.MirrorUtils;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import com.thoughtworks.qdox.model.expression.TypeRef;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONArray;
import org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class InventoryEnrichmentDataProvider implements DocumentationDataProvider {

    public static final Set<String> EXCLUDED_ENRICHERS = new HashSet<>(Collections.singletonList(
            "com.metaeffekt.artifact.enrichment.InventoryEnrichmentPipeline"
    ));

    public static final Set<String> POM_EXCLUDED_PHASES = new HashSet<>(Collections.singletonList(
            InventoryEnrichmentPhase.STANDALONE.name()
    ));

    private static final Set<String> UPPER_BOUND_CONFIG_CLASSES = new HashSet<>(Arrays.asList(
            "java.lang.Object", "org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration"
    ));

    private final static Map<String, String> CUSTOM_PLURAL_TO_SINGULAR = new HashMap<>();
    static {
        CUSTOM_PLURAL_TO_SINGULAR.put("additionalStatus", "status");
        CUSTOM_PLURAL_TO_SINGULAR.put("activeLabel", "label");
        CUSTOM_PLURAL_TO_SINGULAR.put("additionalValidators", "validator");
        CUSTOM_PLURAL_TO_SINGULAR.put("detailLevels", "level");
        CUSTOM_PLURAL_TO_SINGULAR.put("failOnUnreviewedAdvisoriesTypes", "advisoryType");
    }

    private final static Set<String> ASSUME_EMPTY_CONFIGURATION_FIELDS = new HashSet<>(Arrays.asList(
            "requireSecondaryIndicationTermsLimiters"
    ));

    private final static Set<String> EXCLUDED_CONFIGURATION_FIELDS = new HashSet<>(Arrays.asList(
            "LOG", "logger", "log", "configuration", "addonVulnerabilityKeywords"
    ));

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        Map<String, Supplier<String>> variables = new HashMap<>();

        // 1. Fetch and Filter
        List<JavaClass> rawEnrichers = context.findClassesExtending("com.metaeffekt.artifact.enrichment.InventoryEnricher");

        List<JavaClass> candidates = rawEnrichers.stream()
                .filter(c -> !EXCLUDED_ENRICHERS.contains(c.getFullyQualifiedName()))
                .collect(Collectors.toList());

        List<JavaClass> filteredCandidates = excludeAllThatAreExtendedByOthers(candidates);

        // 2. Order
        // Use MirrorUtils to respect the enrichment-order.txt file
        List<JavaClass> enrichers = MirrorUtils.orderEnrichmentClasses(context, filteredCandidates);

        // 3. Group by Phase
        Map<String, List<JavaClass>> enrichersByPhase = new LinkedHashMap<>();
        for (InventoryEnrichmentPhase phase : InventoryEnrichmentPhase.values()) {
            enrichersByPhase.put(phase.name(), new ArrayList<>());
        }

        for (JavaClass clazz : enrichers) {
            try {
                String phase = getEnricherPhase(clazz);
                if (phase != null && enrichersByPhase.containsKey(phase)) {
                    enrichersByPhase.get(phase).add(clazz);
                }
            } catch (Exception e) {
                log.warn("Skipping enricher [{}] due to error reading metadata: {}", clazz.getName(), e.getMessage());
            }
        }

        // 4. Register Variables
        StringJoiner activeStepsList = new StringJoiner("\n", "", "");
        StringJoiner shortPom = new StringJoiner("\n");
        StringJoiner fullPom = new StringJoiner("\n");

        for (Map.Entry<String, List<JavaClass>> entry : enrichersByPhase.entrySet()) {
            String phase = entry.getKey();
            List<JavaClass> classes = entry.getValue();
            String phaseDisplay = InventoryEnrichmentPhase.valueOf(phase).displayName();
            boolean includePom = !POM_EXCLUDED_PHASES.contains(phase);

            // Per-phase content
            variables.put("enrichment-steps-full-doc-" + phase, () -> generatePhaseDetails(context, classes));
            variables.put("enrichment-steps-phase-title-" + phase, () -> phaseDisplay);

            // Accumulate globals
            if (!classes.isEmpty()) {
                activeStepsList.add("- **[" + phaseDisplay + "](#" + toMarkdownId(phaseDisplay) + ")**");
                for (JavaClass clazz : classes) {
                    activeStepsList.add("  - [" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
                }

                if (includePom) {
                    shortPom.add("<!-- " + phaseDisplay + " -->");
                    fullPom.add("<!-- " + phaseDisplay + " -->");

                    for (int i = 0; i < classes.size(); i++) {
                        JavaClass clazz = classes.get(i);
                        JavaClass config = findConfigurationClass(context, clazz);
                        shortPom.add(generatePomEntry(context, clazz, config, false));
                        fullPom.add(generatePomEntry(context, clazz, config, true));

                        // Add spacing if there are more items in this phase
                        if (i < classes.size() - 1) {
                            fullPom.add("");
                        }
                    }
                    shortPom.add("");
                    fullPom.add("");
                }
            }
        }

        variables.put("enrichment-steps-active", activeStepsList::toString);
        variables.put("enrichment-pom-short-configuration", () -> indent(shortPom.toString(), 20));
        variables.put("enrichment-pom-complete-configuration", () -> indent(fullPom.toString(), 20));

        return variables;
    }

    private String generatePhaseDetails(DocumentationContext context, List<JavaClass> classes) {
        StringJoiner joiner = new StringJoiner("\n\n");
        for (JavaClass clazz : classes) {
            joiner.add(generateSingleEnricherDoc(context, clazz));
        }
        return joiner.toString();
    }

    private String generateSingleEnricherDoc(DocumentationContext context, JavaClass clazz) {
        StringBuilder sb = new StringBuilder();
        String suffix = getAnnotationValue(clazz, "intermediateFileSuffix");
        String mavenProp = getAnnotationValue(clazz, "mavenPropertyName");
        JavaClass config = findConfigurationClass(context, clazz);
        String defaultId = buildInitialId(config.getSimpleName());

        sb.append("## ").append(formatClassNameApplyDeprecated(clazz)).append("\n\n");
        sb.append("`").append(suffix).append("` / `").append(mavenProp).append("` / `").append(defaultId).append("`\n\n");

        String methodName = "performEnrichment";
        String expandables = MirrorDataProvider.createSourceCodeExpandable(clazz,
                clazz.getMethods().stream().filter(m -> m.getName().equals(methodName)).findFirst().orElse(null)).getKey(); // simplified for now, ideally reused logic
        sb.append("");

        // Correct logic:
        sb.append(MirrorDataProvider.createSourceCodeExpandable(clazz,
                clazz.getMethods().stream().filter(m -> m.getName().equals("performEnrichment")).findFirst().orElse(
                        clazz.getSuperJavaClass() != null ? clazz.getSuperJavaClass().getMethods().stream().filter(m -> m.getName().equals("performEnrichment")).findFirst().orElse(null) : null
                )).getKey()).append("\n");

        if (clazz.getComment() != null && !clazz.getComment().isEmpty()) {
            sb.append(unwrapJavaDocLink(clazz.getComment())).append("\n\n");
        }

        List<JavaClass> configHierarchy = getConfigHierarchy(config);
        for (JavaClass c : configHierarchy) {
            if (!c.getFields().isEmpty()) {
                sb.append("#### Configuration: ").append(formatClassName(c).replace(" Configuration", "").replace(" Inventory", "")).append("\n\n");
                if (c.getComment() != null) {
                    sb.append(unwrapJavaDocLink(c.getComment().replaceAll("(\r?\n)+", " "))).append("\n\n");
                }
                sb.append(generateConfigTable(c)).append("\n\n");
            }
        }
        return sb.toString();
    }

    private String generateConfigTable(JavaClass configClass) {
        StringBuilder sb = new StringBuilder("<table><tr><th>Parameter</th><th>Default</th></tr>");
        for (JavaField field : configClass.getFields()) {
            if (!isFieldIncluded(field.getName())) continue;
            String desc = field.getComment() != null ? field.getComment().replaceAll("(\r?\n)+", " ") : "";
            String def = field.getInitializationExpression() != null ? field.getInitializationExpression().toString().replace("\n", "").replace("\r", "") : "";

            sb.append("<tr><td><code>").append(field.getName()).append("</code></td><td><code>").append(def).append("</code></td></tr>");
            if (!desc.isEmpty()) {
                sb.append("<tr><td colspan=2>").append(unwrapJavaDocLink(desc)).append("</td></tr>");
            }
        }
        sb.append("</table>");
        return sb.toString();
    }

    private String generatePomEntry(DocumentationContext context, JavaClass clazz, JavaClass configClass, boolean details) {
        String tagName = getAnnotationValue(clazz, "mavenPropertyName");
        if (!details) return "<" + tagName + "/>";

        try {
            Class<?> runtimeConfig = context.loadClass(configClass);
            if (Modifier.isAbstract(runtimeConfig.getModifiers())) return "<" + tagName + "/>";

            Object instance = runtimeConfig.getDeclaredConstructor().newInstance();
            ProcessConfiguration cfg = (ProcessConfiguration) instance;

            StringJoiner props = new StringJoiner("\n");
            for (Field field : cfg.getClass().getDeclaredFields()) {
                field.setAccessible(true);
                String name = field.getName();

                if (!isFieldIncluded(name)) continue;

                Object val = field.get(cfg);

                if (val == null || ASSUME_EMPTY_CONFIGURATION_FIELDS.contains(name)) {
                    props.add("  <!-- <" + name + "/> --> <!-- type: " + field.getType().getSimpleName() + " -->");
                    continue;
                }

                if (val.getClass().isArray()) {
                    val = new ArrayList<>(Arrays.asList((Object[]) val));
                } else if (val instanceof JSONArray) {
                    val = ((JSONArray) val).toList();
                }

                String displayValue;

                if (val instanceof List) {
                    String fieldTagName = CUSTOM_PLURAL_TO_SINGULAR.getOrDefault(name, name.toLowerCase().contains("file") ? "file" : name.replaceAll("([a-zA-Z]+)s$", "$1"));
                    if (((List<?>) val).isEmpty()) {
                        displayValue = "\n    <!-- <" + fieldTagName + ">...</" + fieldTagName + "> -->\n  ";
                    } else {
                        StringJoiner listJoiner = new StringJoiner("\n", "\n", "\n  ");
                        for (Object listValue : (List<?>) val) {
                            listJoiner.add("    <" + fieldTagName + ">" + listValue + "</" + fieldTagName + ">");
                        }
                        displayValue = listJoiner.toString();
                    }
                } else {
                    displayValue = val.toString();
                }

                props.add("  <" + name + ">" + displayValue + "</" + name + ">");
            }

            if (props.length() == 0) return "<" + tagName + "/>";
            return "<" + tagName + ">\n" + props + "\n</" + tagName + ">";

        } catch (Exception e) {
            return "<" + tagName + "/> <!-- Error: " + e.getMessage() + " -->";
        }
    }

    private boolean isFieldIncluded(String name) {
        if (EXCLUDED_CONFIGURATION_FIELDS.contains(name)) return false;
        if (name.startsWith("cached")) return false;
        if (name.startsWith("lastCached")) return false;
        return true;
    }

    private JavaClass findConfigurationClass(DocumentationContext context, JavaClass enricher) {
        String explicit = getAnnotationValue(enricher, "explicitConfiguration");
        if (explicit != null) return context.getClassByName(explicit);

        JavaField field = enricher.getFieldByName("configuration");
        if (field == null && enricher.getSuperJavaClass() != null) {
            field = enricher.getSuperJavaClass().getFieldByName("configuration");
        }
        if (field == null) throw new IllegalStateException("No config field for " + enricher.getName());
        return context.getClassByName(field.getType().getFullyQualifiedName());
    }

    private List<JavaClass> getConfigHierarchy(JavaClass config) {
        List<JavaClass> list = new ArrayList<>();
        list.add(config);
        JavaClass sup = config.getSuperJavaClass();
        while (sup != null && !UPPER_BOUND_CONFIG_CLASSES.contains(sup.getFullyQualifiedName())) {
            list.add(sup);
            sup = sup.getSuperJavaClass();
        }
        return list;
    }

    private String getAnnotationValue(JavaClass clazz, String key) {
        return clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().contains("EnricherMetadata"))
                .map(a -> {
                    AnnotationValue val = a.getProperty(key);
                    if (val == null) return null;
                    if (val instanceof TypeRef) {
                        return ((TypeRef) val).getType().getFullyQualifiedName();
                    }
                    return val.getParameterValue().toString().replace("\"", "");
                })
                .filter(Objects::nonNull)
                .findFirst().orElse(null);
    }

    private String getEnricherPhase(JavaClass clazz) {
        String val = getAnnotationValue(clazz, "phase");
        if (val == null) return null;
        return val.replace("InventoryEnrichmentPhase.", "");
    }

    private String buildInitialId(String className) {
        return className.replace("Configuration", "").replace("Inventory", "").replace("Enrichment", "")
                .replaceAll("([a-z])([A-Z]+)", "$1-$2").toLowerCase();
    }
}