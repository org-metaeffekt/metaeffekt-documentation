package com.metaeffekt.documentation.generator;

import com.metaeffekt.documentation.DocumentationGenerator;
import com.metaeffekt.documentation.IDocumentationGenerator;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.metaeffekt.mirror.index.Index;
import com.metaeffekt.mirror.query.IndexQuery;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.JavaType;
import com.thoughtworks.qdox.model.impl.DefaultJavaParameterizedType;
import org.apache.commons.io.FileUtils;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;


public class OverviewChartVulnerabilityManagementIndividualGenerator implements IDocumentationGenerator {

    public void generateDocumentation(JavaProjectBuilder project) throws IOException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        final List<JavaClass> inventoryEnrichmentClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderEnrichmentClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.artifact.enrichment.InventoryEnricher")));
        inventoryEnrichmentClasses.removeIf(c -> InventoryEnrichmentStepsDocumentationGenerator.EXCLUDED_ENRICHERS.contains(c.getFullyQualifiedName()));
        final Map<String, List<JavaClass>> enrichersByPhase = InventoryEnrichmentStepsDocumentationGenerator.groupEnrichersByPhases(inventoryEnrichmentClasses);
        for (String phase : InventoryEnrichmentStepsDocumentationGenerator.POM_EXCLUDED_ENRICHMENT_PHASES) {
            inventoryEnrichmentClasses.removeAll(enrichersByPhase.get(phase));
        }
        enrichersByPhase.keySet().removeAll(InventoryEnrichmentStepsDocumentationGenerator.POM_EXCLUDED_ENRICHMENT_PHASES);

        final List<JavaClass> downloadClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.download.Download")));
        final List<JavaClass> indexClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.index.Index")));

        final Map<JavaClass, Map<String, List<JavaClass>>> indexClassDependencies = new LinkedHashMap<>();
        for (JavaClass indexClass : indexClasses) {
            indexClassDependencies.put(indexClass, MirrorDocumentationGenerator.getIndexDependencies(project, indexClass));
        }

        final List<JavaClass> indexQueryClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.query.IndexQuery")));
        final Map<JavaClass, List<JavaClass>> indexQueryUsages = new LinkedHashMap<>();
        for (JavaClass enrichmentClass : inventoryEnrichmentClasses) {
            indexQueryUsages.put(enrichmentClass, getEnricherIndexQueryUsages(enrichmentClass, indexQueryClasses));
        }

        final Map<JavaClass, Index> indexUsageInIndexQuery = new LinkedHashMap<>();
        for (JavaClass indexQuery : indexQueryClasses) {
            if (indexQuery.getFullyQualifiedName().contains("CustomVulnerabilityIndexQuery")) continue;

            final Class<?> indexQueryClass = DocumentationGenerator.loadClass(indexQuery.getFullyQualifiedName());
            final Object indexQueryInstance = indexQueryClass.getConstructor(File.class).newInstance(DocumentationProperties.getMirrorPath());
            final IndexQuery typedIndexQueryInstance = (IndexQuery) indexQueryInstance;
            indexUsageInIndexQuery.put(indexQuery, typedIndexQueryInstance.getIndex());
        }

        final StringJoiner diagramsList = new StringJoiner("\n\n");

        for (JavaClass generateDetailViewForIndexClass : indexClasses) {

            System.out.println("Generating overview diagram for " + generateDetailViewForIndexClass.getFullyQualifiedName());

            final JSONArray nodes = new JSONArray();
            final JSONArray edges = new JSONArray();

            final Map<String, List<JavaClass>> indexClassDependenciesForIndex = indexClassDependencies.get(generateDetailViewForIndexClass);

            // only those index that are used in the current index
            final List<JavaClass> indicesForIndex = new ArrayList<>();
            indicesForIndex.add(generateDetailViewForIndexClass);
            for (Map.Entry<String, List<JavaClass>> entry : indexClassDependenciesForIndex.entrySet()) {
                for (JavaClass dependentClass : entry.getValue()) {
                    if (indexClasses.contains(dependentClass)) {
                        indicesForIndex.add(dependentClass);
                    }
                }
            }
            // add indexes that are referenced by other indexes
            boolean added;
            do {
                added = false;
                for (JavaClass index : indexClasses) {
                    final Map<String, List<JavaClass>> dependencies = indexClassDependencies.get(index);
                    for (Map.Entry<String, List<JavaClass>> entry : dependencies.entrySet()) {
                        for (JavaClass dependentClass : entry.getValue()) {
                            if (indicesForIndex.contains(dependentClass) && !indicesForIndex.contains(index)) {
                                indicesForIndex.add(index);
                                added = true;
                            }
                        }
                    }
                }
            } while (added);

            // only those index query that are used in the current index
            final List<JavaClass> indexQueryClassesForIndex = new ArrayList<>();
            for (Map.Entry<JavaClass, Index> entry : indexUsageInIndexQuery.entrySet()) {
                if (entry.getValue().getClass().getName().equals(generateDetailViewForIndexClass.getFullyQualifiedName())) {
                    indexQueryClassesForIndex.add(entry.getKey());
                }
            }

            // only those downloaders that are used in the current index
            final List<JavaClass> downloadersForIndex = new ArrayList<>();
            for (Map.Entry<String, List<JavaClass>> entry : indexClassDependenciesForIndex.entrySet()) {
                for (JavaClass dependentClass : entry.getValue()) {
                    if (downloadClasses.contains(dependentClass)) {
                        downloadersForIndex.add(dependentClass);
                    }
                }
            }
            // add downloads that are referenced by the indexes
            for (JavaClass index : indicesForIndex) {
                final Map<String, List<JavaClass>> dependencies = indexClassDependencies.get(index);
                for (Map.Entry<String, List<JavaClass>> entry : dependencies.entrySet()) {
                    for (JavaClass dependentClass : entry.getValue()) {
                        if (downloadClasses.contains(dependentClass)) {
                            downloadersForIndex.add(dependentClass);
                        }
                    }
                }
            }

            // only those enrichers that are use any of the index queries
            final List<JavaClass> enrichersForIndex = new ArrayList<>();
            for (JavaClass enricher : inventoryEnrichmentClasses) {
                if (indexQueryUsages.get(enricher).stream().anyMatch(indexQueryClassesForIndex::contains)) {
                    enrichersForIndex.add(enricher);
                }
            }

            // only those phases that are used by enrichers
            final Set<String> phaseGroups = new LinkedHashSet<>();
            for (String phase : enrichersByPhase.keySet()) {
                if (enrichersByPhase.get(phase).stream().anyMatch(enrichersForIndex::contains)) {
                    phaseGroups.add(phase);
                }
            }

            // Create swimlanes/groups
            if (!downloadersForIndex.isEmpty()) {
                JSONObject downloadersGroup = new JSONObject();
                downloadersGroup.put("data", new JSONObject().put("id", "downloadersGroup").put("label", "Downloaders")).put("classes", new JSONArray().put("graph-container"));
                nodes.put(downloadersGroup);
            }

            if (!indicesForIndex.isEmpty()) {
                JSONObject indexesGroup = new JSONObject();
                indexesGroup.put("data", new JSONObject().put("id", "indexesGroup").put("label", "Indexes")).put("classes", new JSONArray().put("graph-container"));
                nodes.put(indexesGroup);
            }

            if (!indexQueryClassesForIndex.isEmpty()) {
                JSONObject indexQueriesGroup = new JSONObject();
                indexQueriesGroup.put("data", new JSONObject().put("id", "indexQueriesGroup").put("label", "Index Queries")).put("classes", new JSONArray().put("graph-container"));
                nodes.put(indexQueriesGroup);
            }

            if (!enrichersForIndex.isEmpty()) {
                JSONObject enrichersGroup = new JSONObject();
                enrichersGroup.put("data", new JSONObject().put("id", "enrichersGroup").put("label", "Enrichment Pipeline")).put("classes", new JSONArray().put("graph-container"));
                nodes.put(enrichersGroup);
            }

            // Swimlanes for Enrichment Phases (under Enrichers)
            for (String phase : enrichersByPhase.keySet()) {
                if (!phaseGroups.contains(phase)) continue;
                nodes.put(new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", "phaseGroup_" + phase)
                                .put("label", InventoryEnrichmentPhase.valueOf(phase).displayName())
                                .put("parent", "enrichersGroup"))
                        .put("classes", new JSONArray().put("graph-container").put("enricher-phase")));
            }

            // Nodes for Downloaders
            for (JavaClass downloader : downloadClasses) {
                if (!downloadersForIndex.contains(downloader)) continue;
                final JavaAnnotation metadata = MirrorDocumentationGenerator.getMirrorMetadata(downloader);
                final String directoryName = MirrorDocumentationGenerator.getAnnotationStringValue(metadata, "directoryName");
                final String mavenPropertyName = MirrorDocumentationGenerator.getAnnotationStringValue(metadata, "mavenPropertyName");
                final String displayName = formatClassName(downloader.getName());
                final JSONArray classes = new JSONArray().put("graph-node").put("downloader");
                if (isDeprecated(downloader)) classes.put("deprecated");
                nodes.put(new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", downloader.getFullyQualifiedName())
                                .put("label", "<b>" + displayName + "</b><br>" + directoryName + " / " + mavenPropertyName)
                                .put("parent", "downloadersGroup"))
                        .put("classes", classes));
            }

            // Nodes for Indexes
            for (JavaClass index : indexClasses) {
                if (!indicesForIndex.contains(index)) continue;
                final JavaAnnotation metadata = MirrorDocumentationGenerator.getMirrorMetadata(index);
                final String directoryName = MirrorDocumentationGenerator.getAnnotationStringValue(metadata, "directoryName");
                final String mavenPropertyName = MirrorDocumentationGenerator.getAnnotationStringValue(metadata, "mavenPropertyName");
                final String displayName = formatClassName(index.getName());
                final JSONArray classes = new JSONArray().put("graph-node").put("index");
                if (isDeprecated(index)) classes.put("deprecated");
                nodes.put(new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", index.getFullyQualifiedName())
                                .put("label", "<b>" + displayName + "</b><br>" + directoryName + " / " + mavenPropertyName)
                                .put("parent", "indexesGroup"))
                        .put("classes", classes));
            }

            // Nodes for IndexQueries
            for (JavaClass indexQuery : indexQueryClasses) {
                if (!indexQueryClassesForIndex.contains(indexQuery)) continue;
                final JSONArray classes = new JSONArray().put("graph-node").put("index-query");
                if (isDeprecated(indexQuery)) classes.put("deprecated");
                nodes.put(new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", indexQuery.getFullyQualifiedName())
                                .put("label", "<b>" + formatClassName(indexQuery) + "</b>")
                                .put("parent", "indexQueriesGroup"))
                        .put("classes", classes));
            }

            // Nodes for Enrichers, grouped by phase
            for (Map.Entry<String, List<JavaClass>> entry : enrichersByPhase.entrySet()) {
                if (!phaseGroups.contains(entry.getKey())) continue;
                final String phase = entry.getKey();
                final String phaseGroupId = "phaseGroup_" + phase;
                final List<JavaClass> enrichersInPhase = entry.getValue();

                for (JavaClass enricher : enrichersInPhase) {
                    if (!enrichersForIndex.contains(enricher)) continue;
                    final String intermediateFileSuffix = InventoryEnrichmentStepsDocumentationGenerator.getEnricherIntermediateFileSuffix(enricher);
                    final String mavenPropertyName = InventoryEnrichmentStepsDocumentationGenerator.getEnricherMavenPropertyName(enricher);
                    nodes.put(new JSONObject()
                            .put("data", new JSONObject()
                                    .put("id", enricher.getFullyQualifiedName())
                                    .put("label", "<b>" + formatClassName(enricher) + "</b><br>" + intermediateFileSuffix + " / " + mavenPropertyName)
                                    .put("parent", phaseGroupId))
                            .put("classes", new JSONArray().put("graph-node").put("enricher")));
                }
            }

            // connection between Downloaders and Indexes using indexClassDependencies
            for (JavaClass index : indexClasses) {
                if (!indicesForIndex.contains(index)) continue;
                final Map<String, List<JavaClass>> dependencies = indexClassDependencies.get(index);
                for (Map.Entry<String, List<JavaClass>> entry : dependencies.entrySet()) {
                    final String dependencyType = entry.getKey();
                    final List<JavaClass> dependentClasses = entry.getValue();
                    for (JavaClass dependentClass : dependentClasses) {
                        final boolean isKnownDownloader = downloadersForIndex.contains(dependentClass);
                        final boolean isKnownIndex = indicesForIndex.contains(dependentClass);
                        if (!isKnownDownloader && !isKnownIndex) continue;

                        edges.put(new JSONObject()
                                .put("data", new JSONObject()
                                        .put("source", dependentClass.getFullyQualifiedName())
                                        .put("target", index.getFullyQualifiedName())
                                        .put("label", "Index -> " + dependencyType)));
                    }
                }
            }

            // connection between IndexeQueries and Enrichers
            for (Map.Entry<JavaClass, List<JavaClass>> entry : indexQueryUsages.entrySet()) {
                if (!enrichersForIndex.contains(entry.getKey())) continue;

                final JavaClass enricher = entry.getKey();
                final String enricherId = enricher.getFullyQualifiedName();
                final List<JavaClass> usedIndexQueries = entry.getValue();

                for (JavaClass indexQuery : usedIndexQueries) {
                    if (!indexQueryClassesForIndex.contains(indexQuery)) continue;

                    final String indexQueryId = indexQuery.getFullyQualifiedName();
                    edges.put(new JSONObject()
                            .put("data", new JSONObject()
                                    .put("source", indexQueryId)
                                    .put("target", enricherId)
                                    .put("label", "IndexQuery -> Enricher")));
                }
            }

            // connection between Indexes and IndexQueries, there is a 1:1 relationship
            for (Map.Entry<JavaClass, Index> entry : indexUsageInIndexQuery.entrySet()) {
                if (!indexQueryClassesForIndex.contains(entry.getKey())) continue;
                final JavaClass indexQuery = entry.getKey();
                final String indexQueryId = indexQuery.getFullyQualifiedName();
                final Index indexInstanceInstance = entry.getValue();
                final String indexId = indexInstanceInstance.getClass().getName();
                edges.put(new JSONObject()
                        .put("data", new JSONObject()
                                .put("source", indexId)
                                .put("target", indexQueryId)
                                .put("label", "Index -> IndexQuery")));
            }

            diagramsList.add("### " + formatClassName(generateDetailViewForIndexClass));
            diagramsList.add("![" + generateDetailViewForIndexClass.getName() + "](individual-detail-overview-diagram-rendered/individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getName() + ".png)");


            {
                final Map<String, String> templateReplacements = new HashMap<>();

                templateReplacements.put("nodes", nodes.toString().replace("\\/", "/"));
                templateReplacements.put("edges", edges.toString().replace("\\/", "/"));
                templateReplacements.put("png-save-scale", "2");
                templateReplacements.put("download-name", "individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getName());

                final List<String> targetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("template/large-overview-diagram.html"), templateReplacements);
                DocumentationGenerator.assertTemplateFullyFilled("individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getName() + ".html", targetLines);
                FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("diagrams/individual-detail-overview-diagram-html/individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getName() + ".html"), targetLines);
            }
        }

        {
            final Map<String, String> templateReplacements = new HashMap<>();

            templateReplacements.put("index-diagrams", diagramsList.toString());

            final List<String> targetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("template/individual-index-diagrams.md"), templateReplacements);
            DocumentationGenerator.assertTemplateFullyFilled("individual-index-diagrams.md", targetLines);
            FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("diagrams/individual-index-diagrams.md"), targetLines);
        }
    }


    public static List<JavaClass> getEnricherIndexQueryUsages(JavaClass enricherClass, List<JavaClass> indexQueryClasses) {
        final List<JavaClass> usages = new ArrayList<>();

        final Map<JavaClass, List<JavaField>> aggregatedFields = new LinkedHashMap<>();
        recursiveFindAllFields(enricherClass, aggregatedFields);

        for (Map.Entry<JavaClass, List<JavaField>> reference : aggregatedFields.entrySet()) {
            for (JavaField field : reference.getValue()) {
                for (JavaClass type : getAllTypes(field)) {
                    if (indexQueryClasses.contains(type)) {
                        usages.add(type);
                    }
                }
            }
        }

        return usages;
    }

    private static void recursiveFindAllFields(JavaClass clazz, Map<JavaClass, List<JavaField>> aggregatedFields) {
        if (aggregatedFields.containsKey(clazz)) {
            return;
        }

        try {
            aggregatedFields.put(clazz, new ArrayList<>(clazz.getFields()));
        } catch (Exception e) {
            System.err.println("Error processing class " + clazz.getFullyQualifiedName());
            return;
        }

        // superclass
        if (clazz.getSuperJavaClass() != null) {
            recursiveFindAllFields(clazz.getSuperJavaClass(), aggregatedFields);
        }

        // go into fields
        for (JavaField field : clazz.getFields()) {
            final JavaClass type = field.getType();
            recursiveFindAllFields(type, aggregatedFields);

            if (type instanceof DefaultJavaParameterizedType) {
                final DefaultJavaParameterizedType parameterizedType = (DefaultJavaParameterizedType) type;
                for (JavaType typeArgument : parameterizedType.getActualTypeArguments()) {
                    if (typeArgument instanceof JavaClass) {
                        recursiveFindAllFields((JavaClass) typeArgument, aggregatedFields);
                    }
                }
            }
        }
    }

    private static List<JavaClass> getAllTypes(JavaField field) {
        final List<JavaClass> types = new ArrayList<>();
        types.add(field.getType());

        if (field.getType() instanceof DefaultJavaParameterizedType) {
            final DefaultJavaParameterizedType parameterizedType = (DefaultJavaParameterizedType) field.getType();
            for (JavaType typeArgument : parameterizedType.getActualTypeArguments()) {
                if (typeArgument instanceof JavaClass) {
                    types.add((JavaClass) typeArgument);
                }
            }
        }

        return types;
    }
}
