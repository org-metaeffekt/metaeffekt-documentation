package com.metaeffekt.documentation.domain;

import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import com.thoughtworks.qdox.model.expression.TypeRef;
import lombok.RequiredArgsConstructor;

import java.util.Optional;

@RequiredArgsConstructor
public class EnricherMetadata {

    private final DocumentedType documentedType;

    public String getName() {
        return documentedType.getAnnotationStringValue("EnricherMetadata", "name").orElse(null);
    }

    public String getPhase() {
        return documentedType.getAnnotationStringValue("EnricherMetadata", "phase")
                .map(v -> v.replace(InventoryEnrichmentPhase.class.getSimpleName() + ".", ""))
                .orElse(null);
    }

    public String getIntermediateFileSuffix() {
        return documentedType.getAnnotationStringValue("EnricherMetadata", "intermediateFileSuffix").orElse(null);
    }

    public String getMavenPropertyName() {
        return documentedType.getAnnotationStringValue("EnricherMetadata", "mavenPropertyName").orElse(null);
    }

    /**
     * Returns the fully qualified class name of the explicit configuration class, if defined in the annotation.
     */
    public String getExplicitConfiguration() {
        Optional<AnnotationValue> property = documentedType.getAnnotationProperty("EnricherMetadata", "explicitConfiguration");

        if (property.isPresent()) {
            AnnotationValue val = property.get();
            if (val instanceof TypeRef) {
                return ((TypeRef) val).getType().getFullyQualifiedName();
            }
            return val.getParameterValue().toString().replace("\"", "");
        }
        return null;
    }

    /**
     * Resolves the DocumentedType for the configuration class associated with this enricher.
     * <p>
     * Strategy:
     * 1. Check {@link #getExplicitConfiguration()}.
     * 2. If absent, search recursively for a field named "configuration".
     *
     * @return The configuration type, or empty if not found.
     */
    public Optional<DocumentedType> getConfigurationType() {
        // 1. Try explicit configuration from annotation
        String explicit = getExplicitConfiguration();
        if (explicit != null) {
            return Optional.ofNullable(documentedType.getContext().getType(explicit));
        }

        // 2. Try legacy field search
        Optional<JavaField> configField = documentedType.getFields(true).stream()
                .filter(f -> f.getName().equals("configuration"))
                .findFirst();

        return configField.map(javaField -> documentedType.getContext().getType(javaField.getType().getFullyQualifiedName()));
    }

    /**
     * Generates a default ID string based on the configuration class name.
     * Used for creating predictable anchor links in the documentation.
     */
    public String getDefaultId() {
        return getConfigurationType()
                .map(DocumentedType::getSimpleName)
                .map(name -> name.replace("Configuration", "").replace("Inventory", "").replace("Enrichment", "")
                        .replaceAll("([a-z])([A-Z]+)", "$1-$2").toLowerCase())
                .orElse("unknown");
    }
}