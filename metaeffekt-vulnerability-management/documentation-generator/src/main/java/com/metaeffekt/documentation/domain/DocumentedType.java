package com.metaeffekt.documentation.domain;

import com.metaeffekt.documentation.DocumentationContext;
import com.thoughtworks.qdox.model.*;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Constructor;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
public class DocumentedType {

    @Getter
    private final JavaClass javaClass;

    @Getter
    private final DocumentationContext context;

    private Class<?> runtimeClass;
    private boolean runtimeClassResolved = false;

    private final Map<Class<?>, Object> metadataCache = new HashMap<>();

    public DocumentedType(JavaClass javaClass, DocumentationContext context) {
        this.javaClass = javaClass;
        this.context = context;
    }

    public String getFullyQualifiedName() {
        return javaClass.getFullyQualifiedName();
    }

    public String getSimpleName() {
        return javaClass.getSimpleName();
    }

    public Optional<String> getComment() {
        return Optional.ofNullable(javaClass.getComment());
    }

    public boolean isDeprecated() {
        return javaClass.getAnnotations().stream()
                .anyMatch(a -> a.getType().getValue().equals("Deprecated") || a.getType().getValue().equals("java.lang.Deprecated"));
    }

    public List<JavaField> getFields(boolean recursive) {
        if (!recursive) {
            return javaClass.getFields();
        }
        List<JavaField> fields = new ArrayList<>(javaClass.getFields());
        JavaClass superClass = javaClass.getSuperJavaClass();
        while (superClass != null && !superClass.getFullyQualifiedName().equals("java.lang.Object")) {
            fields.addAll(superClass.getFields());
            superClass = superClass.getSuperJavaClass();
        }
        return fields;
    }

    /**
     * Traverses the class hierarchy upwards to find a method with the given name.
     *
     * @param name The name of the method to find.
     * @return The JavaMethod if found, or empty.
     */
    public Optional<JavaMethod> findMethod(String name) {
        JavaClass current = javaClass;
        while (current != null && !current.getFullyQualifiedName().equals("java.lang.Object")) {
            JavaMethod method = current.getMethods().stream()
                    .filter(m -> m.getName().equals(name))
                    .findFirst().orElse(null);
            if (method != null) {
                return Optional.of(method);
            }
            current = current.getSuperJavaClass();
        }
        return Optional.empty();
    }

    /**
     * Traverses the class hierarchy upwards, collecting DocumentedTypes until a class matches
     * one of the stopClasses or the hierarchy ends.
     *
     * @param stopClasses A set of fully qualified class names or simple names to stop traversal at (exclusive).
     * @return A list of DocumentedTypes starting with this type, moving up the hierarchy.
     */
    public List<DocumentedType> getTypeHierarchy(Set<String> stopClasses) {
        List<DocumentedType> hierarchy = new ArrayList<>();

        if (stopClasses != null && (stopClasses.contains(javaClass.getFullyQualifiedName()) || stopClasses.contains(javaClass.getSimpleName()))) {
            return hierarchy;
        }

        hierarchy.add(this);

        JavaClass sup = javaClass.getSuperJavaClass();
        while (sup != null) {
            if (stopClasses != null) {
                if (stopClasses.contains(sup.getFullyQualifiedName()) || stopClasses.contains(sup.getSimpleName())) {
                    break;
                }
            }
            hierarchy.add(context.getType(sup));
            sup = sup.getSuperJavaClass();
        }

        return hierarchy;
    }

    /**
     * Finds all types in the project that extend or implement this type.
     * The result does not include this type itself.
     *
     * @return A list of subtypes.
     */
    public List<DocumentedType> findSubtypes() {
        String myFqn = getFullyQualifiedName();
        return context.getProjectBuilder().getClasses().stream()
                .filter(c -> c.isA(myFqn) && !c.getFullyQualifiedName().equals(myFqn))
                .map(context::getType)
                .collect(Collectors.toList());
    }

    @SuppressWarnings("unchecked")
    public <T> T as(Class<T> metadataClass) {
        return (T) metadataCache.computeIfAbsent(metadataClass, k -> {
            try {
                Constructor<T> constructor = metadataClass.getConstructor(DocumentedType.class);
                return constructor.newInstance(this);
            } catch (Exception e) {
                throw new RuntimeException("Failed to construct metadata view [" + metadataClass.getName() + "] for type [" + getFullyQualifiedName() + "].", e);
            }
        });
    }

    public Optional<Class<?>> getRuntimeClass() {
        if (!runtimeClassResolved) {
            try {
                this.runtimeClass = context.loadClass(javaClass.getFullyQualifiedName());
            } catch (Throwable t) {
                log.warn("Could not load runtime class for [{}]: {}", javaClass.getFullyQualifiedName(), t.getMessage());
            }
            runtimeClassResolved = true;
        }
        return Optional.ofNullable(runtimeClass);
    }

    public Optional<Object> instantiate(Object... args) {
        return getRuntimeClass().map(clazz -> {
            try {
                for (Constructor<?> c : clazz.getConstructors()) {
                    if (c.getParameterCount() == args.length) {
                        return c.newInstance(args);
                    }
                }
                // try empty constructor if no match found or specific args failed
                return clazz.getDeclaredConstructor().newInstance();
            } catch (Throwable e) {
                log.warn("Failed to instantiate [{}]: {}", clazz.getName(), e.getMessage());
                return null;
            }
        });
    }

    // --- Annotation & JavaDoc Helpers ---

    /**
     * Finds an annotation by name.
     * Checks if the annotation type value ends with the provided name (handling FQN vs SimpleName).
     */
    public Optional<JavaAnnotation> getAnnotation(String name) {
        return javaClass.getAnnotations().stream()
                .filter(a -> a.getType().getValue().endsWith(name))
                .findFirst();
    }

    /**
     * Gets the raw AnnotationValue object. Useful for checking types (TypeRef vs String).
     */
    public Optional<AnnotationValue> getAnnotationProperty(String annotationName, String parameterName) {
        return getAnnotation(annotationName).map(a -> a.getProperty(parameterName));
    }

    /**
     * Retrieves a named parameter from a specific annotation as a String.
     * Returns empty if the annotation is missing or the parameter is missing.
     * Quotes are automatically removed.
     */
    public Optional<String> getAnnotationStringValue(String annotationName, String parameterName) {
        return getAnnotationProperty(annotationName, parameterName)
                .map(val -> val.getParameterValue().toString().replace("\"", ""));
    }

    /**
     * Retrieves the value of a JavaDoc tag (e.g. @goal my-goal).
     */
    public Optional<String> getJavadocTagValue(String tagName) {
        DocletTag tag = javaClass.getTagByName(tagName);
        return tag == null ? Optional.empty() : Optional.of(tag.getValue().trim());
    }

    @Override
    public String toString() {
        return getFullyQualifiedName();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DocumentedType that = (DocumentedType) o;
        return getFullyQualifiedName().equals(that.getFullyQualifiedName());
    }

    @Override
    public int hashCode() {
        return getFullyQualifiedName().hashCode();
    }
}