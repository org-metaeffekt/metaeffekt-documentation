package com.metaeffekt.documentation.provider;

import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.documentation.util.MirrorUtils;
import com.metaeffekt.mirror.download.Download;
import com.metaeffekt.mirror.index.Index;
import com.thoughtworks.qdox.model.*;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;

import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class MirrorDataProvider implements DocumentationDataProvider {

    private static final Set<String> IGNORED_INITIALIZER_CLASSES = new HashSet<>(Arrays.asList(
            "com.metaeffekt.mirror.initializer.MirrorInitializer",
            "com.metaeffekt.mirror.initializer.DownloadInitializer",
            "com.metaeffekt.mirror.initializer.IndexInitializer",
            "MirrorInitializer",
            "DownloadInitializer",
            "IndexInitializer",
            "java.lang.Object"
    ));

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        List<JavaClass> downloads = context.getType(Download.class).findSubtypes().stream()
                .map(DocumentedType::getJavaClass)
                .collect(Collectors.toList());
        List<JavaClass> indexes = context.getType(Index.class).findSubtypes().stream()
                .map(DocumentedType::getJavaClass)
                .collect(Collectors.toList());

        downloads = excludeAllThatAreExtendedByOthers(downloads);
        indexes = excludeAllThatAreExtendedByOthers(indexes);

        List<JavaClass> allOrdered = MirrorUtils.orderMirrorClasses(context, merge(downloads, indexes));
        Map<String, JavaClass> mojoMapping = mapMojoInitializers(context);

        List<MirrorEntry> downloadEntries = new ArrayList<>();
        List<MirrorEntry> indexEntries = new ArrayList<>();

        for (JavaClass clazz : allOrdered) {
            boolean isDownload = downloads.contains(clazz);
            boolean isIndex = indexes.contains(clazz);
            if (!isDownload && !isIndex) continue;

            JavaAnnotation metadata = getMirrorMetadata(clazz);
            if (metadata == null) continue;

            String mavenProp = getAnnotationValue(metadata, "mavenPropertyName");
            JavaClass initializer = mojoMapping.get(mavenProp);

            MirrorEntry entry = new MirrorEntry(clazz, initializer, mavenProp, isDeprecated(clazz));
            if (isDownload) downloadEntries.add(entry);
            else indexEntries.add(entry);
        }

        Map<String, Supplier<String>> variables = new HashMap<>();

        variables.put("download-list-active", () -> generateList(downloadEntries, false));
        variables.put("download-list-deprecated", () -> generateList(downloadEntries, true));
        variables.put("download-full-doc", () -> generateDocs(context, downloadEntries, true));
        variables.put("download-pom-complete-configuration", () -> indent(generatePomBlock(context, downloadEntries, true), 20));
        variables.put("download-pom-short-configuration", () -> indent(generatePomBlock(context, downloadEntries, false), 20));

        variables.put("index-list-active", () -> generateList(indexEntries, false));
        variables.put("index-list-deprecated", () -> generateList(indexEntries, true));
        variables.put("index-full-doc", () -> generateDocs(context, indexEntries, false));
        variables.put("index-pom-complete-configuration", () -> indent(generatePomBlock(context, indexEntries, true), 20));

        return variables;
    }

    private List<JavaClass> merge(List<JavaClass> a, List<JavaClass> b) {
        List<JavaClass> l = new ArrayList<>(a);
        l.addAll(b);
        return l;
    }

    @AllArgsConstructor
    private static class MirrorEntry {
        JavaClass mirrorClass;
        JavaClass initializerClass;
        String mavenPropertyName;
        boolean isDeprecated;
    }

    private String generateList(List<MirrorEntry> entries, boolean deprecatedOnly) {
        StringJoiner joiner = new StringJoiner("\n- ", "- ", "");
        List<String> links = entries.stream()
                .filter(e -> e.isDeprecated == deprecatedOnly)
                .map(e -> {
                    String name = formatClassNameApplyDeprecated(e.mirrorClass);
                    return "[" + name + "](#" + toMarkdownId(name) + ")";
                })
                .collect(Collectors.toList());
        if (links.isEmpty()) return "";
        links.forEach(joiner::add);
        return joiner.toString();
    }

    private String generateDocs(DocumentationContext context, List<MirrorEntry> entries, boolean isDownload) {
        StringJoiner joiner = new StringJoiner("\n\n");
        for (MirrorEntry entry : entries) {
            StringBuilder doc = new StringBuilder();
            String method = isDownload ? "performDownload" : "createIndexDocuments";
            doc.append(generateHeader(context, entry.mirrorClass, method));
            if (isDownload) appendResourceLocationTable(doc, entry.mirrorClass);
            else appendIndexDependenciesTable(doc, context, entry.mirrorClass);
            joiner.add(doc);
        }
        return joiner.toString();
    }

    private String generateHeader(DocumentationContext context, JavaClass clazz, String relevantMethod) {
        StringBuilder sb = new StringBuilder();
        JavaAnnotation meta = getMirrorMetadata(clazz);
        String dir = getAnnotationValue(meta, "directoryName");
        String prop = getAnnotationValue(meta, "mavenPropertyName");

        sb.append("## ").append(formatClassNameApplyDeprecated(clazz)).append("\n\n");
        sb.append("`").append(dir).append("` / `").append(prop).append("`\n\n");

        sb.append(generateDocRelevantMethodExpandables(context, clazz, relevantMethod)).append("\n");

        if (clazz.getComment() != null && !clazz.getComment().isEmpty()) {
            sb.append(clazz.getComment()).append("\n\n");
        }
        return sb.toString();
    }

    public static String generateDocRelevantMethodExpandables(DocumentationContext context, JavaClass subjectClass, String relevantMethodName) {
        if (relevantMethodName != null) {
            JavaMethod method = context.getType(subjectClass).findMethod(relevantMethodName).orElse(null);

            if (method == null) {
                log.warn("Method [{}] not found on [{}] or its superclasses.", relevantMethodName, subjectClass.getName());
                return "";
            }

            Pair<String, JavaMethod> primaryExpandable = createSourceCodeExpandable(subjectClass, method);
            StringJoiner inBetweenContent = new StringJoiner("\n");
            inBetweenContent.add(primaryExpandable.getKey());

            List<Pair<JavaClass, JavaMethod>> docRelevantMethods = findDocRelevantMethod(context, subjectClass, primaryExpandable);
            for (Pair<JavaClass, JavaMethod> docRelevantMethod : docRelevantMethods) {
                inBetweenContent.add(createSourceCodeExpandable(docRelevantMethod.getKey(), docRelevantMethod.getValue()).getKey());
            }

            return inBetweenContent.toString();
        }
        return "";
    }

    public static List<Pair<JavaClass, JavaMethod>> findDocRelevantMethod(DocumentationContext context, JavaClass clazz, Pair<String, JavaMethod> methods) {
        JavaAnnotation docRelevantMethods = methods.getValue().getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("DocRelevantMethods"))
                .findFirst()
                .orElse(null);

        if (docRelevantMethods != null) {
            List<Pair<JavaClass, JavaMethod>> relevantMethods = new ArrayList<>();
            Object value = docRelevantMethods.getProperty("value").getParameterValue();

            List<String> refs = (value instanceof List) ? (List<String>) value : Collections.singletonList(value.toString());

            for (String reference : refs) {
                String[] parts = reference.replace("\"", "").split("#");
                if (parts.length == 2) {
                    String className = parts[0];
                    String methodName = parts[1].replaceAll("([^(]+)(\\(.*\\))", "$1");
                    String[] methodParams = parts[1].contains("(") ? parts[1].replaceAll("([^(]+)\\((.*)\\)", "$2").split(" *, *") : null;
                    if (methodParams != null && methodParams.length == 1 && methodParams[0].isEmpty()) methodParams = null;

                    JavaClass relevantClass = firstNonNull(
                            className.contains(".") ? context.getClassByName(className) : null,
                            className.isEmpty() || className.equals(clazz.getName()) ? clazz : null,
                            context.getProjectBuilder().getClasses().stream().filter(c -> c.getName().equals(className)).findFirst().orElse(null)
                    );

                    if (relevantClass != null) {
                        JavaMethod relevantMethod = findMethodByNameAndParams(relevantClass, methodName, methodParams);
                        if (relevantMethod != null) {
                            relevantMethods.add(Pair.of(relevantClass, relevantMethod));
                        }
                    }
                }
            }
            return relevantMethods;
        }
        return new ArrayList<>();
    }

    private static JavaMethod findMethodByNameAndParams(JavaClass clazz, String methodName, String[] methodParams) {
        if (methodParams == null) {
            return clazz.getMethods().stream().filter(m -> m.getName().equals(methodName)).findFirst().orElse(null);
        }
        return clazz.getMethods().stream()
                .filter(m -> m.getName().equals(methodName))
                .filter(m -> m.getParameters().size() == methodParams.length)
                .filter(m -> {
                    for (int i = 0; i < methodParams.length; i++) {
                        if (!m.getParameters().get(i).getType().getValue().equals(methodParams[i])) return false;
                    }
                    return true;
                })
                .findFirst().orElse(null);
    }

    public static Pair<String, JavaMethod> createSourceCodeExpandable(JavaClass clazz, JavaMethod method) {
        StringBuilder inBetweenContent = new StringBuilder();
        if (method != null) {
            final String baseCodeBlock = unindentCodeBlock(method.getCodeBlock(), 4);
            final String onlyCodePart = unindentCodeBlock(retainMiddlePart(baseCodeBlock.replaceAll("\\) throws [A-Za-z0-9_,. ]+ \\{", ") {"), ") {", "}"), 4);

            inBetweenContent.append("<details>\n\n<summary>Source Code for <code>")
                    .append(method.getDeclaringClass().getName())
                    .append(".").append(method.getName())
                    .append("(").append(method.getParameters().stream().map(p -> p.getType().getValue() + " " + p.getName()).collect(Collectors.joining(", ")).replace("java.lang.", "")).append(")")
                    .append("</code></summary>\n\n```java\n")
                    .append(onlyCodePart)
                    .append("\n```\n\n</details>\n\n");
        }
        return Pair.of(inBetweenContent.toString(), method);
    }

    private String generatePomBlock(DocumentationContext context, List<MirrorEntry> entries, boolean includeDetails) {
        List<MirrorEntry> active = entries.stream().filter(e -> !e.isDeprecated).collect(Collectors.toList());
        List<MirrorEntry> deprecated = entries.stream().filter(e -> e.isDeprecated).collect(Collectors.toList());

        StringBuilder sb = new StringBuilder();
        sb.append(generatePomSequence(context, active, includeDetails));

        if (!deprecated.isEmpty()) {
            sb.append("\n\n<!-- Deprecated steps -->\n").append(generatePomSequence(context, deprecated, false));
        }
        return sb.toString();
    }

    private String generatePomSequence(DocumentationContext context, List<MirrorEntry> entries, boolean includeDetails) {
        List<String> blocks = new ArrayList<>();
        for (MirrorEntry entry : entries) {
            blocks.add(generateSinglePomEntry(context, entry, includeDetails));
        }

        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < blocks.size(); i++) {
            String current = blocks.get(i);
            if (i > 0) {
                String previous = blocks.get(i - 1);
                // Gap logic: Single-to-Single = 1 newline; Any-to-Block or Block-to-Any = 2 newlines
                if (previous.contains("\n") || current.contains("\n")) {
                    sb.append("\n\n");
                } else {
                    sb.append("\n");
                }
            }
            sb.append(current);
        }
        return sb.toString();
    }

    private String generateSinglePomEntry(DocumentationContext context, MirrorEntry entry, boolean details) {
        if (entry.isDeprecated) return "<!-- <" + entry.mavenPropertyName + "/> -->";
        if (!details) return "<" + entry.mavenPropertyName + "/>";

        StringBuilder inner = new StringBuilder();
        if (entry.initializerClass != null) {
            Object instance = instantiate(context, entry.initializerClass);

            DocumentedType initType = context.getType(entry.initializerClass);
            List<DocumentedType> hierarchy = initType.getTypeHierarchy(IGNORED_INITIALIZER_CLASSES);
            Collections.reverse(hierarchy); // Order: GrandParent -> Parent -> Child

            for (DocumentedType type : hierarchy) {
                for (JavaField field : type.getJavaClass().getFields()) {
                    if (field.isStatic()) continue;
                    if (field.isFinal() && !isCollectionOrMap(field.getType())) continue;
                    String val = resolveDefaultValue(context, instance, field);
                    appendXmlComment(inner, "    ", field.getComment());
                    if (StringUtils.isEmpty(val)) inner.append("    <").append(field.getName()).append("/>\n");
                    else inner.append("    <").append(field.getName()).append(">").append(xmlEncode(val)).append("</").append(field.getName()).append(">\n");
                }
            }
        }

        JavaClass resEnum = getNestedEnum(entry.mirrorClass, "ResourceLocation");
        if (resEnum != null) {
            if (inner.length() > 0) inner.append("\n");
            inner.append("    <resourceLocations>\n");

            boolean first = true;
            for (JavaField c : resEnum.getEnumConstants()) {
                if (!first) {
                    inner.append("\n");
                }
                first = false;

                appendXmlComment(inner, "        ", c.getComment());
                String val = c.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "");
                inner.append("        <!-- <").append(c.getName()).append(">").append(xmlEncode(val)).append("</").append(c.getName()).append("> -->\n");
            }
            inner.append("    </resourceLocations>\n");
        }
        if (inner.length() == 0) return "<" + entry.mavenPropertyName + "/>";
        return "<" + entry.mavenPropertyName + ">\n" + inner + "</" + entry.mavenPropertyName + ">";
    }

    private void appendXmlComment(StringBuilder sb, String indent, String javadoc) {
        List<String> lines = formatJavadocForXmlComment(javadoc);
        if (lines.isEmpty()) return;
        sb.append(indent).append("<!-- ");
        if (lines.size() == 1) sb.append(lines.get(0)).append(" -->\n");
        else {
            sb.append(lines.get(0)).append("\n");
            for (int i = 1; i < lines.size(); i++) {
                sb.append(indent).append("     ").append(lines.get(i));
                if (i < lines.size() - 1) sb.append("\n");
                else sb.append(" -->\n");
            }
        }
    }

    private List<String> formatJavadocForXmlComment(String javadoc) {
        if (javadoc == null || javadoc.isEmpty()) return Collections.emptyList();
        String text = javadoc.replace("\r\n", "\n").replace("\r", "\n");
        text = text.replaceAll("<a\\s+href=\"([^\"]+)\"[^>]*>(.*?)</a>", "$2 ($1)");
        text = text.replaceAll("<code>(.*?)</code>", "'$1'");
        text = text.replaceAll("<ol>", "\n").replaceAll("<ul>", "\n").replaceAll("</ol>", "").replaceAll("</ul>", "").replaceAll("<li>", "\n- ").replaceAll("</li>", "");
        text = text.replaceAll("<p>", "\n").replaceAll("</p>", "").replaceAll("<br\\s*/?>", "\n").replaceAll("<pre>", "\n").replaceAll("</pre>", "");
        text = text.replaceAll("<[^>]+>", "").replace("&lt;", "<").replace("&gt;", ">").replace("&amp;", "&").replace("&quot;", "\"").replace("--", "__");
        List<String> cleaned = new ArrayList<>();
        for (String line : text.split("\n")) {
            String t = line.trim();
            if (!t.isEmpty()) cleaned.add(t);
        }
        return cleaned;
    }

    private Map<String, JavaClass> mapMojoInitializers(DocumentationContext context) {
        Map<String, JavaClass> map = new HashMap<>();
        JavaClass mojo = context.getClassByName("com.metaeffekt.mirror.plugin.DataMirrorMojo");
        if (mojo != null) for (JavaField f : mojo.getFields()) map.put(f.getName(), f.getType());
        return map;
    }

    private JavaAnnotation getMirrorMetadata(JavaClass clazz) {
        return clazz.getAnnotations().stream().filter(a -> a.getType().getValue().equals("MirrorMetadata")).findFirst().orElse(null);
    }

    private String getAnnotationValue(JavaAnnotation a, String key) {
        if (a == null) return "???";
        AnnotationValue val = a.getProperty(key);
        return val != null ? val.getParameterValue().toString().replace("\"", "") : "???";
    }

    private void appendResourceLocationTable(StringBuilder doc, JavaClass clazz) {
        JavaClass resEnum = getNestedEnum(clazz, "ResourceLocation");
        if (resEnum == null) return;
        doc.append("| Resource Location | Description |\n| --- | --- |\n");
        for (JavaField c : resEnum.getEnumConstants()) {
            String val = c.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "");
            String comment = c.getComment() != null ? c.getComment().replaceAll("\\s+", " ") : "";
            doc.append("| `").append(c.getName()).append("` | <p>").append(val).append("</p>").append(comment).append(" |\n");
        }
    }

    private void appendIndexDependenciesTable(StringBuilder doc, DocumentationContext context, JavaClass clazz) {
        Map<String, List<JavaClass>> deps = MirrorUtils.getIndexDependencies(context, clazz);
        doc.append("| Dependency Type | Depends on |\n| --- | --- |\n");
        deps.forEach((type, list) -> {
            if (list.isEmpty()) return;
            doc.append("| **").append(type).append("** | ");
            String links = list.stream().map(dep -> {
                String name = formatClassName(dep);
                if (isDeprecated(dep)) return "_" + name + "_";
                String link = type.toLowerCase().contains("download") ? "download.md" : "";
                return "[" + name + "](" + link + "#" + toMarkdownId(name) + ")";
            }).collect(Collectors.joining(", "));
            doc.append(links).append(" |\n");
        });
    }

    private JavaClass getNestedEnum(JavaClass clazz, String partialName) {
        return clazz.getNestedClasses().stream().filter(c -> c.isEnum() && c.getName().contains(partialName)).findFirst().orElse(null);
    }

    private Object instantiate(DocumentationContext context, JavaClass clazz) {
        try {
            return context.loadClass(clazz).getConstructor().newInstance();
        } catch (Exception e) {
            return null;
        }
    }

    private String resolveDefaultValue(DocumentationContext context, Object instance, JavaField field) {
        if ("apiKey".equals(field.getName())) return "${env.nvd.apikey}";
        if (instance != null) {
            try {
                java.lang.reflect.Field f = instance.getClass().getDeclaredField(field.getName());
                f.setAccessible(true);
                Object val = f.get(instance);
                if (val != null) return val.toString();
            } catch (Exception ignored) {
            }
        }
        if (field.getInitializationExpression() != null) {
            String expr = field.getInitializationExpression().replace("\"", "");
            if (expr.contains("new ArrayList") || expr.contains("new HashMap")) return "";
            if (expr.contains("new JSONArray")) return "[]";
            return expr;
        }
        return "";
    }

    private boolean isCollectionOrMap(JavaType type) {
        if (type == null) return false;
        String name = type.getFullyQualifiedName();
        return name.startsWith("java.util.List") || name.startsWith("java.util.Set") ||
                name.startsWith("java.util.Map") || name.startsWith("java.util.Collection");
    }
}