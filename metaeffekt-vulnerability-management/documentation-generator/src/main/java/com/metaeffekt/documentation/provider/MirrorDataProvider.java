package com.metaeffekt.documentation.provider;

import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.documentation.domain.MirrorMetadata;
import com.metaeffekt.documentation.util.MirrorUtils;
import com.metaeffekt.mirror.download.Download;
import com.metaeffekt.mirror.index.Index;
import com.metaeffekt.mirror.initializer.DownloadInitializer;
import com.metaeffekt.mirror.initializer.IndexInitializer;
import com.metaeffekt.mirror.initializer.MirrorInitializer;
import com.thoughtworks.qdox.model.*;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;

import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class MirrorDataProvider implements DocumentationDataProvider {

    private static final Class<?>[] IGNORED_INITIALIZER_CLASSES = {
            MirrorInitializer.class,
            DownloadInitializer.class,
            IndexInitializer.class,
            Object.class
    };

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        List<DocumentedType> downloads = context.getType(Download.class).findSubtypes();
        List<DocumentedType> indexes = context.getType(Index.class).findSubtypes();

        downloads = excludeAllThatAreExtendedByOthers(downloads);
        indexes = excludeAllThatAreExtendedByOthers(indexes);

        List<DocumentedType> allOrdered = MirrorUtils.orderMirrorClasses(context, merge(downloads, indexes));
        Map<String, DocumentedType> mojoMapping = mapMojoInitializers(context);

        List<MirrorEntry> downloadEntries = new ArrayList<>();
        List<MirrorEntry> indexEntries = new ArrayList<>();

        for (DocumentedType type : allOrdered) {
            boolean isDownload = downloads.contains(type);
            boolean isIndex = indexes.contains(type);
            if (!isDownload && !isIndex) continue;

            MirrorMetadata metadata = type.as(MirrorMetadata.class);
            String mavenProp = metadata.getMavenPropertyName();

            if ("???".equals(mavenProp)) continue;

            DocumentedType initializer = mojoMapping.get(mavenProp);

            MirrorEntry entry = new MirrorEntry(type, initializer, metadata, type.isDeprecated());
            if (isDownload) downloadEntries.add(entry);
            else indexEntries.add(entry);
        }

        Map<String, Supplier<String>> variables = new HashMap<>();

        variables.put("download-list-active", () -> generateList(downloadEntries, false));
        variables.put("download-list-deprecated", () -> generateList(downloadEntries, true));
        variables.put("download-full-doc", () -> generateDocs(context, downloadEntries, true));
        variables.put("download-pom-complete-configuration", () -> indent(generatePomBlock(context, downloadEntries, true), 20));
        variables.put("download-pom-short-configuration", () -> indent(generatePomBlock(context, downloadEntries, false), 20));

        variables.put("index-list-active", () -> generateList(indexEntries, false));
        variables.put("index-list-deprecated", () -> generateList(indexEntries, true));
        variables.put("index-full-doc", () -> generateDocs(context, indexEntries, false));
        variables.put("index-pom-complete-configuration", () -> indent(generatePomBlock(context, indexEntries, true), 20));

        return variables;
    }

    private List<DocumentedType> merge(List<DocumentedType> a, List<DocumentedType> b) {
        List<DocumentedType> l = new ArrayList<>(a);
        l.addAll(b);
        return l;
    }

    @AllArgsConstructor
    private static class MirrorEntry {
        DocumentedType mirrorType;
        DocumentedType initializerType;
        MirrorMetadata metadata;
        boolean isDeprecated;
    }

    private String generateList(List<MirrorEntry> entries, boolean deprecatedOnly) {
        StringJoiner joiner = new StringJoiner("\n- ", "- ", "");
        List<String> links = entries.stream()
                .filter(e -> e.isDeprecated == deprecatedOnly)
                .map(e -> {
                    String name = formatClassNameApplyDeprecated(e.mirrorType);
                    return "[" + name + "](#" + toMarkdownId(name) + ")";
                })
                .collect(Collectors.toList());
        if (links.isEmpty()) return "";
        links.forEach(joiner::add);
        return joiner.toString();
    }

    private String generateDocs(DocumentationContext context, List<MirrorEntry> entries, boolean isDownload) {
        StringJoiner joiner = new StringJoiner("\n\n");
        for (MirrorEntry entry : entries) {
            StringBuilder doc = new StringBuilder();
            String method = isDownload ? "performDownload" : "createIndexDocuments";
            doc.append(generateHeader(context, entry, method));
            if (isDownload) appendResourceLocationTable(doc, entry.metadata);
            else appendIndexDependenciesTable(doc, entry.metadata);
            joiner.add(doc);
        }
        return joiner.toString();
    }

    private String generateHeader(DocumentationContext context, MirrorEntry entry, String relevantMethod) {
        StringBuilder sb = new StringBuilder();
        String dir = entry.metadata.getDirectoryName();
        String prop = entry.metadata.getMavenPropertyName();

        sb.append("## ").append(formatClassNameApplyDeprecated(entry.mirrorType)).append("\n\n");
        sb.append("`").append(dir).append("` / `").append(prop).append("`\n\n");

        sb.append(generateDocRelevantMethodExpandables(context, entry.mirrorType, relevantMethod)).append("\n");

        entry.mirrorType.getComment().ifPresent(c -> sb.append(c).append("\n\n"));
        return sb.toString();
    }

    public static String generateDocRelevantMethodExpandables(DocumentationContext context, DocumentedType subjectType, String relevantMethodName) {
        if (relevantMethodName != null) {
            JavaMethod method = subjectType.findMethod(relevantMethodName).orElse(null);

            if (method == null) {
                log.warn("Method [{}] not found on [{}] or its superclasses.", relevantMethodName, subjectType.getFullyQualifiedName());
                return "";
            }

            Pair<String, JavaMethod> primaryExpandable = createSourceCodeExpandable(method);
            StringJoiner inBetweenContent = new StringJoiner("\n");
            inBetweenContent.add(primaryExpandable.getKey());

            List<Pair<JavaClass, JavaMethod>> docRelevantMethods = findDocRelevantMethod(context, subjectType, primaryExpandable);
            for (Pair<JavaClass, JavaMethod> docRelevantMethod : docRelevantMethods) {
                inBetweenContent.add(createSourceCodeExpandable(docRelevantMethod.getValue()).getKey());
            }

            return inBetweenContent.toString();
        }
        return "";
    }

    public static List<Pair<JavaClass, JavaMethod>> findDocRelevantMethod(DocumentationContext context, DocumentedType type, Pair<String, JavaMethod> methods) {
        JavaAnnotation docRelevantMethodsAnn = methods.getValue().getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("DocRelevantMethods"))
                .findFirst().orElse(null);

        if (docRelevantMethodsAnn != null) {
            List<Pair<JavaClass, JavaMethod>> relevantMethods = new ArrayList<>();
            AnnotationValue val = docRelevantMethodsAnn.getProperty("value");
            Object value = val.getParameterValue();

            List<String> refs = (value instanceof List) ? (List<String>) value : Collections.singletonList(value.toString());

            for (String reference : refs) {
                String[] parts = reference.replace("\"", "").split("#");
                if (parts.length == 2) {
                    String className = parts[0];
                    String methodName = parts[1].replaceAll("([^(]+)(\\(.*\\))", "$1");
                    String[] methodParams = parts[1].contains("(") ? parts[1].replaceAll("([^(]+)\\((.*)\\)", "$2").split(" *, *") : null;
                    if (methodParams != null && methodParams.length == 1 && methodParams[0].isEmpty()) methodParams = null;

                    DocumentedType relevantType;
                    if (className.isEmpty() || className.equals(type.getJavaClass().getName()) || className.equals(type.getJavaClass().getSimpleName())) {
                        relevantType = type;
                    } else {
                        relevantType = context.getType(className);
                    }

                    if (relevantType != null) {
                        JavaMethod relevantMethod = findMethodByNameAndParams(relevantType.getJavaClass(), methodName, methodParams);
                        if (relevantMethod != null) {
                            relevantMethods.add(Pair.of(relevantType.getJavaClass(), relevantMethod));
                        } else {
                            throw new IllegalStateException("Unknown relevant method: " + className + " " + methodName + " " + Arrays.toString(methodParams));
                        }
                    } else {
                        log.warn("Class {} not found for DocRelevantMethods (Simple name lookup failed)", className);
                    }
                }
            }
            return relevantMethods;
        }
        return new ArrayList<>();
    }

    private static JavaMethod findMethodByNameAndParams(JavaClass clazz, String methodName, String[] methodParams) {
        if (methodParams == null) {
            return clazz.getMethods().stream().filter(m -> m.getName().equals(methodName)).findFirst().orElse(null);
        }
        return clazz.getMethods().stream()
                .filter(m -> m.getName().equals(methodName))
                .filter(m -> m.getParameters().size() == methodParams.length)
                .filter(m -> {
                    for (int i = 0; i < methodParams.length; i++) {
                        if (!m.getParameters().get(i).getType().getValue().equals(methodParams[i])) return false;
                    }
                    return true;
                })
                .findFirst().orElse(null);
    }

    public static Pair<String, JavaMethod> createSourceCodeExpandable(JavaMethod method) {
        StringBuilder inBetweenContent = new StringBuilder();
        if (method != null) {
            final String baseCodeBlock = unindentCodeBlock(method.getCodeBlock(), 4);
            final String onlyCodePart = unindentCodeBlock(retainMiddlePart(baseCodeBlock.replaceAll("\\) throws [A-Za-z0-9_,. ]+ \\{", ") {"), ") {", "}"), 4);

            inBetweenContent.append("<details>\n\n<summary>Source Code for <code>")
                    .append(method.getDeclaringClass().getName())
                    .append(".").append(method.getName())
                    .append("(").append(method.getParameters().stream().map(p -> p.getType().getValue() + " " + p.getName()).collect(Collectors.joining(", ")).replace("java.lang.", "")).append(")")
                    .append("</code></summary>\n\n```java\n")
                    .append(onlyCodePart)
                    .append("\n```\n\n</details>\n\n");
        }
        return Pair.of(inBetweenContent.toString(), method);
    }

    private String generatePomBlock(DocumentationContext context, List<MirrorEntry> entries, boolean includeDetails) {
        List<MirrorEntry> active = entries.stream().filter(e -> !e.isDeprecated).collect(Collectors.toList());
        List<MirrorEntry> deprecated = entries.stream().filter(e -> e.isDeprecated).collect(Collectors.toList());

        StringBuilder sb = new StringBuilder();
        sb.append(generatePomSequence(context, active, includeDetails));

        if (!deprecated.isEmpty()) {
            sb.append("\n\n<!-- Deprecated steps -->\n").append(generatePomSequence(context, deprecated, false));
        }
        return sb.toString();
    }

    private String generatePomSequence(DocumentationContext context, List<MirrorEntry> entries, boolean includeDetails) {
        List<String> blocks = new ArrayList<>();
        for (MirrorEntry entry : entries) {
            blocks.add(generateSinglePomEntry(context, entry, includeDetails));
        }

        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < blocks.size(); i++) {
            String current = blocks.get(i);
            if (i > 0) {
                String previous = blocks.get(i - 1);
                // Gap logic: Single-to-Single = 1 newline; Any-to-Block or Block-to-Any = 2 newlines
                if (previous.contains("\n") || current.contains("\n")) {
                    sb.append("\n\n");
                } else {
                    sb.append("\n");
                }
            }
            sb.append(current);
        }
        return sb.toString();
    }

    private String generateSinglePomEntry(DocumentationContext context, MirrorEntry entry, boolean details) {
        if (entry.isDeprecated) return "<!-- <" + entry.metadata.getMavenPropertyName() + "/> -->";
        if (!details) return "<" + entry.metadata.getMavenPropertyName() + "/>";

        StringBuilder inner = new StringBuilder();
        if (entry.initializerType != null) {
            Object instance = entry.initializerType.instantiate().orElse(null);

            List<DocumentedType> hierarchy = entry.initializerType.getTypeHierarchy(IGNORED_INITIALIZER_CLASSES);
            Collections.reverse(hierarchy);

            for (DocumentedType type : hierarchy) {
                for (JavaField field : type.getJavaClass().getFields()) {
                    if (field.isStatic()) continue;
                    if (field.isFinal() && !isCollectionOrMap(field.getType())) continue;
                    String val = resolveDefaultValue(context, instance, field);
                    appendXmlComment(inner, "    ", field.getComment());
                    if (StringUtils.isEmpty(val)) inner.append("    <").append(field.getName()).append("/>\n");
                    else inner.append("    <").append(field.getName()).append(">").append(xmlEncode(val)).append("</").append(field.getName()).append(">\n");
                }
            }
        }

        List<MirrorMetadata.ResourceLocationEntry> locs = entry.metadata.getResourceLocations();
        if (!locs.isEmpty()) {
            if (inner.length() > 0) inner.append("\n");
            inner.append("    <resourceLocations>\n");

            boolean first = true;
            for (MirrorMetadata.ResourceLocationEntry c : locs) {
                if (!first) inner.append("\n");
                first = false;
                appendXmlComment(inner, "        ", c.getDescription());
                inner.append("        <!-- <").append(c.getName()).append(">").append(xmlEncode(c.getValue())).append("</").append(c.getName()).append("> -->\n");
            }
            inner.append("    </resourceLocations>\n");
        }

        String prop = entry.metadata.getMavenPropertyName();
        if (inner.length() == 0) return "<" + prop + "/>";
        return "<" + prop + ">\n" + inner + "</" + prop + ">";
    }

    private void appendXmlComment(StringBuilder sb, String indent, String javadoc) {
        List<String> lines = formatJavadocForXmlComment(javadoc);
        if (lines.isEmpty()) return;
        sb.append(indent).append("<!-- ");
        if (lines.size() == 1) sb.append(lines.get(0)).append(" -->\n");
        else {
            sb.append(lines.get(0)).append("\n");
            for (int i = 1; i < lines.size(); i++) {
                sb.append(indent).append("     ").append(lines.get(i));
                if (i < lines.size() - 1) sb.append("\n");
                else sb.append(" -->\n");
            }
        }
    }

    private List<String> formatJavadocForXmlComment(String javadoc) {
        if (javadoc == null || javadoc.isEmpty()) return Collections.emptyList();
        String text = javadoc.replace("\r\n", "\n").replace("\r", "\n");
        text = text.replaceAll("<a\\s+href=\"([^\"]+)\"[^>]*>(.*?)</a>", "$2 ($1)");
        text = text.replaceAll("<code>(.*?)</code>", "'$1'");
        text = text.replaceAll("<ol>", "\n").replaceAll("<ul>", "\n").replaceAll("</ol>", "").replaceAll("</ul>", "").replaceAll("<li>", "\n- ").replaceAll("</li>", "");
        text = text.replaceAll("<p>", "\n").replaceAll("</p>", "").replaceAll("<br\\s*/?>", "\n").replaceAll("<pre>", "\n").replaceAll("</pre>", "");
        text = text.replaceAll("<[^>]+>", "").replace("&lt;", "<").replace("&gt;", ">").replace("&amp;", "&").replace("&quot;", "\"").replace("--", "__");
        List<String> cleaned = new ArrayList<>();
        for (String line : text.split("\n")) {
            String t = line.trim();
            if (!t.isEmpty()) cleaned.add(t);
        }
        return cleaned;
    }

    private Map<String, DocumentedType> mapMojoInitializers(DocumentationContext context) {
        Map<String, DocumentedType> map = new HashMap<>();
        DocumentedType mojo = context.getType("com.metaeffekt.mirror.plugin.DataMirrorMojo");
        if (mojo != null) {
            for (JavaField f : mojo.getJavaClass().getFields()) {
                DocumentedType fieldType = context.getType(f.getType().getFullyQualifiedName());
                if (fieldType != null) {
                    map.put(f.getName(), fieldType);
                }
            }
        }
        return map;
    }

    private void appendResourceLocationTable(StringBuilder doc, MirrorMetadata metadata) {
        List<MirrorMetadata.ResourceLocationEntry> entries = metadata.getResourceLocations();
        if (entries.isEmpty()) return;
        doc.append("| Resource Location | Description |\n| --- | --- |\n");
        for (MirrorMetadata.ResourceLocationEntry c : entries) {
            String desc = c.getDescription() != null ? c.getDescription().replaceAll("\\s+", " ") : "";
            doc.append("| `").append(c.getName()).append("` | <p>").append(c.getValue()).append("</p>").append(desc).append(" |\n");
        }
    }

    private void appendIndexDependenciesTable(StringBuilder doc, MirrorMetadata metadata) {
        Map<String, List<DocumentedType>> deps = metadata.getIndexDependencies();
        doc.append("| Dependency Type | Depends on |\n| --- | --- |\n");
        deps.forEach((type, list) -> {
            if (list.isEmpty()) return;
            doc.append("| **").append(type).append("** | ");
            String links = list.stream().map(dep -> {
                String name = formatClassName(dep);
                if (isDeprecated(dep)) return "_" + name + "_";
                String link = type.toLowerCase().contains("download") ? "download.md" : "";
                return "[" + name + "](" + link + "#" + toMarkdownId(name) + ")";
            }).collect(Collectors.joining(", "));
            doc.append(links).append(" |\n");
        });
    }

    private String resolveDefaultValue(DocumentationContext context, Object instance, JavaField field) {
        if ("apiKey".equals(field.getName())) return "${env.nvd.apikey}";
        if (instance != null) {
            try {
                java.lang.reflect.Field f = instance.getClass().getDeclaredField(field.getName());
                f.setAccessible(true);
                Object val = f.get(instance);
                if (val != null) return val.toString();
            } catch (Exception ignored) {
            }
        }
        if (field.getInitializationExpression() != null) {
            String expr = field.getInitializationExpression().replace("\"", "");
            if (expr.contains("new ArrayList") || expr.contains("new HashMap")) return "";
            if (expr.contains("new JSONArray")) return "[]";
            return expr;
        }
        return "";
    }

    private boolean isCollectionOrMap(JavaType type) {
        if (type == null) return false;
        String name = type.getFullyQualifiedName();
        return name.startsWith("java.util.List") || name.startsWith("java.util.Set") ||
                name.startsWith("java.util.Map") || name.startsWith("java.util.Collection");
    }
}