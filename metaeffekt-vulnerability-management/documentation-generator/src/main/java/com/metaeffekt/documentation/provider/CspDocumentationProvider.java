package com.metaeffekt.documentation.provider;

import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.documentation.domain.MojoMetadata;
import com.metaeffekt.documentation.util.MavenMetadataService;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONObject;
import org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration;

import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.unwrapJavaDocLink;

public class CspDocumentationProvider implements DocumentationDataProvider {

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        Map<String, Supplier<String>> variables = new HashMap<>();

        variables.put("csp-loader-usage-table", () -> constructCspUsageTable(context));
        variables.put("csp-configuration-parameters", () -> constructParameterDocumentation(context));
        variables.put("index-pom-default-security-policy", () ->
                new JSONObject(new CentralSecurityPolicyConfiguration().getProperties()).toString(4)
        );
        variables.put("csp-latest-version", () -> CentralSecurityPolicyConfiguration.LATEST_VERSION);

        return variables;
    }

    private String constructParameterDocumentation(DocumentationContext context) {
        final StringBuilder doc = new StringBuilder();

        // 1. Static Analysis (Source)
        final DocumentedType configType = context.getType(CentralSecurityPolicyConfiguration.class);

        // 2. Runtime Analysis (Values)
        final CentralSecurityPolicyConfiguration defaultConfigInstance = new CentralSecurityPolicyConfiguration();
        final Map<String, Object> defaultProperties = defaultConfigInstance.getProperties();

        // Filter: Must exist in source AND be exposed in properties
        final List<JavaField> fields = configType.getJavaClass().getFields().stream()
                // .filter(f -> defaultProperties.containsKey(f.getName()))
                .sorted(Comparator.comparing(JavaField::getName))
                .collect(Collectors.toList());

        if (fields.size() != defaultProperties.size()) {
            System.err.println("Mismatch in CSP Configuration fields: Source[" + fields.size() + "] vs Runtime[" + defaultProperties.size() + "]");
        }

        for (JavaField field : fields) {
            appendFieldDocumentation(doc, field, defaultProperties.get(field.getName()));
        }

        return doc.toString();
    }

    private void appendFieldDocumentation(StringBuilder doc, JavaField field, Object defaultValue) {
        String name = field.getName();
        String description = field.getComment();

        // Extract "Default:" note from Javadoc if present
        String extractedDefaultNote = null;
        if (description != null && description.contains("Default:")) {
            StringBuilder descBuilder = new StringBuilder();
            for (String line : description.split("\\r?\\n")) {
                String plainText = line.replaceAll("<[^>]+>", "").trim();
                if (plainText.startsWith("Default:")) {
                    extractedDefaultNote = plainText.substring("Default:".length()).trim();
                    extractedDefaultNote = unwrapJavaDocLink(extractedDefaultNote);
                } else {
                    descBuilder.append(line).append("\n");
                }
            }
            description = descBuilder.toString().trim();
        }

        doc.append("<details>\n <summary><code>").append(name).append("</code></summary>\n\n");

        // Format Default Value
        appendDefaultValue(doc, defaultValue, extractedDefaultNote);

        doc.append("\n");

        if (StringUtils.isNotEmpty(description)) {
            doc.append(unwrapJavaDocLink(description)).append("\n\n");
        }
        doc.append("</details>\n\n");
    }

    private void appendDefaultValue(StringBuilder doc, Object defaultValue, String extractedNote) {
        if (defaultValue == null) {
            doc.append("**Default:** `null`");
        } else if (defaultValue instanceof Collection || defaultValue instanceof Map || defaultValue instanceof JSONObject || defaultValue instanceof JSONArray) {
            // Complex types
            String jsonStr = (defaultValue instanceof JSONObject) ? ((JSONObject) defaultValue).toString(2) :
                    (defaultValue instanceof JSONArray) ? ((JSONArray) defaultValue).toString(2) :
                            (defaultValue instanceof Map) ? new JSONObject((Map<?, ?>) defaultValue).toString(2) :
                                    new JSONArray((Collection<?>) defaultValue).toString(2);

            doc.append("**Default:**");
            if (StringUtils.isNotEmpty(extractedNote)) doc.append(" _(").append(extractedNote).append(")_");
            doc.append("\n\n```json\n").append(jsonStr).append("\n```\n");
            return;
        } else {
            // Simple types
            doc.append("**Default:** `").append(defaultValue).append("`");
        }

        if (StringUtils.isNotEmpty(extractedNote)) {
            doc.append(" _(").append(extractedNote).append(")_");
        }
        doc.append("\n");
    }

    private String constructCspUsageTable(DocumentationContext context) {
        final List<String> lines = new ArrayList<>();

        // Iterate all classes
        List<JavaClass> allClasses = context.getProjectBuilder().getClasses().stream()
                .sorted(Comparator.comparing(JavaClass::getName))
                .collect(Collectors.toList());

        for (JavaClass javaClass : allClasses) {
            DocumentedType type = context.getType(javaClass);
            String mojoName = type.as(MojoMetadata.class).getGoal();

            if (mojoName == null) {
                continue;
            }

            // Use Context helper for hierarchy search
            List<JavaField> allFields = type.getFields(true);

            boolean hasCspLoader = allFields.stream()
                    .anyMatch(f -> f.getType().getValue().equals("CspLoader") || f.getType().getFullyQualifiedName().endsWith(".CspLoader"));

            if (hasCspLoader) {
                // Use Context Service for POM parsing
                MavenMetadataService.MavenCoordinates coords = context.getMavenMetadataService().getMavenCoordinates(javaClass);
                lines.add("\n| `" + coords.groupId + "` | `" + coords.artifactId + "` | `" + mojoName + "`");
            }
        }

        StringBuilder table = new StringBuilder();
        table.append("| Group Id | Artifact Id | Mojo Goal |\n");
        table.append("| :--- | :--- | :--- |");

        if (lines.isEmpty()) {
            table.append("\n| - | - | - | - | - | No CspLoader usage found in Mojos |");
        } else {
            lines.sort(String::compareTo);
            lines.forEach(table::append);
        }

        return table.toString();
    }
}