package com.metaeffekt.documentation;

import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.documentation.util.MavenMetadataService;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaClass;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;

@Slf4j
public class DocumentationContext {

    @Getter
    private final JavaProjectBuilder projectBuilder;

    @Getter
    private final MavenMetadataService mavenMetadataService;

    @Getter
    private final File artifactAnalysisPath;
    @Getter
    private final File corePath;
    @Getter
    private final File mirrorPath;
    @Getter
    private final File documentationProjectPath;

    private final Map<String, DocumentedType> typeCache = new HashMap<>();

    private final Map<String, String> simpleClassNameIndex = new HashMap<>();

    public DocumentationContext(File artifactAnalysisPath, File corePath, File mirrorPath, File documentationProjectPath) {
        this.artifactAnalysisPath = artifactAnalysisPath;
        this.corePath = corePath;
        this.mirrorPath = mirrorPath;
        this.documentationProjectPath = documentationProjectPath;

        this.projectBuilder = new JavaProjectBuilder();
        this.mavenMetadataService = new MavenMetadataService();

        initializeSources();
    }

    private void initializeSources() {
        try {
            log.info("--- Parsing reference projects ---");
            log.info(" - artifact analysis: {}", artifactAnalysisPath);
            addSourcesExcludingBuildPaths(artifactAnalysisPath);

            if (corePath.exists() && !corePath.getAbsolutePath().equals(artifactAnalysisPath.getAbsolutePath())) {
                log.info(" - core: {}", corePath);
                addSourcesExcludingBuildPaths(corePath);
            } else {
                log.info("- skipping core as it does not exist or is equals to artifact analysis");
            }

            for (JavaClass javaClass : projectBuilder.getClasses()) {
                String simpleName = javaClass.getSimpleName();
                String fqn = javaClass.getFullyQualifiedName();

                if (simpleClassNameIndex.containsKey(simpleName)) {
                    log.debug("Duplicate simple name found: {}. Existing: {}, New: {}", simpleName, simpleClassNameIndex.get(simpleName), fqn);
                } else {
                    simpleClassNameIndex.put(simpleName, fqn);
                }
            }
            log.info("Indexed {} classes for simple name resolution.", simpleClassNameIndex.size());

        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize source code analysis", e);
        }
    }

    private void addSourcesExcludingBuildPaths(File rootDir) throws IOException {
        if (rootDir == null || !rootDir.exists()) return;

        Files.walkFileTree(rootDir.toPath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                String dirName = dir.getFileName().toString();
                String parentDirName = dir.getParent() != null ? dir.getParent().getFileName().toString() : "";

                if (dirName.equals("target") || dirName.equals(".test")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                if (parentDirName.equals("test") && dirName.equals("java")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                if (dirName.startsWith(".") && !dir.equals(rootDir.toPath())) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                if (file.toString().endsWith(".java")) {
                    try {
                        projectBuilder.addSource(file.toFile());
                    } catch (Exception e) {
                        log.warn("Failed to parse {} (skipping): {}", file, e.getMessage());
                    }
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    public DocumentedType getType(String name) {
        String fullyQualifiedName = name;
        if (!name.contains(".")) {
            String resolved = simpleClassNameIndex.get(name);
            if (resolved != null) {
                fullyQualifiedName = resolved;
            }
        }

        return typeCache.computeIfAbsent(fullyQualifiedName, fqn -> {
            JavaClass javaClass = projectBuilder.getClassByName(fqn);
            if (javaClass == null) {
                return null;
            }
            return new DocumentedType(javaClass, this);
        });
    }

    public DocumentedType getType(JavaClass javaClass) {
        if (javaClass == null) return null;
        return typeCache.computeIfAbsent(javaClass.getFullyQualifiedName(), k -> new DocumentedType(javaClass, this));
    }

    public DocumentedType getType(Class<?> clazz) {
        return getType(clazz.getName());
    }

    public JavaClass getClassByName(String fullyQualifiedName) {
        return projectBuilder.getClassByName(fullyQualifiedName);
    }

    public Class<?> loadClass(JavaClass javaClass) {
        return loadClass(javaClass.getFullyQualifiedName());
    }

    public Class<?> loadClass(String fullyQualifiedName) {
        try {
            return Class.forName(fullyQualifiedName);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Runtime class not found for [" + fullyQualifiedName + "]. " +
                    "Ensure the project is compiled and on the classpath.", e);
        }
    }
}
