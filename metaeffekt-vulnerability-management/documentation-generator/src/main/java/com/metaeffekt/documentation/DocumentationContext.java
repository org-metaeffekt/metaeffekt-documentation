package com.metaeffekt.documentation;

import com.metaeffekt.documentation.util.MavenMetadataService;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.JavaType;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class DocumentationContext {

    @Getter
    private final JavaProjectBuilder projectBuilder;

    @Getter
    private final MavenMetadataService mavenMetadataService;

    @Getter
    private final File artifactAnalysisPath;
    @Getter
    private final File corePath;
    @Getter
    private final File mirrorPath;
    @Getter
    private final File documentationProjectPath;

    public DocumentationContext(File artifactAnalysisPath, File corePath, File mirrorPath, File documentationProjectPath) {
        this.artifactAnalysisPath = artifactAnalysisPath;
        this.corePath = corePath;
        this.mirrorPath = mirrorPath;
        this.documentationProjectPath = documentationProjectPath;

        this.projectBuilder = new JavaProjectBuilder();
        this.mavenMetadataService = new MavenMetadataService();

        initializeSources();
    }

    private void initializeSources() {
        try {
            log.info("--- Parsing reference projects ---");
            log.info(" - artifact analysis: {}", artifactAnalysisPath);
            addSourcesExcludingBuildPaths(artifactAnalysisPath);

            if (corePath.exists() && !corePath.getAbsolutePath().equals(artifactAnalysisPath.getAbsolutePath())) {
                log.info(" - core: {}", corePath);
                addSourcesExcludingBuildPaths(corePath);
            } else {
                log.info("- skipping core as it does not exist or is equals to artifact analysis");
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize source code analysis", e);
        }
    }

    private void addSourcesExcludingBuildPaths(File rootDir) throws IOException {
        if (rootDir == null || !rootDir.exists()) return;

        Files.walkFileTree(rootDir.toPath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                String dirName = dir.getFileName().toString();
                String parentDirName = dir.getParent() != null ? dir.getParent().getFileName().toString() : "";

                if (dirName.equals("target") || dirName.equals(".test")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                if (parentDirName.equals("test") && dirName.equals("java")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                if (dirName.startsWith(".") && !dir.equals(rootDir.toPath())) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                if (file.toString().endsWith(".java")) {
                    try {
                        projectBuilder.addSource(file.toFile());
                    } catch (Exception e) {
                        log.warn("Failed to parse {} (skipping): {}", file, e.getMessage());
                    }
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    public JavaClass getClassByName(String fullyQualifiedName) {
        return projectBuilder.getClassByName(fullyQualifiedName);
    }

    /**
     * Finds all classes that extend the given class name, traversing up the hierarchy.
     */
    public List<JavaClass> findClassesExtending(String className) {
        final List<JavaClass> classes = new ArrayList<>();

        for (JavaClass clazz : projectBuilder.getClasses()) {
            JavaType superClass = clazz.getSuperClass();
            while (superClass != null) {
                if (superClass.getFullyQualifiedName().equals(className)) {
                    classes.add(clazz);
                    break;
                }
                JavaClass superClassClass = projectBuilder.getClassByName(superClass.getFullyQualifiedName());
                if (superClassClass != null) {
                    superClass = superClassClass.getSuperClass();
                } else {
                    break;
                }
            }
        }
        return classes;
    }

    /**
     * Recursively collects all fields from the class and its superclasses (excluding Object).
     */
    public List<JavaField> getFieldsRecursively(JavaClass clazz) {
        List<JavaField> fields = new ArrayList<>(clazz.getFields());
        JavaClass superClass = clazz.getSuperJavaClass();
        while (superClass != null && !superClass.getFullyQualifiedName().equals("java.lang.Object")) {
            fields.addAll(superClass.getFields());
            superClass = superClass.getSuperJavaClass();
        }
        return fields;
    }

    /**
     * Tries to load the runtime Class for a given QDox JavaClass.
     */
    public Class<?> loadClass(JavaClass javaClass) {
        return loadClass(javaClass.getFullyQualifiedName());
    }

    /**
     * Tries to load the runtime Class by name.
     */
    public Class<?> loadClass(String fullyQualifiedName) {
        try {
            return Class.forName(fullyQualifiedName);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Runtime class not found for [" + fullyQualifiedName + "]. " +
                    "Ensure the project is compiled and on the classpath.", e);
        }
    }
}
