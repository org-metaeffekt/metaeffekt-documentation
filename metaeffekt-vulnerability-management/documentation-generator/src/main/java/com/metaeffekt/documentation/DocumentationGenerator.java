package com.metaeffekt.documentation;

import com.metaeffekt.documentation.generator.*;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.metaeffekt.documentation.util.ImageUtils;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaType;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

@Slf4j
public class DocumentationGenerator {

    public static void main(String[] args) throws Exception {
        generateDocumentation();
        // cropImages(); // run only if the images were re-generated
    }

    private static void cropImages() throws IOException {
        ImageUtils.cropImagesInDirectoryToColoredArea(new File("metaeffekt-vulnerability-management/diagrams/individual-detail-overview-diagram-rendered"), "individual-detail-overview-diagram", 10);
        ImageUtils.cropImageToColoredArea(new File("metaeffekt-vulnerability-management/large-overview-diagram.png"), new File("metaeffekt-vulnerability-management/large-overview-diagram.png"), 10);
    }

    private static void generateDocumentation() throws Exception {
        final JavaProjectBuilder project = new JavaProjectBuilder();
        log.info("--- Parsing reference projects ---");
        project.addSourceTree(DocumentationProperties.getArtifactAnalysisPath());
        // project.addSourceTree(DocumentationProperties.getCorePath());

        for (IDocumentationGenerator generator : Arrays.asList(
                new MirrorDocumentationGenerator(),
                new InventoryEnrichmentStepsDocumentationGenerator(),
                new ContentIdentifiersDocumentationGenerator(),
                new OverviewChartVulnerabilityManagementGenerator(),
                new OverviewChartVulnerabilityManagementIndividualGenerator(),
                new DataSourceExampleDocumentationGenerator(),
                new CvssCnaInfoDocumentationGenerator(),
                new EolDataDocumentationGenerator(),
                new MsrcKbChainForProducts()
        )) {
            log.info("--- Starting generator [{}] ---", generator.getClass().getSimpleName());
            generator.generateDocumentation(project);
        }
    }

    public static List<JavaClass> findClassesExtending(JavaProjectBuilder project, String className) {
        final List<JavaClass> classes = new ArrayList<>();

        for (JavaClass clazz : project.getClasses()) {
            JavaType superClass = clazz.getSuperClass();

            while (superClass != null) {
                if (superClass.getFullyQualifiedName().equals(className)) {
                    classes.add(clazz);
                    break;
                }

                // fetch the superclass as JavaClass to continue up the hierarchy
                JavaClass superClassClass = project.getClassByName(superClass.getFullyQualifiedName());
                if (superClassClass != null) {
                    superClass = superClassClass.getSuperClass();
                } else {
                    break;
                }
            }
        }

        return classes;
    }

    public static File getVulnerabilityDocumentationFile(String path) {
        return new File(DocumentationProperties.getDocumentationProjectPath().getAbsolutePath() + "/metaeffekt-vulnerability-management/" + path);
    }

    public static List<String> fillTemplate(File templateFile, Map<String, String> replacements) throws IOException {
        final List<String> lines = FileUtils.readLines(templateFile, StandardCharsets.UTF_8);
        final List<String> filledLines = new ArrayList<>();

        for (String line : lines) {
            for (Map.Entry<String, String> replacement : replacements.entrySet()) {
                line = line.replace("$gen{" + replacement.getKey() + "}", replacement.getValue());
            }
            filledLines.add(line);
        }

        return filledLines;
    }

    public static void assertTemplateFullyFilled(String template, List<String> lines) {
        for (String line : lines) {
            if (line.contains("$gen{")) {
                throw new IllegalStateException("Template [" + template + "] not fully filled: " + line);
            }
        }
    }

    public static Class<?> loadClass(String fullyQualifiedName) {
        try {
            return Class.forName(fullyQualifiedName);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Unable to load class [" + fullyQualifiedName + "]", e);
        }
    }
}
