package com.metaeffekt.documentation;

import com.metaeffekt.documentation.generator.*;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.metaeffekt.documentation.util.ImageUtils;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaType;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

@Slf4j
public class DocumentationGenerator {

    public static void main(String[] args) throws Exception {
        generateDocumentation();
        // cropImages(); // run only if the images were re-generated
    }

    private static void cropImages() throws IOException {
        ImageUtils.cropImagesInDirectoryToColoredArea(new File("metaeffekt-vulnerability-management/diagrams/individual-detail-overview-diagram-rendered"), "individual-detail-overview-diagram", 10);
        ImageUtils.cropImageToColoredArea(new File("metaeffekt-vulnerability-management/large-overview-diagram.png"), new File("metaeffekt-vulnerability-management/large-overview-diagram.png"), 10);
    }

    private static void generateDocumentation() throws Exception {
        final JavaProjectBuilder project = new JavaProjectBuilder();

        System.out.println("--- Parsing reference projects ---");
        File analysisPath = DocumentationProperties.getArtifactAnalysisPath();
        File corePath = DocumentationProperties.getCorePath();

        System.out.println(" - artifact analysis: " + analysisPath);
        addSourcesExcludingBuildPaths(project, analysisPath);

        if (corePath.exists() && !corePath.getAbsolutePath().equals(analysisPath.getAbsolutePath())) {
            System.out.println(" - core: " + corePath);
            addSourcesExcludingBuildPaths(project, corePath);
        } else {
            System.out.println("- skipping core as it does not exist or is equals to artifact analysis");
        }

        for (IDocumentationGenerator generator : Arrays.asList(
                new MirrorDocumentationGenerator(),
                new InventoryEnrichmentStepsDocumentationGenerator(),
                new CspDocumentationGenerator(),
                new ContentIdentifiersDocumentationGenerator(),
                new OverviewChartVulnerabilityManagementGenerator(),
                new OverviewChartVulnerabilityManagementIndividualGenerator(),
                new DataSourceExampleDocumentationGenerator(),
                new CvssCnaInfoDocumentationGenerator(),
                new EolDataDocumentationGenerator(),
                new MsrcKbChainForProducts()
        )) {
            System.out.println("--- Starting generator [" + generator.getClass().getSimpleName() + "] ---");
            generator.generateDocumentation(project);
        }
    }


    private static void addSourcesExcludingBuildPaths(JavaProjectBuilder builder, File rootDir) throws IOException {
        if (rootDir == null || !rootDir.exists()) return;

        Files.walkFileTree(rootDir.toPath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                String dirName = dir.getFileName().toString();

                // SKIP CONDITIONS:
                // Skip 'target' directories (Maven build output)
                // Skip '.test' directories (referenced in your stacktrace)
                // You can also add "test" here if you want to skip src/test entirely
                if (dirName.equals("target") || dirName.equals(".test")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }

                // Optional: Skip hidden directories (starting with .)
                if (dirName.startsWith(".") && !dir.equals(rootDir.toPath())) {
                    return FileVisitResult.SKIP_SUBTREE;
                }

                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                try {
                    if (file.toString().endsWith(".java")) {
                        builder.addSource(file.toFile());
                    }
                } catch (Exception e) {
                    System.err.println("Failed to parse " + file + " (skipping): " + e.getMessage());
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    public static List<JavaClass> findClassesExtending(JavaProjectBuilder project, String className) {
        final List<JavaClass> classes = new ArrayList<>();

        for (JavaClass clazz : project.getClasses()) {
            JavaType superClass = clazz.getSuperClass();

            while (superClass != null) {
                if (superClass.getFullyQualifiedName().equals(className)) {
                    classes.add(clazz);
                    break;
                }

                // fetch the superclass as JavaClass to continue up the hierarchy
                JavaClass superClassClass = project.getClassByName(superClass.getFullyQualifiedName());
                if (superClassClass != null) {
                    superClass = superClassClass.getSuperClass();
                } else {
                    break;
                }
            }
        }

        return classes;
    }

    public static File getVulnerabilityDocumentationFile(String path) {
        return new File(DocumentationProperties.getDocumentationProjectPath().getAbsolutePath() + "/metaeffekt-vulnerability-management/" + path);
    }

    public static List<String> fillTemplate(File templateFile, Map<String, String> replacements) throws IOException {
        final List<String> lines = FileUtils.readLines(templateFile, StandardCharsets.UTF_8);
        final List<String> filledLines = new ArrayList<>();

        for (String line : lines) {
            for (Map.Entry<String, String> replacement : replacements.entrySet()) {
                line = line.replace("$gen{" + replacement.getKey() + "}", replacement.getValue());
            }
            filledLines.add(line);
        }

        return filledLines;
    }

    public static void assertTemplateFullyFilled(String template, List<String> lines) {
        for (String line : lines) {
            if (line.contains("$gen{")) {
                throw new IllegalStateException("Template [" + template + "] not fully filled: " + line);
            }
        }
    }

    public static Class<?> loadClass(String fullyQualifiedName) {
        try {
            return Class.forName(fullyQualifiedName);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Unable to load class [" + fullyQualifiedName + "]", e);
        }
    }
}
