package com.metaeffekt.documentation;

import com.metaeffekt.documentation.provider.*;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaType;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

@Slf4j
public class DocumentationGenerator {

    public static void main(String[] args) {
        try {
            log.info("Starting Documentation Generator (Pull Model)...");

            DocumentationContext context = new DocumentationContext(
                    DocumentationProperties.getArtifactAnalysisPath(),
                    DocumentationProperties.getCorePath(),
                    DocumentationProperties.getMirrorPath(),
                    DocumentationProperties.getDocumentationProjectPath()
            );

            TemplateRegistry registry = new TemplateRegistry();
            List<DocumentationDataProvider> providers = new ArrayList<>();
            providers.add(new CspDocumentationProvider());
            providers.add(new ContentIdentifiersDataProvider());
            providers.add(new InventoryEnrichmentDataProvider());
            providers.add(new MirrorDataProvider());
            providers.add(new DataSourceExampleDataProvider());
            providers.add(new CvssCnaInfoDataProvider());
            providers.add(new EolDataDataProvider());
            providers.add(new MsrcKbChainDataProvider());
            providers.add(new OverviewChartDataProvider());
            providers.add(new IndividualIndexDiagramsDataProvider());

            for (DocumentationDataProvider provider : providers) {
                log.info("Loading variables from provider: {}", provider.getClass().getSimpleName());
                Map<String, Supplier<String>> variables = provider.getTemplateVariables(context);
                log.info("  {}", variables.keySet());
                registry.registerAll(variables);
            }

            TemplateProcessor processor = new TemplateProcessor(registry, context);
            processor.processTemplates();

            log.info("Documentation generation finished successfully.");

        } catch (Exception e) {
            log.error("Critical failure during generation", e);
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void addSourcesExcludingBuildPaths(JavaProjectBuilder builder, File rootDir) throws IOException {
        if (rootDir == null || !rootDir.exists()) return;

        Files.walkFileTree(rootDir.toPath(), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                String dirName = dir.getFileName().toString();
                String parentDirName = dir.getParent().getFileName().toString();

                if (dirName.equals("target") || dirName.equals(".test")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }

                if (parentDirName.equals("test") && dirName.equals("java")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }

                // Optional: Skip hidden directories (starting with .)
                if (dirName.startsWith(".") && !dir.equals(rootDir.toPath())) {
                    return FileVisitResult.SKIP_SUBTREE;
                }

                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                try {
                    if (file.toString().endsWith(".java")) {
                        builder.addSource(file.toFile());
                    }
                } catch (Exception e) {
                    System.err.println("Failed to parse " + file + " (skipping): " + e.getMessage());
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    public static List<JavaClass> findClassesExtending(JavaProjectBuilder project, String className) {
        final List<JavaClass> classes = new ArrayList<>();

        for (JavaClass clazz : project.getClasses()) {
            JavaType superClass = clazz.getSuperClass();

            while (superClass != null) {
                if (superClass.getFullyQualifiedName().equals(className)) {
                    classes.add(clazz);
                    break;
                }

                // fetch the superclass as JavaClass to continue up the hierarchy
                JavaClass superClassClass = project.getClassByName(superClass.getFullyQualifiedName());
                if (superClassClass != null) {
                    superClass = superClassClass.getSuperClass();
                } else {
                    break;
                }
            }
        }

        return classes;
    }

    public static File getVulnerabilityDocumentationFile(String path) {
        return new File(DocumentationProperties.getDocumentationProjectPath().getAbsolutePath() + "/metaeffekt-vulnerability-management/" + path);
    }

    public static List<String> fillTemplate(File templateFile, Map<String, String> replacements) throws IOException {
        final List<String> lines = FileUtils.readLines(templateFile, StandardCharsets.UTF_8);
        final List<String> filledLines = new ArrayList<>();

        for (String line : lines) {
            for (Map.Entry<String, String> replacement : replacements.entrySet()) {
                line = line.replace("$gen{" + replacement.getKey() + "}", replacement.getValue());
            }
            filledLines.add(line);
        }

        return filledLines;
    }

    public static void assertTemplateFullyFilled(String template, List<String> lines) {
        for (String line : lines) {
            if (line.contains("$gen{")) {
                throw new IllegalStateException("Template [" + template + "] not fully filled: " + line);
            }
        }
    }

    public static Class<?> loadClass(String fullyQualifiedName) {
        try {
            return Class.forName(fullyQualifiedName);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Unable to load class [" + fullyQualifiedName + "]", e);
        }
    }
}
