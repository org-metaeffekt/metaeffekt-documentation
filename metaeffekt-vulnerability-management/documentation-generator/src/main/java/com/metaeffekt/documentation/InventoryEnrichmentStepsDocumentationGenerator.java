package com.metaeffekt.documentation;

import com.metaeffekt.artifact.enrichment.InventoryEnrichmentPipeline;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import com.thoughtworks.qdox.model.expression.TypeRef;
import org.apache.commons.io.FileUtils;
import org.json.JSONArray;
import org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.util.*;

import static com.metaeffekt.documentation.MarkdownDocUtils.*;

public class InventoryEnrichmentStepsDocumentationGenerator {

    private final static Set<String> EXCLUDED_ENRICHERS = new HashSet<>();

    static {
        EXCLUDED_ENRICHERS.add(InventoryEnrichmentPipeline.class.getName());
    }

    private final static Set<String> POM_EXCLUDED_ENRICHMENT_PHASES = new HashSet<>();

    static {
        POM_EXCLUDED_ENRICHMENT_PHASES.add(InventoryEnrichmentPhase.STANDALONE.name());
    }

    public void generateDocumentation(JavaProjectBuilder project) throws IOException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        final List<JavaClass> inventoryEnrichmentClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderEnrichmentClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.artifact.enrichment.InventoryEnricher")));
        inventoryEnrichmentClasses.removeIf(c -> EXCLUDED_ENRICHERS.contains(c.getFullyQualifiedName()));
        final Map<String, List<JavaClass>> enrichersByPhase = groupEnrichersByPhases(inventoryEnrichmentClasses);

        final Map<String, String> templateReplacements = new HashMap<>();

        final StringJoiner inventoryEnrichersList = new StringJoiner("\n", "", "");
        final StringJoiner completeMavenPomJoiner = new StringJoiner("\n");
        final StringJoiner shortMavenPomJoiner = new StringJoiner("\n");

        for (Map.Entry<String, List<JavaClass>> enrichersBySinglePhase : enrichersByPhase.entrySet()) {
            final String phase = enrichersBySinglePhase.getKey();
            final String phaseDisplayName = InventoryEnrichmentPhase.valueOf(enrichersBySinglePhase.getKey()).displayName();
            final List<JavaClass> enrichers = enrichersBySinglePhase.getValue();
            final boolean includePomPhase = !POM_EXCLUDED_ENRICHMENT_PHASES.contains(phase);

            final StringJoiner inventoryEnrichersDetailsJoiner = new StringJoiner("\n\n");
            final StringJoiner inventoryEnrichersListElement = new StringJoiner("\n  - ", "- **[" + phaseDisplayName + "](#" + toMarkdownId(phaseDisplayName) + ")**\n  - ", "");

            if (includePomPhase) {
                shortMavenPomJoiner.add("<!-- " + phaseDisplayName + " -->");
                completeMavenPomJoiner.add("<!-- " + phaseDisplayName + " -->");
            }

            for (Iterator<JavaClass> iterator = enrichers.iterator(); iterator.hasNext(); ) {
                final JavaClass enricher = iterator.next();
                final JavaClass directConfiguration = findConfigurationClassForEnricher(project, enricher);
                final List<JavaClass> superConfigurations = configurationIncludingSuperclasses(directConfiguration);

                inventoryEnrichersListElement.add("[" + formatClassNameApplyDeprecated(enricher) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(enricher)) + ")");

                inventoryEnrichersDetailsJoiner.add(generateInventoryEnricherDocumentation(project, enricher, directConfiguration, superConfigurations));

                if (includePomPhase) {
                    shortMavenPomJoiner.add(generateMavenPomConfigurationEntryForEnrichmentStep(enricher, directConfiguration, false));
                    completeMavenPomJoiner.add(generateMavenPomConfigurationEntryForEnrichmentStep(enricher, directConfiguration, true));
                    if (iterator.hasNext()) {
                        completeMavenPomJoiner.add("");
                    }
                }
            }

            inventoryEnrichersList.add(inventoryEnrichersListElement.toString());
            templateReplacements.put("enrichment-steps-full-doc-" + phase, inventoryEnrichersDetailsJoiner.toString());
            templateReplacements.put("enrichment-steps-phase-title-" + phase, phaseDisplayName);

            if (includePomPhase) {
                shortMavenPomJoiner.add("");
                completeMavenPomJoiner.add("");
            }
        }
        templateReplacements.put("enrichment-steps-active", inventoryEnrichersList.toString());
        templateReplacements.put("index-pom-short-configuration", indent(shortMavenPomJoiner.toString(), 20));
        templateReplacements.put("index-pom-complete-configuration", indent(completeMavenPomJoiner.toString(), 20));


        final List<String> downloadTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("inventory-enrichment/template/inventory-enrichment-steps.md"), templateReplacements);
        DocumentationGenerator.assertTemplateFullyFilled("inventory-enrichment-steps.md", downloadTargetLines);

        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("inventory-enrichment/inventory-enrichment-steps.md"), downloadTargetLines);
    }

    private final static Map<String, String> CUSTOM_PLURAL_TO_SINGULAR = new HashMap<>();

    static {
        CUSTOM_PLURAL_TO_SINGULAR.put("additionalStatus", "status");
        CUSTOM_PLURAL_TO_SINGULAR.put("activeLabel", "label");
        CUSTOM_PLURAL_TO_SINGULAR.put("additionalValidators", "validator");
        CUSTOM_PLURAL_TO_SINGULAR.put("detailLevels", "level");
        CUSTOM_PLURAL_TO_SINGULAR.put("failOnUnreviewedAdvisoriesTypes", "advisoryType");
    }

    private final static Set<String> EXCLUDED_CONFIGURATION_FIELDS = new HashSet<>(Arrays.asList(
            "LOG", "logger", "log", "configuration",
            "addonVulnerabilityKeywords"
    ));

    private final static Set<String> ASSUME_EMPTY_CONFIGURATION_FIELDS = new HashSet<>(Arrays.asList(
            "requireSecondaryIndicationTermsLimiters"
    ));

    private String generateMavenPomConfigurationEntryForEnrichmentStep(JavaClass clazz, JavaClass directConfiguration, boolean includeDetails) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        final JavaAnnotation mirrorMetadata = clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("EnricherMetadata"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No @EnricherMetadata annotation found on " + clazz.getName()));
        final AnnotationValue mavenPropertyName = mirrorMetadata.getProperty("mavenPropertyName");

        final String tagName = mavenPropertyName.getParameterValue().toString().replace("\"", "");
        final String baseTag = "<" + tagName + "/>";
        if (!includeDetails) {
            return baseTag;
        }

        final Class<?> clazzClass = Class.forName(directConfiguration.getFullyQualifiedName());

        if (Modifier.isAbstract(clazzClass.getModifiers())) {
            return baseTag;
        }

        final Object instance = clazzClass.getDeclaredConstructor().newInstance();

        if (!(instance instanceof ProcessConfiguration)) {
            throw new IllegalStateException("Configuration class does not implement ProcessConfiguration: " + directConfiguration.getName());
        }

        final ProcessConfiguration configuration = (ProcessConfiguration) instance;

        final StringJoiner propertiesJoiner = new StringJoiner("\n");

        for (Field field : configuration.getClass().getDeclaredFields()) {
            if (!field.isAccessible()) {
                field.setAccessible(true);
            }

            final String fieldName = field.getName();
            Object fieldValue = field.get(configuration);

            if (EXCLUDED_CONFIGURATION_FIELDS.contains(fieldName)) {
                continue;
            }

            if (fieldValue == null || ASSUME_EMPTY_CONFIGURATION_FIELDS.contains(fieldName)) {
                propertiesJoiner.add("  <!-- <" + fieldName + "/> --> <!-- type: " + field.getType().getSimpleName() + " -->");
                continue;
            }

            // turn arrays into lists
            if (fieldValue.getClass().isArray()) {
                fieldValue = new ArrayList<>(Arrays.asList((Object[]) fieldValue));
            } else if (fieldValue instanceof JSONArray) {
                fieldValue = ((JSONArray) fieldValue).toList();
            }

            final String displayValue;

            if (fieldValue instanceof String) {
                displayValue = (String) fieldValue;
            } else if (fieldValue instanceof Number || fieldValue instanceof Boolean) {
                displayValue = fieldValue.toString();

            } else if (fieldValue instanceof List) {
                // build XML list
                final String fieldTagName = CUSTOM_PLURAL_TO_SINGULAR.getOrDefault(fieldName, fieldName.toLowerCase().contains("file") ? "file" : fieldName.replaceAll("([a-zA-Z]+)s$", "$1"));
                if (((List<?>) fieldValue).isEmpty()) {
                    displayValue = "\n    <!-- <" + fieldTagName + ">...</" + fieldTagName + "> -->\n  ";
                } else {
                    final StringJoiner listJoiner = new StringJoiner("\n", "\n", "\n  ");
                    for (Object listValue : (List<?>) fieldValue) {
                        listJoiner.add("    <" + fieldTagName + ">" + listValue + "</" + fieldTagName + ">");
                    }
                    displayValue = listJoiner.toString();
                }
            } else {
                System.out.println("Unknown field type: " + fieldValue.getClass().getName() + " for " + fieldName + " = " + fieldValue);
                displayValue = fieldValue.toString();
            }

            propertiesJoiner.add("  <" + fieldName + ">" + displayValue + "</" + fieldName + ">");
        }

        if (propertiesJoiner.length() == 0) {
            return baseTag;
        }

        return "<" + tagName + ">\n" +
                propertiesJoiner +
                "\n</" + tagName + ">";
    }

    private String generateInventoryEnricherDocumentation(JavaProjectBuilder project, JavaClass clazz, JavaClass directConfiguration, List<JavaClass> allConfigurationClasses) {
        final StringBuilder content = new StringBuilder();

        final String intermediateFileSuffix = getEnricherIntermediateFileSuffix(clazz);
        final String mavenPropertyName = getEnricherMavenPropertyName(clazz);

        content.append("## ").append(formatClassNameApplyDeprecated(clazz)).append("\n\n");
        content.append("`").append(intermediateFileSuffix).append("` / `").append(mavenPropertyName).append("`\n\n");

        content.append(MirrorDocumentationGenerator.generateDocRelevantMethodExpandables(project, clazz, "performEnrichment")).append("\n");

        if (clazz.getComment() != null && !clazz.getComment().isEmpty()) {
            content.append(unwrapJavaDocLink(clazz.getComment())).append("\n\n");
        }

        for (JavaClass configurationClass : allConfigurationClasses) {
            if (!configurationClass.getFields().isEmpty()) {
                final String configDisplayName = "Configuration: " + formatClassName(configurationClass).replace(" Configuration", "").replace(" Inventory", "");
                content.append("#### ").append(configDisplayName).append("\n\n");
                content.append(generateConfigurationDescription(configurationClass)).append("\n\n");
            }
        }

        return content.toString();
    }

    private String generateConfigurationDescription(JavaClass configurationClass) {
        final StringBuilder content = new StringBuilder();

        content.append("<table><tr><th>Parameter</th><th>Default</th></tr>");

        for (JavaField field : configurationClass.getFields()) {
            final String fieldName = field.getName();
            final String fieldDescription = field.getComment() != null ? field.getComment().replaceAll("(\r?\n)+", " ") : "";
            final String defaultValue = field.getInitializationExpression() != null ? field.getInitializationExpression().toString().replace("\n", "").replace("\r", "") : "";
            content.append("<tr><td><code>").append(fieldName).append("</code></td><td><code>").append(defaultValue).append("</code></td></tr>");
            if (!fieldDescription.isEmpty()) {
                content.append("<tr><td colspan=2>").append(unwrapJavaDocLink(fieldDescription)).append("</td></tr>");
            }
        }

        content.append("</table>");

        return content.toString();
    }

    private JavaClass findConfigurationClassForEnricher(JavaProjectBuilder project, JavaClass enrichmentClass) {
        final String explicitConfiguration = getEnricherExplicitConfiguration(enrichmentClass);

        if (explicitConfiguration != null) {
            return project.getClassByName(explicitConfiguration);
        }

        final JavaField configurationField = firstNonNull(
                enrichmentClass.getFieldByName("configuration"),
                enrichmentClass.getSuperJavaClass().getFieldByName("configuration")
        );

        if (configurationField == null) {
            throw new IllegalStateException("Configuration field not found for enricher: " + enrichmentClass.getName());
        }

        final String fullyQualifiedName = configurationField.getType().getFullyQualifiedName();
        return project.getClassByName(fullyQualifiedName);
    }

    private final static Set<String> UPPER_BOUND_CONFIGURATION_CLASSES = new HashSet<>(Arrays.asList("java.lang.Object", "org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration"));

    private List<JavaClass> configurationIncludingSuperclasses(JavaClass configurationClass) {
        final List<JavaClass> configurationClassesIncludingSuperclasses = new ArrayList<>();
        configurationClassesIncludingSuperclasses.add(configurationClass);

        JavaClass superClass = configurationClass.getSuperJavaClass();
        while (superClass != null) {
            // get until ProcessConfiguration is reached
            if (UPPER_BOUND_CONFIGURATION_CLASSES.contains(superClass.getFullyQualifiedName())) {
                break;
            }

            configurationClassesIncludingSuperclasses.add(superClass);
            superClass = superClass.getSuperJavaClass();
        }

        return configurationClassesIncludingSuperclasses;
    }

    private Map<String, List<JavaClass>> groupEnrichersByPhases(List<JavaClass> inventoryEnrichmentClasses) {
        // use the "phase" value of the EnricherMetadata annotation to group the enrichers
        final Map<String, List<JavaClass>> enrichersByPhase = new LinkedHashMap<>();

        for (InventoryEnrichmentPhase phase : InventoryEnrichmentPhase.values()) {
            enrichersByPhase.computeIfAbsent(phase.name(), k -> new ArrayList<>());
        }

        for (JavaClass clazz : inventoryEnrichmentClasses) {
            final String phase = getEnricherPhase(clazz);

            enrichersByPhase.computeIfAbsent(phase, k -> new ArrayList<>()).add(clazz);
        }

        return enrichersByPhase;
    }

    private static String getEnricherPhase(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "phase")
                .replace(InventoryEnrichmentPhase.class.getSimpleName() + ".", "");
    }

    public static String getEnricherName(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "name");
    }

    public static String getEnricherIntermediateFileSuffix(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "intermediateFileSuffix");
    }

    public static String getEnricherMavenPropertyName(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "mavenPropertyName");
    }

    public static String getEnricherExplicitConfiguration(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "explicitConfiguration");
    }

    private static JavaAnnotation getEnricherMetadataAnnotation(JavaClass clazz) {
        return clazz.getAnnotations().stream().filter(a -> a.getType().getValue().contains("EnricherMetadata")).findFirst().orElse(null);
    }

    private static String getAnnotationValue(JavaAnnotation annotation, String property) {
        if (annotation == null) {
            return null;
        }
        try {
            final AnnotationValue prop = annotation.getProperty(property);
            if (prop == null) {
                return null;
            }
            if (prop instanceof TypeRef) {
                return ((TypeRef) prop).getType().getFullyQualifiedName();
            }
            return prop.getParameterValue().toString().replace("\"", "");
        } catch (Exception e) {
            throw new IllegalStateException("Annotation property access failed: " + property, e);
        }
    }
}
