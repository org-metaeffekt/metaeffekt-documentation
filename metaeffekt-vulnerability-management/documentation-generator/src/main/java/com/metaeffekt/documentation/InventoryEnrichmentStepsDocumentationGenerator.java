package com.metaeffekt.documentation;

import com.metaeffekt.artifact.enrichment.InventoryEnrichmentPipeline;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import com.thoughtworks.qdox.model.expression.TypeRef;
import org.apache.commons.io.FileUtils;

import java.io.IOException;
import java.util.*;

import static com.metaeffekt.documentation.MarkdownDocUtils.*;

public class InventoryEnrichmentStepsDocumentationGenerator {

    private final static Set<String> EXCLUDED_ENRICHERS = new HashSet<>();

    static {
        EXCLUDED_ENRICHERS.add(InventoryEnrichmentPipeline.class.getName());
    }

    public void generateDocumentation(JavaProjectBuilder project) throws IOException {
        final List<JavaClass> inventoryEnrichmentClasses = excludeAllThatAreExtendedByOthers(MirrorDocumentationGenerator.orderEnrichmentClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.artifact.enrichment.InventoryEnricher")));
        inventoryEnrichmentClasses.removeIf(c -> EXCLUDED_ENRICHERS.contains(c.getFullyQualifiedName()));
        final Map<String, List<JavaClass>> enrichersByPhase = groupEnrichersByPhases(inventoryEnrichmentClasses);

        final Map<String, String> templateReplacements = new HashMap<>();

        final StringJoiner inventoryEnrichersList = new StringJoiner("\n", "", "");

        for (Map.Entry<String, List<JavaClass>> enrichersBySinglePhase : enrichersByPhase.entrySet()) {
            final String phase = enrichersBySinglePhase.getKey();
            final String phaseDisplayName = InventoryEnrichmentPhase.valueOf(enrichersBySinglePhase.getKey()).displayName();
            final List<JavaClass> enrichers = enrichersBySinglePhase.getValue();

            final StringJoiner inventoryEnrichersDetailsJoiner = new StringJoiner("\n\n");
            final StringJoiner inventoryEnrichersListElement = new StringJoiner("\n  - ", "- **[" + phaseDisplayName + "](#" + toMarkdownId(phaseDisplayName) + ")**\n  - ", "");

            for (JavaClass enricher : enrichers) {
                final JavaClass directConfiguration = findConfigurationClassForEnricher(project, enricher);
                final List<JavaClass> superConfigurations = configurationIncludingSuperclasses(directConfiguration);
                inventoryEnrichersListElement.add("[" + formatClassNameApplyDeprecated(enricher) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(enricher)) + ")");
                inventoryEnrichersDetailsJoiner.add(generateInventoryEnricherDocumentation(project, enricher, directConfiguration, superConfigurations));
            }

            inventoryEnrichersList.add(inventoryEnrichersListElement.toString());
            templateReplacements.put("enrichment-steps-full-doc-" + phase, inventoryEnrichersDetailsJoiner.toString());
            templateReplacements.put("enrichment-steps-phase-title-" + phase, phaseDisplayName);
        }
        templateReplacements.put("enrichment-steps-active", inventoryEnrichersList.toString());


        final List<String> downloadTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("inventory-enrichment/template/inventory-enrichment-steps.md"), templateReplacements);
        DocumentationGenerator.assertTemplateFullyFilled("inventory-enrichment-steps.md", downloadTargetLines);

        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("inventory-enrichment/inventory-enrichment-steps.md"), downloadTargetLines);
    }

    private String generateInventoryEnricherDocumentation(JavaProjectBuilder project, JavaClass clazz, JavaClass directConfiguration, List<JavaClass> allConfigurationClasses) {
        final StringBuilder content = new StringBuilder();

        final String intermediateFileSuffix = getEnricherIntermediateFileSuffix(clazz);
        final String mavenPropertyName = getEnricherMavenPropertyName(clazz);

        content.append("## ").append(formatClassNameApplyDeprecated(clazz)).append("\n\n");
        content.append("`").append(intermediateFileSuffix).append("` / `").append(mavenPropertyName).append("`\n\n");

        content.append(MirrorDocumentationGenerator.generateDocRelevantMethodExpandables(project, clazz, "performEnrichment")).append("\n");

        if (clazz.getComment() != null && !clazz.getComment().isEmpty()) {
            content.append(clazz.getComment()).append("\n\n");
        }

        for (JavaClass configurationClass : allConfigurationClasses) {
            if (!configurationClass.getFields().isEmpty()) {
                final String configDisplayName = "Configuration: " + formatClassName(configurationClass).replace(" Configuration", "").replace(" Inventory", "");
                content.append("#### ").append(configDisplayName).append("\n\n");
                content.append(generateConfigurationDescription(configurationClass)).append("\n\n");
            }
        }

        return content.toString();
    }

    private String generateConfigurationDescription(JavaClass configurationClass) {
        final StringBuilder content = new StringBuilder();

        content.append("<table><tr><th>Parameter</th><th>Default</th></tr>");

        for (JavaField field : configurationClass.getFields()) {
            final String fieldName = field.getName();
            final String fieldDescription = field.getComment() != null ? field.getComment().replaceAll("(\r?\n)+", "<br>") : "";
            final String defaultValue = field.getInitializationExpression() != null ? field.getInitializationExpression().toString().replace("\n", "").replace("\r", "") : "";
            content.append("<tr><td><code>").append(fieldName).append("</code></td><td><code>").append(defaultValue).append("</code></td></tr>");
            if (!fieldDescription.isEmpty()) {
                content.append("<tr><td colspan=2>").append(unwrapJavaDocLink(fieldDescription)).append("</td></tr>");
            }
        }

        content.append("</table>");

        return content.toString();
    }

    private JavaClass findConfigurationClassForEnricher(JavaProjectBuilder project, JavaClass enrichmentClass) {
        final String explicitConfiguration = getEnricherExplicitConfiguration(enrichmentClass);

        if (explicitConfiguration != null) {
            return project.getClassByName(explicitConfiguration);
        }

        final JavaField configurationField = firstNonNull(
                enrichmentClass.getFieldByName("configuration"),
                enrichmentClass.getSuperJavaClass().getFieldByName("configuration")
        );

        if (configurationField == null) {
            throw new IllegalStateException("Configuration field not found for enricher: " + enrichmentClass.getName());
        }

        final String fullyQualifiedName = configurationField.getType().getFullyQualifiedName();
        return project.getClassByName(fullyQualifiedName);
    }

    private final static Set<String> UPPER_BOUND_CONFIGURATION_CLASSES = new HashSet<>(Arrays.asList("java.lang.Object", "org.metaeffekt.core.inventory.processor.configuration.ProcessConfiguration"));

    private List<JavaClass> configurationIncludingSuperclasses(JavaClass configurationClass) {
        final List<JavaClass> configurationClassesIncludingSuperclasses = new ArrayList<>();
        configurationClassesIncludingSuperclasses.add(configurationClass);

        JavaClass superClass = configurationClass.getSuperJavaClass();
        while (superClass != null) {
            // get until ProcessConfiguration is reached
            if (UPPER_BOUND_CONFIGURATION_CLASSES.contains(superClass.getFullyQualifiedName())) {
                break;
            }

            configurationClassesIncludingSuperclasses.add(superClass);
            superClass = superClass.getSuperJavaClass();
        }

        return configurationClassesIncludingSuperclasses;
    }

    private Map<String, List<JavaClass>> groupEnrichersByPhases(List<JavaClass> inventoryEnrichmentClasses) {
        // use the "phase" value of the EnricherMetadata annotation to group the enrichers
        final Map<String, List<JavaClass>> enrichersByPhase = new LinkedHashMap<>();

        for (InventoryEnrichmentPhase phase : InventoryEnrichmentPhase.values()) {
            enrichersByPhase.computeIfAbsent(phase.name(), k -> new ArrayList<>());
        }

        for (JavaClass clazz : inventoryEnrichmentClasses) {
            final String phase = getEnricherPhase(clazz);

            enrichersByPhase.computeIfAbsent(phase, k -> new ArrayList<>()).add(clazz);
        }

        return enrichersByPhase;
    }

    private static String getEnricherPhase(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "phase")
                .replace(InventoryEnrichmentPhase.class.getSimpleName() + ".", "");
    }

    public static String getEnricherName(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "name");
    }

    public static String getEnricherIntermediateFileSuffix(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "intermediateFileSuffix");
    }

    public static String getEnricherMavenPropertyName(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "mavenPropertyName");
    }

    public static String getEnricherExplicitConfiguration(JavaClass clazz) {
        return getAnnotationValue(getEnricherMetadataAnnotation(clazz), "explicitConfiguration");
    }

    private static JavaAnnotation getEnricherMetadataAnnotation(JavaClass clazz) {
        return clazz.getAnnotations().stream().filter(a -> a.getType().getValue().contains("EnricherMetadata")).findFirst().orElse(null);
    }

    private static String getAnnotationValue(JavaAnnotation annotation, String property) {
        if (annotation == null) {
            return null;
        }
        try {
            final AnnotationValue prop = annotation.getProperty(property);
            if (prop == null) {
                return null;
            }
            if (prop instanceof TypeRef) {
                return ((TypeRef) prop).getType().getFullyQualifiedName();
            }
            return prop.getParameterValue().toString().replace("\"", "");
        } catch (Exception e) {
            throw new IllegalStateException("Annotation property access failed: " + property, e);
        }
    }
}
