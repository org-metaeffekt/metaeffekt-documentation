package com.metaeffekt.documentation;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class TemplateProcessor {

    private static final String TEMPLATE_MARKER = ".template.";
    private static final Pattern PLACEHOLDER_PATTERN = Pattern.compile("\\$gen\\{([^}]+)}");

    private final TemplateRegistry registry;
    private final File rootDirectory;

    public TemplateProcessor(TemplateRegistry registry, DocumentationContext context) {
        this.registry = registry;
        this.rootDirectory = context.getDocumentationProjectPath();
    }

    public void processTemplates() {
        log.info("Starting template processing in: {}", rootDirectory);

        try {
            Files.walkFileTree(rootDirectory.toPath(), new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                    File f = file.toFile();
                    if (f.getName().contains(TEMPLATE_MARKER)) {
                        processSingleTemplate(f);
                    }
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            throw new RuntimeException("Failed to walk file tree for template processing", e);
        }
    }

    private void processSingleTemplate(File templateFile) {
        try {
            log.info("Processing template: {}", templateFile);

            // 1. Determine Output File Name
            // e.g., "download.template.md" -> "download.md"
            String outputFileName = templateFile.getName().replace(TEMPLATE_MARKER, ".");
            File outputFile = new File(templateFile.getParentFile(), outputFileName);

            // 2. Read Lines
            List<String> lines = FileUtils.readLines(templateFile, StandardCharsets.UTF_8);
            List<String> processedLines = new ArrayList<>(lines.size());

            // 3. Process Placeholders
            for (String line : lines) {
                processedLines.add(replacePlaceholders(line));
            }

            // 4. Verify no unresolved placeholders remain
            assertTemplateFullyFilled(templateFile.getName(), processedLines);

            // 5. Write Output
            FileUtils.writeLines(outputFile, StandardCharsets.UTF_8.name(), processedLines);
            log.info("Generated: {}", outputFile);

        } catch (Exception e) {
            throw new RuntimeException("Failed to process template [" + templateFile.getAbsolutePath() + "]", e);
        }
    }

    private String replacePlaceholders(String line) {
        if (!line.contains("$gen{")) {
            return line;
        }

        Matcher matcher = PLACEHOLDER_PATTERN.matcher(line);
        StringBuffer sb = new StringBuffer();

        while (matcher.find()) {
            String key = matcher.group(1);
            String value = registry.getValue(key);

            // Escape the replacement string to prevent regex errors if the value contains $ or \
            matcher.appendReplacement(sb, Matcher.quoteReplacement(value));
        }
        matcher.appendTail(sb);
        return sb.toString();
    }

    private void assertTemplateFullyFilled(String templateName, List<String> lines) {
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line.contains("$gen{")) {
                throw new IllegalStateException(
                        String.format("Template [%s] not fully filled on line %d. Remnant: %s", templateName, i + 1, line.trim())
                );
            }
        }
    }
}