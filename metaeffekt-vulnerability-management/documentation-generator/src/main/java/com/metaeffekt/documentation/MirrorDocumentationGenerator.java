package com.metaeffekt.documentation;

import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.*;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import javafx.util.Pair;
import org.apache.commons.io.FileUtils;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

public class MirrorDocumentationGenerator {

    public void generateDocumentation(JavaProjectBuilder project) throws IOException {
        final List<JavaClass> downloadClasses = excludeAllThatAreExtendedByOthers(orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.download.Download")));
        final List<JavaClass> indexClasses = excludeAllThatAreExtendedByOthers(orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.index.Index")));


        final Map<String, String> downloadReplacements = new HashMap<>();

        final StringJoiner downloadClassesListJoiner = new StringJoiner("\n- ", "- ", "");
        final StringJoiner downloadClassesDetailsJoiner = new StringJoiner("\n\n");
        for (JavaClass clazz : downloadClasses) {
            downloadClassesListJoiner.add("[" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
            downloadClassesDetailsJoiner.add(generateDownloadDocumentation(project, clazz));
        }
        downloadReplacements.put("download-list", downloadClassesListJoiner.toString());
        downloadReplacements.put("download-full-doc", downloadClassesDetailsJoiner.toString());


        final Map<String, String> indexReplacements = new HashMap<>();

        final StringJoiner indexClassesDetailsJoiner = new StringJoiner("\n\n");
        final StringJoiner indexClassesListJoiner = new StringJoiner("\n- ", "- ", "");
        for (JavaClass clazz : indexClasses) {
            indexClassesListJoiner.add("[" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
            indexClassesDetailsJoiner.add(generateIndexDocumentation(clazz));
        }
        indexReplacements.put("index-list", indexClassesListJoiner.toString());
        indexReplacements.put("index-full-doc", indexClassesDetailsJoiner.toString());


        final List<String> downloadTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/download-template.md"), downloadReplacements);
        final List<String> indexTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/index-template.md"), indexReplacements);

        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/download.md"), downloadTargetLines);
        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/index.md"), indexTargetLines);
    }

    private String generateDownloadDocumentation(JavaProjectBuilder project, JavaClass clazz) {
        final StringBuilder content = new StringBuilder();

        {
            final Pair<String, JavaMethod> performDownloadMethod = createSourceCodeExpandable(clazz, "performDownload");
            final StringJoiner inBetweenContent = new StringJoiner("\n");
            inBetweenContent.add(performDownloadMethod.getKey());

            final JavaAnnotation docRelevantMethods = performDownloadMethod.getValue().getAnnotations().stream()
                    .filter(a -> a.getType().getValue().equals("DocRelevantMethods"))
                    .findFirst()
                    .orElse(null);

            if (docRelevantMethods != null) {
                final Object value = docRelevantMethods.getProperty("value").getParameterValue();
                if (value instanceof List) {
                    for (String reference : (List<String>) value) {
                        // split method and class name, split by "."
                        final String[] parts = reference.replace("\"", "").split("#");
                        if (parts.length == 2) {
                            final String className = parts[0];
                            final String methodName = parts[1];
                            final JavaClass relevantClass = project.getClassByName(className);
                            if (relevantClass != null) {
                                final JavaMethod relevantMethod = relevantClass.getMethods().stream()
                                        .filter(m -> m.getName().equals(methodName))
                                        .findFirst().orElse(null);
                                if (relevantMethod != null) {
                                    inBetweenContent.add(createSourceCodeExpandable(relevantClass, methodName).getKey());
                                } else {
                                    System.err.println("Method " + methodName + " not found on " + className);
                                }
                            }
                        }
                    }
                }
            }

            content.append(generateGeneralMirrorHeaderDocumentation(clazz, inBetweenContent.toString()));
        }

        // search the class for a definition of an enum that implements ResourceLocation
        final JavaClass resourceLocationEnum = clazz.getNestedClasses().stream()
                .filter(c -> c.isEnum() && c.getName().contains("ResourceLocation"))
                .findFirst()
                .orElse(null);

        if (resourceLocationEnum != null) {
            content.append("| Resource Location | Description |\n")
                    .append("| --- | --- |\n");
            for (JavaField enumConstant : resourceLocationEnum.getEnumConstants()) {
                content.append("| `").append(enumConstant.getName()).append("` | <p>");
                content.append(enumConstant.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "")).append("</p>")
                        .append(enumConstant.getComment().replace("\r\n", " ").replace("\n", " ").replace("\r", " "))
                        .append(" |\n");
            }
        }

        return content.toString();
    }

    private Pair<String, JavaMethod> createSourceCodeExpandable(JavaClass clazz, String methodName) {
        final StringBuilder inBetweenContent = new StringBuilder();

        final JavaMethod baseClassMethod = clazz.getMethods().stream().filter(m -> m.getName().equals(methodName)).findFirst().orElse(null);
        final JavaMethod superClassMethod = clazz.getSuperJavaClass() != null ? clazz.getSuperJavaClass().getMethods().stream().filter(m -> m.getName().equals(methodName)).findFirst().orElse(null) : null;
        final JavaMethod method = firstNonNull(baseClassMethod, superClassMethod);

        if (method != null) {
            final String baseCodeBlock = unindentCodeBlock(method.getCodeBlock(), 4);
            final String onlyCodePart = unindentCodeBlock(retainMiddlePart(baseCodeBlock, ") {", "}"), 4);

            inBetweenContent.append("<details>\n\n<summary>Source Code for <code>")
                    .append(baseClassMethod == null ? clazz.getSuperJavaClass().getName() : clazz.getName())
                    .append(".").append(methodName).append("</code> </summary>\n\n```java\n")
                    .append(onlyCodePart)
                    .append("\n```\n\n</details>\n\n");
        }

        return new Pair<>(inBetweenContent.toString(), method);
    }

    private String generateIndexDocumentation(JavaClass clazz) {
        final StringBuilder content = new StringBuilder();

        final boolean isDeprecated = isDeprecated(clazz);
        content.append(generateGeneralMirrorHeaderDocumentation(clazz, createSourceCodeExpandable(clazz, "createIndexDocuments").getKey()));

        // relevant part in constructor: super(baseMirrorDirectory, GhsaAdvisorIndex.class, Collections.singletonList(GhsaDownload.class), Collections.emptyList());
        final JavaConstructor classConstructor = clazz.getConstructors().stream()
                .filter(c -> c.getParameters().size() == 1)
                .filter(c -> c.getParameters().get(0).getType().getValue().equals("File"))
                .findFirst().orElseThrow(() -> new RuntimeException("No constructor with one file parameter found on " + clazz.getName()));

        // now access the inside of the constructor, the super call
        String[] constructorParameters = classConstructor.getCodeBlock()
                .replace("\n", "").replace(" ", "")
                .replaceAll(".*super\\(([^;]+)\\);.*", "$1").split(",");

        // [baseMirrorDirectory, MsrcKbChainIndex.class, Collections.singletonList(MsrcSecurityGuideDownload.class), Arrays.asList(MsrcAdvisorIndex.class, MsrcProductIndex.class), Collections.singletonList(MsrcManualCsvDownload.class), Collections.emptyList()]
        // [baseMirrorDirectory, MsrcProductIndex.class, Collections.singletonList(MsrcDownload.class), Collections.emptyList()]
        // now skip the first two parameters and grab the rest, make sure to collect each parameter until the value ends in a ")"
        final List<List<String>> classDependencies = new ArrayList<>();
        List<String> currentClassDependency = new ArrayList<>();
        for (int i = 2, constructorParametersLength = constructorParameters.length; i < constructorParametersLength; i++) {
            final String parameter = constructorParameters[i];

            if (parameter.contains("()")) {
                classDependencies.add(currentClassDependency);
                currentClassDependency = new ArrayList<>();
                continue;
            }

            // extract the "*.class" part
            final String className = parameter.replaceAll(".*?([A-Za-z0-9]+\\.class).*", "$1");
            final String simpleClassName = className.substring(0, className.length() - ".class".length());

            currentClassDependency.add(simpleClassName);
            if (parameter.endsWith(")")) {
                classDependencies.add(currentClassDependency);
                currentClassDependency = new ArrayList<>();
            }
        }
        if (!currentClassDependency.isEmpty()) {
            classDependencies.add(currentClassDependency);
        }

        // [[MsrcSecurityGuideDownload], [MsrcAdvisorIndex, MsrcProductIndex], [MsrcManualCsvDownload], []]
        final List<String> dependencyTypes = Arrays.asList("Download", "Index", "Optional Download", "Optional Index");
        content.append("| Dependency Type | Depends on |\n")
                .append("| --- | --- |\n");
        for (int i = 0; i < classDependencies.size(); i++) {
            final List<String> dependencies = classDependencies.get(i);
            if (dependencies.isEmpty()) {
                continue;
            }

            final String type = dependencyTypes.get(i);
            content.append("| **").append(type).append("** | ");
            final StringJoiner classNameJoiner = new StringJoiner(", ");
            for (String dependency : dependencies) {
                final StringBuilder dependencyContent = new StringBuilder();
                if (isDeprecated) {
                    dependencyContent.append("_").append(formatClassName(dependency)).append("_");
                } else {
                    dependencyContent.append("[").append(formatClassName(dependency)).append("](");
                    if (type.toLowerCase().contains("download")) {
                        dependencyContent.append("download.md");
                    }
                    dependencyContent.append("#").append(toMarkdownId(formatClassName(dependency))).append(")");
                }
                classNameJoiner.add(dependencyContent.toString());
            }
            content.append(classNameJoiner).append(" |\n");
        }

        return content.toString();
    }

    private String generateGeneralMirrorHeaderDocumentation(JavaClass clazz, String inBetweenHeaderAndDocumentation) {
        final StringBuilder content = new StringBuilder();

        // search the cass for the @MirrorMetadata annotation
        final JavaAnnotation mirrorMetadata = clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("MirrorMetadata"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No @MirrorMetadata annotation found on " + clazz.getName()));
        final AnnotationValue directoryName = mirrorMetadata.getProperty("directoryName");
        final AnnotationValue mavenPropertyName = mirrorMetadata.getProperty("mavenPropertyName");

        content.append("## ").append(formatClassNameApplyDeprecated(clazz)).append("\n\n");
        content.append("`").append(directoryName.getParameterValue().toString().replace("\"", ""))
                .append("` / `").append(mavenPropertyName.getParameterValue().toString().replace("\"", ""))
                .append("`\n\n");

        if (inBetweenHeaderAndDocumentation != null && !inBetweenHeaderAndDocumentation.trim().isEmpty()) {
            content.append(inBetweenHeaderAndDocumentation);
        }

        if (clazz.getComment() != null && !clazz.getComment().isEmpty()) {
            content.append(clazz.getComment()).append("\n\n");
        }

        return content.toString();
    }

    private List<JavaClass> orderMirrorClasses(List<JavaClass> classes) {
        final List<String> downloadOrder = DocumentationProperties.loadResource("/mirror/download-order.txt");
        final List<String> indexOrder = DocumentationProperties.loadResource("/mirror/index-order.txt");

        final Map<String, JavaClass> classMap = new HashMap<>();
        for (JavaClass clazz : classes) {
            classMap.put(clazz.getName(), clazz);
        }

        final List<JavaClass> orderedClasses = new ArrayList<>();

        for (String className : downloadOrder) {
            if (classMap.containsKey(className)) {
                orderedClasses.add(classMap.get(className));
            }
        }
        for (String className : indexOrder) {
            if (classMap.containsKey(className)) {
                orderedClasses.add(classMap.get(className));
            }
        }

        for (JavaClass clazz : classes) {
            if (!orderedClasses.contains(clazz)) {
                orderedClasses.add(clazz);
            }
        }

        // now remove all deprecated and add them at the bottom in the order
        final List<JavaClass> deprecated = orderedClasses.stream().filter(this::isDeprecated).collect(Collectors.toList());
        orderedClasses.removeAll(deprecated);
        orderedClasses.addAll(deprecated);

        return orderedClasses;
    }

    private List<JavaClass> excludeAllThatAreExtendedByOthers(List<JavaClass> classes) {
        final Set<String> extendedClasses = new HashSet<>();
        for (JavaClass clazz : classes) {
            for (JavaClass other : classes) {
                if (other.getSuperJavaClass() != null && other.getSuperJavaClass().getName().equals(clazz.getName())) {
                    extendedClasses.add(clazz.getName());
                    System.out.println("Excluding " + clazz.getName() + " because it is extended by " + other.getName());
                }
            }
        }

        return classes.stream().filter(c -> !extendedClasses.contains(c.getName())).collect(Collectors.toList());
    }

    private boolean isDeprecated(JavaClass clazz) {
        return clazz.getAnnotations().stream().anyMatch(a -> a.getType().getValue().equals("Deprecated"));
    }

    private final static Set<String> FORMAT_CLASS_UPPERCASE_NAMES = new HashSet<>(Arrays.asList("msrc", "cert", "cve", "nist", "cwe", "cvss", "cpe", "cve", "nvd", "nist", "cwe", "cvss", "cpe", "csv", "api", "kb", "kev", "ghsa", "epss", "eol", "csaf", "cisa"));

    /**
     * Formats a mirror class name such that it is human-readable:
     * <p>
     * MsrcSecurityGuideDownload becomes "MSRC Security Guide"<br>
     * CertEuIndex becomes "CERT-EU Index"
     *
     * @param clazz The class to format
     * @return The formatted class name
     */
    private String formatClassName(String clazz) {
        final String[] parts = clazz.split("(?=[A-Z])");
        final StringJoiner joiner = new StringJoiner(" ");
        for (String part : parts) {
            if (part.equals("Download") || part.equals("Index")) {
                continue;
            }

            if (FORMAT_CLASS_UPPERCASE_NAMES.contains(part.toLowerCase())) {
                joiner.add(part.toUpperCase());
            } else {
                joiner.add(part.substring(0, 1).toUpperCase() + part.substring(1).toLowerCase());
            }
        }

        final String baseValue = joiner.toString();

        // CERT Eu --> CERT-EU and other CERTs
        final String[] certParts = baseValue.split(" ");
        if (certParts.length >= 2 && certParts[0].equalsIgnoreCase("cert")) {
            return "CERT-" + certParts[1].toUpperCase() + (certParts.length > 2 ? " " + certParts[2] : "");
        }

        return baseValue;
    }

    private String formatClassName(JavaClass clazz) {
        return formatClassName(clazz.getName());
    }

    private String formatClassNameApplyDeprecated(JavaClass clazz) {
        return isDeprecated(clazz) ? "_" + formatClassName(clazz) + " (deprecated)_" : formatClassName(clazz);
    }

    private String toMarkdownId(String name) {
        return name.toLowerCase().replace(" ", "-").replaceAll("[^a-z0-9-]", "");
    }

    private String unindentCodeBlock(String codeBlock, int indent) {
        final String[] lines = codeBlock.split("\n");

        // remove the smallest indentation from all lines
        final StringBuilder unindented = new StringBuilder();
        for (String line : lines) {
            final boolean shouldUnindent = line.length() >= indent && line.substring(0, indent).chars().allMatch(c -> c == ' ');
            if (shouldUnindent) {
                unindented.append(line.substring(indent)).append("\n");
            } else {
                unindented.append(line).append("\n");
            }
        }

        return trimNewlinesAndSpaces(unindented.toString());
    }

    private String trimNewlinesAndSpaces(String input) {
        return input.replaceAll("^\\s+", "").replaceAll("\\s+$", "");
    }

    private String retainMiddlePart(String input, String start, String end) {
        return input.substring(input.indexOf(start) + start.length(), input.lastIndexOf(end));
    }

    private static <T> T firstNonNull(T... values) {
        for (T value : values) {
            if (value != null) {
                return value;
            }
        }
        return null;
    }
}
