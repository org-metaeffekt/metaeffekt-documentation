package com.metaeffekt.documentation;

import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaConstructor;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import org.apache.commons.io.FileUtils;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

public class MirrorDocumentationGenerator {

    public void generateDocumentation(JavaProjectBuilder project) throws IOException {
        final List<JavaClass> downloadClasses = excludeAllThatAreExtendedByOthers(orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.download.Download")));
        final List<JavaClass> indexClasses = excludeAllThatAreExtendedByOthers(orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.index.Index")));


        final Map<String, String> downloadReplacements = new HashMap<>();

        final StringJoiner downloadClassesListJoiner = new StringJoiner("\n- ", "- ", "");
        final StringJoiner downloadClassesDetailsJoiner = new StringJoiner("\n\n");
        for (JavaClass clazz : downloadClasses) {
            downloadClassesListJoiner.add("[" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
            downloadClassesDetailsJoiner.add(generateDownloadDocumentation(clazz));
        }
        downloadReplacements.put("download-list", downloadClassesListJoiner.toString());
        downloadReplacements.put("download-full-doc", downloadClassesDetailsJoiner.toString());


        final Map<String, String> indexReplacements = new HashMap<>();

        final StringJoiner indexClassesDetailsJoiner = new StringJoiner("\n\n");
        final StringJoiner indexClassesListJoiner = new StringJoiner("\n- ", "- ", "");
        for (JavaClass clazz : indexClasses) {
            indexClassesListJoiner.add("[" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
            indexClassesDetailsJoiner.add(generateIndexDocumentation(clazz));
        }
        indexReplacements.put("index-list", indexClassesListJoiner.toString());
        indexReplacements.put("index-full-doc", indexClassesDetailsJoiner.toString());


        final List<String> downloadTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/download-template.md"), downloadReplacements);
        final List<String> indexTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/index-template.md"), indexReplacements);

        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/download.md"), downloadTargetLines);
        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/index.md"), indexTargetLines);
    }

    private String generateDownloadDocumentation(JavaClass clazz) {
        final StringBuilder content = new StringBuilder();

        content.append(generateGeneralMirrorHeaderDocumentation(clazz));

        // search the class for a definition of an enum that implements ResourceLocation
        final JavaClass resourceLocationEnum = clazz.getNestedClasses().stream()
                .filter(c -> c.isEnum() && c.getName().contains("ResourceLocation"))
                .findFirst()
                .orElse(null);

        if (resourceLocationEnum != null) {
            content.append("| Resource Location | Description |\n")
                    .append("| --- | --- |\n");
            for (JavaField enumConstant : resourceLocationEnum.getEnumConstants()) {
                content.append("| `").append(enumConstant.getName()).append("` | ");
                content.append(enumConstant.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "")).append("<p/>")
                        .append(enumConstant.getComment().replace("\n", " ")).append(" |\n");
            }
        }

        return content.toString();
    }

    private String generateIndexDocumentation(JavaClass clazz) {
        final StringBuilder content = new StringBuilder();

        content.append(generateGeneralMirrorHeaderDocumentation(clazz));

        /*
        find the constructor of the class:
public GhsaAdvisorIndex(File baseMirrorDirectory) {
    super(baseMirrorDirectory, GhsaAdvisorIndex.class, Collections.singletonList(GhsaDownload.class), Collections.emptyList());
}
        grab the classes mentioned in the last two parameters, they can both be lists
         */
        final JavaConstructor classConstructor = clazz.getConstructors().stream()
                .filter(c -> c.getParameters().size() == 1)
                .filter(c -> c.getParameters().get(0).getType().getValue().equals("File"))
                .findFirst().orElseThrow(() -> new RuntimeException("No constructor with one file parameter found on " + clazz.getName()));

        // now access the inside of the constructor, the super call
        String[] constructorParameters = classConstructor.getCodeBlock()
                .replace("\n", "").replace(" ", "")
                .replaceAll(".*super\\(([^;]+)\\);.*", "$1").split(",");

        // [baseMirrorDirectory, MsrcKbChainIndex.class, Collections.singletonList(MsrcSecurityGuideDownload.class), Arrays.asList(MsrcAdvisorIndex.class, MsrcProductIndex.class), Collections.singletonList(MsrcManualCsvDownload.class), Collections.emptyList()]
        // [baseMirrorDirectory, MsrcProductIndex.class, Collections.singletonList(MsrcDownload.class), Collections.emptyList()]
        // now skip the first two parameters and grab the rest, make sure to collect each parameter until the value ends in a ")"
        final List<List<String>> classDependencies = new ArrayList<>();
        List<String> currentClassDependency = new ArrayList<>();
        for (int i = 2, constructorParametersLength = constructorParameters.length; i < constructorParametersLength; i++) {
            final String parameter = constructorParameters[i];

            if (parameter.contains("()")) {
                classDependencies.add(currentClassDependency);
                currentClassDependency = new ArrayList<>();
                continue;
            }

            // extract the "*.class" part
            final String className = parameter.replaceAll(".*?([A-Za-z0-9]+\\.class).*", "$1");
            final String simpleClassName = className.substring(0, className.length() - ".class".length());

            currentClassDependency.add(simpleClassName);
            if (parameter.endsWith(")")) {
                classDependencies.add(currentClassDependency);
                currentClassDependency = new ArrayList<>();
            }
        }
        if (!currentClassDependency.isEmpty()) {
            classDependencies.add(currentClassDependency);
        }

        // [[MsrcSecurityGuideDownload], [MsrcAdvisorIndex, MsrcProductIndex], [MsrcManualCsvDownload], []]
        final List<String> dependencyTypes = Arrays.asList("Download", "Index", "Optional Download", "Optional Index");
        content.append("| Dependency Type | Depends on |\n")
                .append("| --- | --- |\n");
        for (int i = 0; i < classDependencies.size(); i++) {
            final List<String> dependencies = classDependencies.get(i);
            if (dependencies.isEmpty()) {
                continue;
            }

            final String type = dependencyTypes.get(i);
            content.append("| **").append(type).append("** | ");
            final StringJoiner classNameJoiner = new StringJoiner(", ");
            for (String dependency : dependencies) {
                final StringBuilder dependencyContent = new StringBuilder();
                dependencyContent.append("[").append(formatClassName(dependency)).append("](");
                if (type.toLowerCase().contains("download")) {
                    dependencyContent.append("download.md");
                }
                dependencyContent.append("#").append(toMarkdownId(formatClassName(dependency))).append(")");
                classNameJoiner.add(dependencyContent.toString());
            }
            content.append(classNameJoiner).append(" |\n");
        }

        return content.toString();
    }

    private String generateGeneralMirrorHeaderDocumentation(JavaClass clazz) {
        final StringBuilder content = new StringBuilder();

        // search the cass for the @MirrorMetadata annotation
        final JavaAnnotation mirrorMetadata = clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("MirrorMetadata"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No @MirrorMetadata annotation found on " + clazz.getName()));
        final AnnotationValue directoryName = mirrorMetadata.getProperty("directoryName");
        final AnnotationValue mavenPropertyName = mirrorMetadata.getProperty("mavenPropertyName");

        /*content.append("## ").append(formatClassNameApplyDeprecated(clazz))
                .append(" (`").append(directoryName.getParameterValue().toString().replace("\"", ""))
                .append("` / `").append(mavenPropertyName.getParameterValue().toString().replace("\"", ""))
                .append("`)\n\n");*/

        content.append("## ").append(formatClassNameApplyDeprecated(clazz)).append("\n\n");
        content.append("`").append(directoryName.getParameterValue().toString().replace("\"", ""))
                .append("` / `").append(mavenPropertyName.getParameterValue().toString().replace("\"", ""))
                .append("`\n\n");

        if (clazz.getComment() != null && !clazz.getComment().isEmpty()) {
            content.append(clazz.getComment()).append("\n");
        }

        return content.toString();
    }

    private List<JavaClass> orderMirrorClasses(List<JavaClass> classes) {
        final List<String> downloadOrder = DocumentationProperties.loadResource("/mirror/download-order.txt");
        final List<String> indexOrder = DocumentationProperties.loadResource("/mirror/index-order.txt");

        final Map<String, JavaClass> classMap = new HashMap<>();
        for (JavaClass clazz : classes) {
            classMap.put(clazz.getName(), clazz);
        }

        final List<JavaClass> orderedClasses = new ArrayList<>();

        for (String className : downloadOrder) {
            if (classMap.containsKey(className)) {
                orderedClasses.add(classMap.get(className));
            }
        }
        for (String className : indexOrder) {
            if (classMap.containsKey(className)) {
                orderedClasses.add(classMap.get(className));
            }
        }

        for (JavaClass clazz : classes) {
            if (!orderedClasses.contains(clazz)) {
                orderedClasses.add(clazz);
            }
        }

        // now remove all deprecated and add them at the bottom in the order
        final List<JavaClass> deprecated = orderedClasses.stream().filter(this::isDeprecated).collect(Collectors.toList());
        orderedClasses.removeAll(deprecated);
        orderedClasses.addAll(deprecated);

        return orderedClasses;
    }

    private List<JavaClass> excludeAllThatAreExtendedByOthers(List<JavaClass> classes) {
        final Set<String> extendedClasses = new HashSet<>();
        for (JavaClass clazz : classes) {
            for (JavaClass other : classes) {
                if (other.getSuperJavaClass() != null && other.getSuperJavaClass().getName().equals(clazz.getName())) {
                    extendedClasses.add(clazz.getName());
                    System.out.println("Excluding " + clazz.getName() + " because it is extended by " + other.getName());
                }
            }
        }

        return classes.stream().filter(c -> !extendedClasses.contains(c.getName())).collect(Collectors.toList());
    }

    private boolean isDeprecated(JavaClass clazz) {
        return clazz.getAnnotations().stream().anyMatch(a -> a.getType().getValue().equals("Deprecated"));
    }

    private final static Set<String> FORMAT_CLASS_UPPERCASE_NAMES = new HashSet<>(Arrays.asList("msrc", "cert", "cve", "nist", "cwe", "cvss", "cpe", "cve", "nvd", "nist", "cwe", "cvss", "cpe", "csv", "api", "kb", "kev", "ghsa", "epss", "eol", "csaf", "cisa"));

    /**
     * Formats a mirror class name such that it is human-readable:
     * <p>
     * MsrcSecurityGuideDownload becomes "MSRC Security Guide"<br>
     * CertEuIndex becomes "CERT-EU Index"
     *
     * @param clazz The class to format
     * @return The formatted class name
     */
    private String formatClassName(String clazz) {
        final String[] parts = clazz.split("(?=[A-Z])");
        final StringJoiner joiner = new StringJoiner(" ");
        for (String part : parts) {
            if (part.equals("Download") || part.equals("Index")) {
                continue;
            }

            if (FORMAT_CLASS_UPPERCASE_NAMES.contains(part.toLowerCase())) {
                joiner.add(part.toUpperCase());
            } else {
                joiner.add(part.substring(0, 1).toUpperCase() + part.substring(1).toLowerCase());
            }
        }

        final String baseValue = joiner.toString();

        // CERT Eu --> CERT-EU and other CERTs
        final String[] certParts = baseValue.split(" ");
        if (certParts.length >= 2 && certParts[0].equalsIgnoreCase("cert")) {
            return "CERT-" + certParts[1].toUpperCase() + (certParts.length > 2 ? " " + certParts[2] : "");
        }

        return baseValue;
    }

    private String formatClassName(JavaClass clazz) {
        return formatClassName(clazz.getName());
    }

    private String formatClassNameApplyDeprecated(JavaClass clazz) {
        return isDeprecated(clazz) ? "_" + formatClassName(clazz) + " (deprecated)_" : formatClassName(clazz);
    }

    private String toMarkdownId(String name) {
        return name.toLowerCase().replace(" ", "-").replaceAll("[^a-z0-9-]", "");
    }
}
