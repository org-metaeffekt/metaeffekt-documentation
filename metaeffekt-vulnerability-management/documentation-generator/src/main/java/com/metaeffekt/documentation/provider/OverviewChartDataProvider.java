package com.metaeffekt.documentation.provider;

import com.metaeffekt.artifact.enrichment.InventoryEnricher;
import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.documentation.domain.EnricherMetadata;
import com.metaeffekt.documentation.util.MirrorUtils;
import com.metaeffekt.mirror.download.Download;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.metaeffekt.mirror.index.Index;
import com.metaeffekt.mirror.query.IndexQuery;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.JavaType;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import com.thoughtworks.qdox.model.expression.TypeRef;
import com.thoughtworks.qdox.model.impl.DefaultJavaParameterizedType;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class OverviewChartDataProvider implements DocumentationDataProvider {

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        return new HashMap<String, Supplier<String>>() {{
            put("overview-chart-nodes", () -> {
                JSONArray[] data = generateGraphData(context);
                return data[0].toString().replace("\\/", "/");
            });
            put("overview-chart-edges", () -> {
                JSONArray[] data = generateGraphData(context);
                return data[1].toString().replace("\\/", "/");
            });
            put("overview-chart-png-save-scale", () -> "3");
            put("overview-chart-download-name", () -> "large-overview-diagram");
        }};
    }

    private JSONArray[] generateGraphData(DocumentationContext context) {
        // --- 1. Collect and Filter Classes ---

        List<JavaClass> inventoryEnrichmentClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderEnrichmentClasses(context,
                context.getType(InventoryEnricher.class).findSubtypes().stream().map(DocumentedType::getJavaClass).collect(Collectors.toList())));
        inventoryEnrichmentClasses.removeIf(c -> InventoryEnrichmentDataProvider.EXCLUDED_ENRICHERS.contains(c.getFullyQualifiedName()));

        Map<String, List<JavaClass>> enrichersByPhase = groupEnrichersByPhases(context, inventoryEnrichmentClasses);
        for (String phase : InventoryEnrichmentDataProvider.POM_EXCLUDED_PHASES) {
            inventoryEnrichmentClasses.removeAll(enrichersByPhase.get(phase));
        }
        enrichersByPhase.keySet().removeAll(InventoryEnrichmentDataProvider.POM_EXCLUDED_PHASES);

        List<JavaClass> downloadClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(Download.class).findSubtypes().stream().map(DocumentedType::getJavaClass).collect(Collectors.toList())));
        List<JavaClass> indexClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(Index.class).findSubtypes().stream().map(DocumentedType::getJavaClass).collect(Collectors.toList())));

        // Map dependencies
        Map<JavaClass, Map<String, List<JavaClass>>> indexClassDependencies = new LinkedHashMap<>();
        for (JavaClass indexClass : indexClasses) {
            indexClassDependencies.put(indexClass, MirrorUtils.getIndexDependencies(context, indexClass));
        }

        List<JavaClass> indexQueryClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(IndexQuery.class).findSubtypes().stream().map(DocumentedType::getJavaClass).collect(Collectors.toList())));
        Map<JavaClass, List<JavaClass>> indexQueryUsages = new LinkedHashMap<>();
        for (JavaClass enrichmentClass : inventoryEnrichmentClasses) {
            indexQueryUsages.put(enrichmentClass, getEnricherIndexQueryUsages(enrichmentClass, indexQueryClasses));
        }

        Map<JavaClass, Index> indexUsageInIndexQuery = new LinkedHashMap<>();
        for (JavaClass indexQuery : indexQueryClasses) {
            if (indexQuery.getFullyQualifiedName().contains("CustomVulnerabilityIndexQuery")) continue;

            try {
                Class<?> indexQueryClass = context.loadClass(indexQuery.getFullyQualifiedName());
                Object indexQueryInstance = indexQueryClass.getConstructor(File.class).newInstance(context.getMirrorPath());
                IndexQuery typedIndexQueryInstance = (IndexQuery) indexQueryInstance;
                indexUsageInIndexQuery.put(indexQuery, typedIndexQueryInstance.getIndex());
            } catch (Exception e) {
                log.error("Failed to create query instance for class {}", indexQuery.getName(), e);
            }
        }

        // --- 2. Build Nodes ---

        final JSONArray nodes = new JSONArray();
        final Set<String> validNodeIds = new HashSet<>();

        // Resolver Map: Base Class Name (Simple & FQN) -> Concrete Class ID (FQN)
        final Map<String, String> inheritanceResolver = new HashMap<>();

        // Groups
        addNode(nodes, validNodeIds, createGroup("downloadersGroup", "Downloaders"));
        addNode(nodes, validNodeIds, createGroup("indexesGroup", "Indexes"));
        addNode(nodes, validNodeIds, createGroup("indexQueriesGroup", "Index Queries"));
        addNode(nodes, validNodeIds, createGroup("enrichersGroup", "Enrichment Pipeline"));

        for (String phase : enrichersByPhase.keySet()) {
            JSONObject group = new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", "phaseGroup_" + phase)
                            .put("label", InventoryEnrichmentPhase.valueOf(phase).displayName())
                            .put("parent", "enrichersGroup"))
                    .put("classes", new JSONArray().put("graph-container").put("enricher-phase"));
            addNode(nodes, validNodeIds, group);
        }

        // Downloaders
        for (JavaClass downloader : downloadClasses) {
            final String id = downloader.getFullyQualifiedName();
            registerInheritance(inheritanceResolver, downloader, id);

            final JavaAnnotation metadata = getMirrorMetadata(downloader);
            final String directoryName = getAnnotationStringValue(metadata, "directoryName");
            final String mavenPropertyName = getAnnotationStringValue(metadata, "mavenPropertyName");
            final String displayName = formatClassName(downloader.getName());
            final JSONArray classes = new JSONArray().put("graph-node").put("downloader");
            if (isDeprecated(downloader)) classes.put("deprecated");

            JSONObject node = new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", id)
                            .put("label", "<b>" + displayName + "</b><br>" + directoryName + " / " + mavenPropertyName)
                            .put("parent", "downloadersGroup"))
                    .put("classes", classes);
            addNode(nodes, validNodeIds, node);
        }

        // Indexes
        for (JavaClass index : indexClasses) {
            final String id = index.getFullyQualifiedName();
            registerInheritance(inheritanceResolver, index, id);

            final JavaAnnotation metadata = getMirrorMetadata(index);
            final String directoryName = getAnnotationStringValue(metadata, "directoryName");
            final String mavenPropertyName = getAnnotationStringValue(metadata, "mavenPropertyName");
            final String displayName = formatClassName(index.getName());
            final JSONArray classes = new JSONArray().put("graph-node").put("index");
            if (isDeprecated(index)) classes.put("deprecated");

            JSONObject node = new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", id)
                            .put("label", "<b>" + displayName + "</b><br>" + directoryName + " / " + mavenPropertyName)
                            .put("parent", "indexesGroup"))
                    .put("classes", classes);
            addNode(nodes, validNodeIds, node);
        }

        // Index Queries
        for (JavaClass indexQuery : indexQueryClasses) {
            final String id = indexQuery.getFullyQualifiedName();
            registerInheritance(inheritanceResolver, indexQuery, id);

            final JSONArray classes = new JSONArray().put("graph-node").put("index-query");
            if (isDeprecated(indexQuery)) classes.put("deprecated");

            JSONObject node = new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", id)
                            .put("label", "<b>" + formatClassName(indexQuery) + "</b>")
                            .put("parent", "indexQueriesGroup"))
                    .put("classes", classes);
            addNode(nodes, validNodeIds, node);
        }

        // Enrichers
        for (Map.Entry<String, List<JavaClass>> entry : enrichersByPhase.entrySet()) {
            final String phaseGroupId = "phaseGroup_" + entry.getKey();
            for (JavaClass enricher : entry.getValue()) {
                final String id = enricher.getFullyQualifiedName();
                registerInheritance(inheritanceResolver, enricher, id);

                EnricherMetadata metadata = context.getType(enricher).as(EnricherMetadata.class);
                final String intermediateFileSuffix = metadata.getIntermediateFileSuffix();
                final String mavenPropertyName = metadata.getMavenPropertyName();

                JSONObject node = new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", id)
                                .put("label", "<b>" + formatClassName(enricher) + "</b><br>" + intermediateFileSuffix + " / " + mavenPropertyName)
                                .put("parent", phaseGroupId))
                        .put("classes", new JSONArray().put("graph-node").put("enricher"));
                addNode(nodes, validNodeIds, node);
            }
        }

        // --- 3. Build Edges (With Resolution) ---

        final JSONArray edges = new JSONArray();

        // Download -> Index AND Index -> Index
        for (JavaClass index : indexClasses) {
            final Map<String, List<JavaClass>> dependencies = indexClassDependencies.get(index);
            for (Map.Entry<String, List<JavaClass>> entry : dependencies.entrySet()) {
                final String dependencyType = entry.getKey();
                for (JavaClass dependentClass : entry.getValue()) {
                    // Try to resolve using FQN first, then Simple Name
                    String sourceKey = dependentClass.getFullyQualifiedName();
                    String resolvedSourceId = inheritanceResolver.getOrDefault(sourceKey, inheritanceResolver.get(dependentClass.getSimpleName()));
                    if (resolvedSourceId == null) resolvedSourceId = sourceKey;
                    safeAddEdge(edges, validNodeIds, resolvedSourceId, index.getFullyQualifiedName(), "Index -> " + dependencyType);
                }
            }
        }

        // IndexQuery -> Enricher
        for (Map.Entry<JavaClass, List<JavaClass>> entry : indexQueryUsages.entrySet()) {
            final String enricherId = entry.getKey().getFullyQualifiedName();
            for (JavaClass indexQuery : entry.getValue()) {
                String sourceId = indexQuery.getFullyQualifiedName();
                String resolvedSource = inheritanceResolver.getOrDefault(sourceId, sourceId);
                safeAddEdge(edges, validNodeIds, resolvedSource, enricherId, "IndexQuery -> Enricher");
            }
        }

        // Index -> IndexQuery
        for (Map.Entry<JavaClass, Index> entry : indexUsageInIndexQuery.entrySet()) {
            final String indexQueryId = entry.getKey().getFullyQualifiedName();
            final String indexId = entry.getValue().getClass().getName();
            String resolvedSource = inheritanceResolver.getOrDefault(indexId, inheritanceResolver.get(indexId.substring(indexId.lastIndexOf('.') + 1)));
            if (resolvedSource == null) resolvedSource = indexId;
            String resolvedTarget = inheritanceResolver.getOrDefault(indexQueryId, indexQueryId);
            safeAddEdge(edges, validNodeIds, resolvedSource, resolvedTarget, "Index -> IndexQuery");
        }

        return new JSONArray[]{nodes, edges};
    }

    private void registerInheritance(Map<String, String> map, JavaClass concreteClass, String concreteId) {
        // Map FQN -> Concrete
        map.put(concreteClass.getFullyQualifiedName(), concreteId);
        // Map Simple Name -> Concrete
        map.put(concreteClass.getSimpleName(), concreteId);

        // Map Hierarchy
        JavaClass superClass = concreteClass.getSuperJavaClass();
        while (superClass != null && !superClass.getFullyQualifiedName().equals("java.lang.Object")) {
            map.putIfAbsent(superClass.getFullyQualifiedName(), concreteId);
            map.putIfAbsent(superClass.getSimpleName(), concreteId);
            superClass = superClass.getSuperJavaClass();
        }
    }

    private void addNode(JSONArray nodes, Set<String> validIds, JSONObject node) {
        nodes.put(node);
        validIds.add(node.getJSONObject("data").getString("id"));
    }

    private JSONObject createGroup(String id, String label) {
        return new JSONObject()
                .put("data", new JSONObject().put("id", id).put("label", label))
                .put("classes", new JSONArray().put("graph-container"));
    }

    private void safeAddEdge(JSONArray edges, Set<String> validNodeIds, String source, String target, String label) {
        if (validNodeIds.contains(source) && validNodeIds.contains(target)) {
            JSONObject data = new JSONObject()
                    .put("source", source)
                    .put("target", target);
            if (label != null) {
                data.put("label", label);
            }
            edges.put(new JSONObject().put("data", data));
        } else {
            log.warn("Skipping edge creation: {} -> {} (One or both nodes missing)", source, target);
        }
    }

    private Map<String, List<JavaClass>> groupEnrichersByPhases(DocumentationContext context, List<JavaClass> inventoryEnrichmentClasses) {
        final Map<String, List<JavaClass>> enrichersByPhase = new LinkedHashMap<>();
        for (InventoryEnrichmentPhase phase : InventoryEnrichmentPhase.values()) {
            enrichersByPhase.computeIfAbsent(phase.name(), k -> new ArrayList<>());
        }
        for (JavaClass clazz : inventoryEnrichmentClasses) {
            final String phase = context.getType(clazz).as(EnricherMetadata.class).getPhase();
            if (phase != null && enrichersByPhase.containsKey(phase)) {
                enrichersByPhase.get(phase).add(clazz);
            }
        }
        return enrichersByPhase;
    }

    public List<JavaClass> getEnricherIndexQueryUsages(JavaClass enricherClass, List<JavaClass> indexQueryClasses) {
        final List<JavaClass> usages = new ArrayList<>();
        final Map<JavaClass, List<JavaField>> aggregatedFields = new LinkedHashMap<>();
        recursiveFindAllFields(enricherClass, aggregatedFields);

        for (Map.Entry<JavaClass, List<JavaField>> reference : aggregatedFields.entrySet()) {
            for (JavaField field : reference.getValue()) {
                for (JavaClass type : getAllTypes(field)) {
                    if (indexQueryClasses.contains(type)) {
                        usages.add(type);
                    }
                }
            }
        }
        return usages;
    }

    private void recursiveFindAllFields(JavaClass clazz, Map<JavaClass, List<JavaField>> aggregatedFields) {
        if (aggregatedFields.containsKey(clazz)) return;
        try {
            aggregatedFields.put(clazz, new ArrayList<>(clazz.getFields()));
        } catch (Exception e) {
            return;
        }
        if (clazz.getSuperJavaClass() != null) {
            recursiveFindAllFields(clazz.getSuperJavaClass(), aggregatedFields);
        }

        for (JavaField field : clazz.getFields()) {
            final JavaClass type = field.getType();
            recursiveFindAllFields(type, aggregatedFields);

            if (type instanceof DefaultJavaParameterizedType) {
                final DefaultJavaParameterizedType parameterizedType = (DefaultJavaParameterizedType) type;
                for (JavaType typeArgument : parameterizedType.getActualTypeArguments()) {
                    if (typeArgument instanceof JavaClass) {
                        recursiveFindAllFields((JavaClass) typeArgument, aggregatedFields);
                    }
                }
            }
        }
    }

    private List<JavaClass> getAllTypes(JavaField field) {
        final List<JavaClass> types = new ArrayList<>();
        types.add(field.getType());
        if (field.getType() instanceof DefaultJavaParameterizedType) {
            final DefaultJavaParameterizedType parameterizedType = (DefaultJavaParameterizedType) field.getType();
            for (JavaType typeArgument : parameterizedType.getActualTypeArguments()) {
                if (typeArgument instanceof JavaClass) {
                    types.add((JavaClass) typeArgument);
                }
            }
        }
        return types;
    }

    private JavaAnnotation getMirrorMetadata(JavaClass clazz) {
        return getMirrorMetadata(clazz, "MirrorMetadata");
    }

    private JavaAnnotation getMirrorMetadata(JavaClass clazz, String name) {
        return clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().contains(name))
                .findFirst().orElse(null);
    }

    private String getAnnotationStringValue(JavaAnnotation annotation, String property) {
        if (annotation == null) return null;
        AnnotationValue val = annotation.getProperty(property);
        if (val == null) return null;
        if (val instanceof TypeRef) return ((TypeRef) val).getType().getFullyQualifiedName();
        return val.getParameterValue().toString().replace("\"", "");
    }
}