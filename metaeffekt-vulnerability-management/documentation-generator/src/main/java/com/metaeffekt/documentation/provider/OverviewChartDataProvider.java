package com.metaeffekt.documentation.provider;

import com.metaeffekt.artifact.enrichment.InventoryEnricher;
import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.documentation.domain.EnricherMetadata;
import com.metaeffekt.documentation.domain.MirrorMetadata;
import com.metaeffekt.documentation.util.MirrorUtils;
import com.metaeffekt.mirror.download.Download;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.metaeffekt.mirror.index.Index;
import com.metaeffekt.mirror.query.CustomVulnerabilityIndexQuery;
import com.metaeffekt.mirror.query.IndexQuery;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.JavaType;
import com.thoughtworks.qdox.model.impl.DefaultJavaParameterizedType;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.excludeAllThatAreExtendedByOthers;
import static com.metaeffekt.documentation.util.MarkdownDocUtils.formatClassName;

@Slf4j
public class OverviewChartDataProvider implements DocumentationDataProvider {

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        return new HashMap<String, Supplier<String>>() {{
            put("overview-chart-nodes", () -> {
                JSONArray[] data = generateGraphData(context);
                return data[0].toString().replace("\\/", "/");
            });
            put("overview-chart-edges", () -> {
                JSONArray[] data = generateGraphData(context);
                return data[1].toString().replace("\\/", "/");
            });
            put("overview-chart-png-save-scale", () -> "3");
            put("overview-chart-download-name", () -> "large-overview-diagram");
        }};
    }

    private JSONArray[] generateGraphData(DocumentationContext context) {
        // --- 1. Collect and Filter Classes ---

        List<DocumentedType> inventoryEnrichmentClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderEnrichmentClasses(context,
                context.getType(InventoryEnricher.class).findSubtypes()));
        inventoryEnrichmentClasses.removeIf(c -> InventoryEnrichmentDataProvider.EXCLUDED_ENRICHERS.stream().anyMatch(c::isA));

        Map<String, List<DocumentedType>> enrichersByPhase = groupEnrichersByPhases(context, inventoryEnrichmentClasses);
        for (String phase : InventoryEnrichmentDataProvider.POM_EXCLUDED_PHASES) {
            inventoryEnrichmentClasses.removeAll(enrichersByPhase.get(phase));
        }
        enrichersByPhase.keySet().removeAll(InventoryEnrichmentDataProvider.POM_EXCLUDED_PHASES);

        List<DocumentedType> downloadClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(Download.class).findSubtypes()));
        List<DocumentedType> indexClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(Index.class).findSubtypes()));

        // Map dependencies
        Map<DocumentedType, Map<String, List<DocumentedType>>> indexClassDependencies = new LinkedHashMap<>();
        for (DocumentedType indexClass : indexClasses) {
            indexClassDependencies.put(indexClass, indexClass.as(MirrorMetadata.class).getIndexDependencies());
        }

        List<DocumentedType> indexQueryClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(IndexQuery.class).findSubtypes()));

        Map<DocumentedType, List<DocumentedType>> indexQueryUsages = new LinkedHashMap<>();
        for (DocumentedType enrichmentClass : inventoryEnrichmentClasses) {
            indexQueryUsages.put(enrichmentClass, getEnricherIndexQueryUsages(context, enrichmentClass, indexQueryClasses));
        }

        Map<DocumentedType, Index> indexUsageInIndexQuery = new LinkedHashMap<>();
        for (DocumentedType indexQuery : indexQueryClasses) {
            if (indexQuery.isA(CustomVulnerabilityIndexQuery.class)) continue;

            try {
                Class<?> indexQueryClass = indexQuery.getRuntimeClass().orElse(null);
                if (indexQueryClass != null) {
                    Object indexQueryInstance = indexQueryClass.getConstructor(File.class).newInstance(context.getMirrorPath());
                    IndexQuery typedIndexQueryInstance = (IndexQuery) indexQueryInstance;
                    indexUsageInIndexQuery.put(indexQuery, typedIndexQueryInstance.getIndex());
                }
            } catch (Exception e) {
                log.error("Failed to create query instance for class {}", indexQuery.getFullyQualifiedName(), e);
            }
        }

        // --- 2. Build Nodes ---

        final JSONArray nodes = new JSONArray();
        final Set<String> validNodeIds = new HashSet<>();

        // Resolver Map: Base Class Name (Simple & FQN) -> Concrete Class ID (FQN)
        final Map<String, String> inheritanceResolver = new HashMap<>();

        // Groups
        addNode(nodes, validNodeIds, createGroup("downloadersGroup", "Downloaders"));
        addNode(nodes, validNodeIds, createGroup("indexesGroup", "Indexes"));
        addNode(nodes, validNodeIds, createGroup("indexQueriesGroup", "Index Queries"));
        addNode(nodes, validNodeIds, createGroup("enrichersGroup", "Enrichment Pipeline"));

        for (String phase : enrichersByPhase.keySet()) {
            JSONObject group = new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", "phaseGroup_" + phase)
                            .put("label", InventoryEnrichmentPhase.valueOf(phase).displayName())
                            .put("parent", "enrichersGroup"))
                    .put("classes", new JSONArray().put("graph-container").put("enricher-phase"));
            addNode(nodes, validNodeIds, group);
        }

        // Downloaders
        for (DocumentedType downloader : downloadClasses) {
            final String id = downloader.getFullyQualifiedName();
            registerInheritance(inheritanceResolver, downloader, id);

            MirrorMetadata metadata = downloader.as(MirrorMetadata.class);
            final String directoryName = metadata.getDirectoryName();
            final String mavenPropertyName = metadata.getMavenPropertyName();
            final String displayName = formatClassName(downloader);
            final JSONArray classes = new JSONArray().put("graph-node").put("downloader");
            if (downloader.isDeprecated()) classes.put("deprecated");

            JSONObject node = new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", id)
                            .put("label", "<b>" + displayName + "</b><br>" + directoryName + " / " + mavenPropertyName)
                            .put("parent", "downloadersGroup"))
                    .put("classes", classes);
            addNode(nodes, validNodeIds, node);
        }

        // Indexes
        for (DocumentedType index : indexClasses) {
            final String id = index.getFullyQualifiedName();
            registerInheritance(inheritanceResolver, index, id);

            MirrorMetadata metadata = index.as(MirrorMetadata.class);
            final String directoryName = metadata.getDirectoryName();
            final String mavenPropertyName = metadata.getMavenPropertyName();
            final String displayName = formatClassName(index);
            final JSONArray classes = new JSONArray().put("graph-node").put("index");
            if (index.isDeprecated()) classes.put("deprecated");

            JSONObject node = new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", id)
                            .put("label", "<b>" + displayName + "</b><br>" + directoryName + " / " + mavenPropertyName)
                            .put("parent", "indexesGroup"))
                    .put("classes", classes);
            addNode(nodes, validNodeIds, node);
        }

        // Index Queries
        for (DocumentedType indexQuery : indexQueryClasses) {
            final String id = indexQuery.getFullyQualifiedName();
            registerInheritance(inheritanceResolver, indexQuery, id);

            final JSONArray classes = new JSONArray().put("graph-node").put("index-query");
            if (indexQuery.isDeprecated()) classes.put("deprecated");

            JSONObject node = new JSONObject()
                    .put("data", new JSONObject()
                            .put("id", id)
                            .put("label", "<b>" + formatClassName(indexQuery) + "</b>")
                            .put("parent", "indexQueriesGroup"))
                    .put("classes", classes);
            addNode(nodes, validNodeIds, node);
        }

        // Enrichers
        for (Map.Entry<String, List<DocumentedType>> entry : enrichersByPhase.entrySet()) {
            final String phaseGroupId = "phaseGroup_" + entry.getKey();
            for (DocumentedType enricher : entry.getValue()) {
                final String id = enricher.getFullyQualifiedName();
                registerInheritance(inheritanceResolver, enricher, id);

                EnricherMetadata metadata = enricher.as(EnricherMetadata.class);
                final String intermediateFileSuffix = metadata.getIntermediateFileSuffix();
                final String mavenPropertyName = metadata.getMavenPropertyName();

                JSONObject node = new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", id)
                                .put("label", "<b>" + formatClassName(enricher) + "</b><br>" + intermediateFileSuffix + " / " + mavenPropertyName)
                                .put("parent", phaseGroupId))
                        .put("classes", new JSONArray().put("graph-node").put("enricher"));
                addNode(nodes, validNodeIds, node);
            }
        }

        // --- 3. Build Edges (With Resolution) ---

        final JSONArray edges = new JSONArray();

        // Download -> Index AND Index -> Index
        for (DocumentedType index : indexClasses) {
            final Map<String, List<DocumentedType>> dependencies = indexClassDependencies.get(index);
            for (Map.Entry<String, List<DocumentedType>> entry : dependencies.entrySet()) {
                final String dependencyType = entry.getKey();
                for (DocumentedType dependentClass : entry.getValue()) {
                    String sourceKey = dependentClass.getFullyQualifiedName();
                    String resolvedSourceId = inheritanceResolver.getOrDefault(sourceKey, inheritanceResolver.get(dependentClass.getSimpleName()));
                    if (resolvedSourceId == null) resolvedSourceId = sourceKey;
                    safeAddEdge(edges, validNodeIds, resolvedSourceId, index.getFullyQualifiedName(), "Index -> " + dependencyType);
                }
            }
        }

        // IndexQuery -> Enricher
        for (Map.Entry<DocumentedType, List<DocumentedType>> entry : indexQueryUsages.entrySet()) {
            final String enricherId = entry.getKey().getFullyQualifiedName();
            for (DocumentedType indexQuery : entry.getValue()) {
                String sourceId = indexQuery.getFullyQualifiedName();
                String resolvedSource = inheritanceResolver.getOrDefault(sourceId, sourceId);
                safeAddEdge(edges, validNodeIds, resolvedSource, enricherId, "IndexQuery -> Enricher");
            }
        }

        // Index -> IndexQuery
        for (Map.Entry<DocumentedType, Index> entry : indexUsageInIndexQuery.entrySet()) {
            final String indexQueryId = entry.getKey().getFullyQualifiedName();
            final String indexId = entry.getValue().getClass().getName();
            String resolvedSource = inheritanceResolver.getOrDefault(indexId, inheritanceResolver.get(indexId.substring(indexId.lastIndexOf('.') + 1)));
            if (resolvedSource == null) resolvedSource = indexId;
            String resolvedTarget = inheritanceResolver.getOrDefault(indexQueryId, indexQueryId);
            safeAddEdge(edges, validNodeIds, resolvedSource, resolvedTarget, "Index -> IndexQuery");
        }

        return new JSONArray[]{nodes, edges};
    }

    private void registerInheritance(Map<String, String> map, DocumentedType concreteClass, String concreteId) {
        map.put(concreteClass.getFullyQualifiedName(), concreteId);
        map.put(concreteClass.getSimpleName(), concreteId);
        List<DocumentedType> hierarchy = concreteClass.getTypeHierarchy(Object.class);
        for (DocumentedType parent : hierarchy) {
            map.putIfAbsent(parent.getFullyQualifiedName(), concreteId);
            map.putIfAbsent(parent.getSimpleName(), concreteId);
        }
    }

    private void addNode(JSONArray nodes, Set<String> validIds, JSONObject node) {
        nodes.put(node);
        validIds.add(node.getJSONObject("data").getString("id"));
    }

    private JSONObject createGroup(String id, String label) {
        return new JSONObject()
                .put("data", new JSONObject().put("id", id).put("label", label))
                .put("classes", new JSONArray().put("graph-container"));
    }

    private void safeAddEdge(JSONArray edges, Set<String> validNodeIds, String source, String target, String label) {
        if (validNodeIds.contains(source) && validNodeIds.contains(target)) {
            JSONObject data = new JSONObject()
                    .put("source", source)
                    .put("target", target);
            if (label != null) {
                data.put("label", label);
            }
            edges.put(new JSONObject().put("data", data));
        } else {
            log.warn("Skipping edge creation: {} -> {} (One or both nodes missing)", source, target);
        }
    }

    private Map<String, List<DocumentedType>> groupEnrichersByPhases(DocumentationContext context, List<DocumentedType> classes) {
        Map<String, List<DocumentedType>> map = new LinkedHashMap<>();
        for (InventoryEnrichmentPhase phase : InventoryEnrichmentPhase.values()) map.put(phase.name(), new ArrayList<>());
        for (DocumentedType clazz : classes) {
            String p = clazz.as(EnricherMetadata.class).getPhase();
            if (p != null && map.containsKey(p)) map.get(p).add(clazz);
        }
        return map;
    }

    public List<DocumentedType> getEnricherIndexQueryUsages(DocumentationContext context, DocumentedType enricherClass, List<DocumentedType> indexQueryClasses) {
        final List<DocumentedType> usages = new ArrayList<>();
        final Map<String, DocumentedType> queryClassMap = indexQueryClasses.stream()
                .collect(Collectors.toMap(DocumentedType::getFullyQualifiedName, d -> d));

        // Deep traversal
        Map<String, List<JavaField>> aggregatedFields = new HashMap<>();
        recursiveFindAllFields(context, enricherClass, aggregatedFields);

        for (List<JavaField> fields : aggregatedFields.values()) {
            for (JavaField field : fields) {
                // Direct match
                String typeName = field.getType().getFullyQualifiedName();
                if (queryClassMap.containsKey(typeName)) {
                    usages.add(queryClassMap.get(typeName));
                }

                // Generic match (e.g. List<IndexQuery>)
                if (field.getType() instanceof DefaultJavaParameterizedType) {
                    DefaultJavaParameterizedType pType = (DefaultJavaParameterizedType) field.getType();
                    for (JavaType arg : pType.getActualTypeArguments()) {
                        if (queryClassMap.containsKey(arg.getFullyQualifiedName())) {
                            usages.add(queryClassMap.get(arg.getFullyQualifiedName()));
                        }
                    }
                }
            }
        }
        return usages;
    }

    private void recursiveFindAllFields(DocumentationContext context, DocumentedType type, Map<String, List<JavaField>> aggregatedFields) {
        if (type == null) return;
        if (aggregatedFields.containsKey(type.getFullyQualifiedName())) return;

        List<JavaField> fields = type.getFields(false);
        aggregatedFields.put(type.getFullyQualifiedName(), fields);

        // Inherited fields
        DocumentedType sup = type.getContext().getType(type.getJavaClass().getSuperJavaClass());
        if (sup != null && !sup.getFullyQualifiedName().equals("java.lang.Object")) {
            recursiveFindAllFields(context, sup, aggregatedFields);
        }

        // Composed fields (Recurse into types of fields)
        for (JavaField field : fields) {
            String fieldTypeName = field.getType().getFullyQualifiedName();
            if (!fieldTypeName.startsWith("java.") && !aggregatedFields.containsKey(fieldTypeName)) {
                DocumentedType fieldType = context.getType(fieldTypeName);
                if (fieldType != null) {
                    recursiveFindAllFields(context, fieldType, aggregatedFields);
                }
            }

            // Check generic args
            if (field.getType() instanceof DefaultJavaParameterizedType) {
                DefaultJavaParameterizedType pType = (DefaultJavaParameterizedType) field.getType();
                for (JavaType arg : pType.getActualTypeArguments()) {
                    String argName = arg.getFullyQualifiedName();
                    if (!argName.startsWith("java.") && !aggregatedFields.containsKey(argName)) {
                        DocumentedType argType = context.getType(argName);
                        if (argType != null) {
                            recursiveFindAllFields(context, argType, aggregatedFields);
                        }
                    }
                }
            }
        }
    }
}