package com.metaeffekt.documentation.util;

import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.mirror.Mirror;
import com.metaeffekt.mirror.MirrorRunner;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
public class MirrorUtils {

    public static List<DocumentedType> orderMirrorClasses(DocumentationContext context, List<DocumentedType> classes) {
        List<String> explicitOrder = DocumentationProperties.loadResource("/mirror/mirror-order.txt");
        return orderClasses(context, classes, explicitOrder, true);
    }

    public static List<DocumentedType> orderEnrichmentClasses(DocumentationContext context, List<DocumentedType> classes) {
        List<String> explicitOrder = DocumentationProperties.loadResource("/enrichment/enrichment-order.txt");
        return orderClasses(context, classes, explicitOrder, false);
    }

    public static List<DocumentedType> orderClasses(DocumentationContext context, List<DocumentedType> classes, List<String> order, boolean useRuntimeSort) {
        // 1. Explicit Order from file
        List<DocumentedType> explicitlyOrdered = new ArrayList<>();
        List<DocumentedType> remaining = new ArrayList<>(classes);

        for (String name : order) {
            DocumentedType match = remaining.stream()
                    .filter(c -> c.getFullyQualifiedName().equals(name) || c.getSimpleName().equals(name))
                    .findFirst().orElse(null);

            if (match != null) {
                explicitlyOrdered.add(match);
                remaining.remove(match);
            }
        }

        List<DocumentedType> runtimeSorted = new ArrayList<>();

        // 2. Runtime Topological Sort (Only for Mirror classes)
        if (useRuntimeSort) {
            List<Mirror> runtimeInstances = new ArrayList<>();
            Map<Class<?>, DocumentedType> classMap = new HashMap<>();

            for (DocumentedType dt : remaining) {
                try {
                    Class<?> clazz = dt.getRuntimeClass().orElse(null);
                    if (clazz != null && Mirror.class.isAssignableFrom(clazz)) {
                        Mirror mirror = instantiateMirror(clazz, null);
                        if (mirror != null) {
                            runtimeInstances.add(mirror);
                            classMap.put(clazz, dt);
                        }
                    }
                } catch (Exception e) {
                    log.debug("Skipping ordering instantiation for {}: {}", dt.getFullyQualifiedName(), e.getMessage());
                }
            }

            MirrorRunner runner = new MirrorRunner(null);
            List<Mirror> sorted = runner.resolveExecutionOrder(runtimeInstances);

            for (Mirror m : sorted) {
                runtimeSorted.add(classMap.get(m.getClass()));
            }
        }

        // 3. Combine
        List<DocumentedType> result = new ArrayList<>(explicitlyOrdered);

        // Add runtime sorted
        for (DocumentedType dt : runtimeSorted) {
            if (dt != null) { // Safety check
                result.add(dt);
                remaining.remove(dt);
            }
        }

        // Add whatever is left
        for (DocumentedType dt : remaining) {
            if (!result.contains(dt)) result.add(dt);
        }

        // 4. Move deprecated to bottom
        List<DocumentedType> deprecated = result.stream().filter(MarkdownDocUtils::isDeprecated).collect(Collectors.toList());
        result.removeAll(deprecated);
        result.addAll(deprecated);

        return result;
    }

    private static Mirror instantiateMirror(Class<?> clazz, File mirrorPath) throws Exception {
        try {
            if (clazz.getName().contains("CustomVulnerabilityIndexQuery")) return null;
            return (Mirror) clazz.getConstructor(File.class).newInstance(mirrorPath);
        } catch (NoSuchMethodException e) {
            return (Mirror) clazz.getConstructor().newInstance();
        }
    }
}