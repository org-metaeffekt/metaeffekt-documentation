package com.metaeffekt.documentation.util;

import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.mirror.Mirror;
import com.metaeffekt.mirror.MirrorRunner;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
public class MirrorUtils {

    public static List<JavaClass> orderMirrorClasses(DocumentationContext context, List<JavaClass> classes) {
        List<String> explicitOrder = DocumentationProperties.loadResource("/mirror/mirror-order.txt");
        return orderClasses(context, classes, explicitOrder, true);
    }

    public static List<JavaClass> orderEnrichmentClasses(DocumentationContext context, List<JavaClass> classes) {
        List<String> explicitOrder = DocumentationProperties.loadResource("/enrichment/enrichment-order.txt");
        // Enrichment classes don't use the MirrorRunner runtime topological sort, just the text file order + remainder
        return orderClasses(context, classes, explicitOrder, false);
    }

    public static List<JavaClass> orderClasses(DocumentationContext context, List<JavaClass> classes, List<String> order, boolean useRuntimeSort) {
        // 1. Explicit Order from file
        List<JavaClass> explicitlyOrdered = new ArrayList<>();
        List<JavaClass> remaining = new ArrayList<>(classes);

        for (String name : order) {
            JavaClass match = remaining.stream()
                    .filter(c -> c.getName().equals(name) || c.getSimpleName().equals(name))
                    .findFirst().orElse(null);

            if (match != null) {
                explicitlyOrdered.add(match);
                remaining.remove(match);
            }
        }

        List<JavaClass> runtimeSorted = new ArrayList<>();

        // 2. Runtime Topological Sort (Only for Mirror classes)
        if (useRuntimeSort) {
            List<Mirror> runtimeInstances = new ArrayList<>();
            Map<Class<?>, JavaClass> classMap = new HashMap<>();

            for (JavaClass jc : remaining) {
                try {
                    Class<?> clazz = context.loadClass(jc);
                    if (Mirror.class.isAssignableFrom(clazz)) {
                        Mirror mirror = instantiateMirror(clazz, null);
                        if (mirror != null) {
                            runtimeInstances.add(mirror);
                            classMap.put(clazz, jc);
                        }
                    }
                } catch (Exception e) {
                    log.debug("Skipping ordering instantiation for {}: {}", jc.getName(), e.getMessage());
                }
            }

            MirrorRunner runner = new MirrorRunner(null);
            List<Mirror> sorted = runner.resolveExecutionOrder(runtimeInstances);

            for (Mirror m : sorted) {
                runtimeSorted.add(classMap.get(m.getClass()));
            }
        }

        // 3. Combine
        List<JavaClass> result = new ArrayList<>(explicitlyOrdered);

        // Add runtime sorted
        for (JavaClass jc : runtimeSorted) {
            result.add(jc);
            remaining.remove(jc);
        }

        // Add whatever is left
        for (JavaClass jc : remaining) {
            if (!result.contains(jc)) result.add(jc);
        }

        // 4. Move deprecated to bottom
        List<JavaClass> deprecated = result.stream().filter(MarkdownDocUtils::isDeprecated).collect(Collectors.toList());
        result.removeAll(deprecated);
        result.addAll(deprecated);

        return result;
    }

    private static Mirror instantiateMirror(Class<?> clazz, File mirrorPath) throws Exception {
        try {
            if (clazz.getName().contains("CustomVulnerabilityIndexQuery")) return null;
            return (Mirror) clazz.getConstructor(File.class).newInstance(mirrorPath);
        } catch (NoSuchMethodException e) {
            return (Mirror) clazz.getConstructor().newInstance();
        }
    }

    public static Map<String, List<JavaClass>> getIndexDependencies(DocumentationContext context, JavaClass clazz) {
        Map<String, List<JavaClass>> map = new LinkedHashMap<>();
        JavaAnnotation ann = clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().endsWith("IndexDependencies")).findFirst().orElse(null);

        if (ann != null) {
            map.put("Download", resolveDeps(context, ann, "requiredDownloads"));
            map.put("Index", resolveDeps(context, ann, "requiredIndexes"));
            map.put("Optional Download", resolveDeps(context, ann, "optionalDownloads"));
            map.put("Optional Index", resolveDeps(context, ann, "optionalIndexes"));
        } else {
            map.put("Download", Collections.emptyList());
            map.put("Index", Collections.emptyList());
            map.put("Optional Download", Collections.emptyList());
            map.put("Optional Index", Collections.emptyList());
        }
        return map;
    }

    private static List<JavaClass> resolveDeps(DocumentationContext context, JavaAnnotation ann, String prop) {
        AnnotationValue val = ann.getProperty(prop);
        if (val == null) return Collections.emptyList();

        List<String> names = (val.getParameterValue() instanceof List) ?
                (List<String>) val.getParameterValue() :
                Collections.singletonList(val.getParameterValue().toString());

        return names.stream()
                .map(s -> s.replace(".class", "").replace("\"", "").trim())
                .filter(s -> !s.isEmpty())
                .map(context::getClassByName)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }
}