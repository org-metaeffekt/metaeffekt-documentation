package com.metaeffekt.documentation.provider;

import com.metaeffekt.artifact.enrichment.InventoryEnricher;
import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.domain.DocumentedType;
import com.metaeffekt.documentation.domain.EnricherMetadata;
import com.metaeffekt.documentation.domain.MirrorMetadata;
import com.metaeffekt.documentation.util.MirrorUtils;
import com.metaeffekt.mirror.download.Download;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.metaeffekt.mirror.index.Index;
import com.metaeffekt.mirror.query.IndexQuery;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.JavaType;
import com.thoughtworks.qdox.model.impl.DefaultJavaParameterizedType;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class IndividualIndexDiagramsDataProvider implements DocumentationDataProvider {

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        Map<String, Supplier<String>> variables = new HashMap<>();
        variables.put("index-diagrams", () -> generateDiagrams(context));
        return variables;
    }

    private String generateDiagrams(DocumentationContext context) {
        List<DocumentedType> inventoryEnrichmentClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderEnrichmentClasses(context,
                context.getType(InventoryEnricher.class).findSubtypes()));
        inventoryEnrichmentClasses.removeIf(c -> InventoryEnrichmentDataProvider.EXCLUDED_ENRICHERS.stream().anyMatch(c::isA));

        Map<String, List<DocumentedType>> enrichersByPhase = groupEnrichersByPhases(context, inventoryEnrichmentClasses);
        for (String phase : InventoryEnrichmentDataProvider.POM_EXCLUDED_PHASES) {
            inventoryEnrichmentClasses.removeAll(enrichersByPhase.get(phase));
        }
        enrichersByPhase.keySet().removeAll(InventoryEnrichmentDataProvider.POM_EXCLUDED_PHASES);

        List<DocumentedType> downloadClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(Download.class).findSubtypes()));
        List<DocumentedType> indexClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(Index.class).findSubtypes()));

        Map<DocumentedType, Map<String, List<DocumentedType>>> indexClassDependencies = new LinkedHashMap<>();
        for (DocumentedType indexClass : indexClasses) {
            indexClassDependencies.put(indexClass, indexClass.as(MirrorMetadata.class).getIndexDependencies());
        }

        List<DocumentedType> indexQueryClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context,
                context.getType(IndexQuery.class).findSubtypes()));

        Map<DocumentedType, List<DocumentedType>> indexQueryUsages = new LinkedHashMap<>();
        for (DocumentedType enrichmentClass : inventoryEnrichmentClasses) {
            indexQueryUsages.put(enrichmentClass, getEnricherIndexQueryUsages(context, enrichmentClass, indexQueryClasses));
        }

        Map<DocumentedType, Index> indexUsageInIndexQuery = new LinkedHashMap<>();
        for (DocumentedType indexQuery : indexQueryClasses) {
            if (indexQuery.getFullyQualifiedName().contains("CustomVulnerabilityIndexQuery")) continue;
            try {
                Class<?> indexQueryClass = indexQuery.getRuntimeClass().orElse(null);
                if (indexQueryClass != null) {
                    Object indexQueryInstance = indexQueryClass.getConstructor(File.class).newInstance(context.getMirrorPath());
                    IndexQuery typedIndexQueryInstance = (IndexQuery) indexQueryInstance;
                    indexUsageInIndexQuery.put(indexQuery, typedIndexQueryInstance.getIndex());
                }
            } catch (Exception e) {
                log.error("Failed to create query instance for class {}", indexQuery.getFullyQualifiedName(), e);
            }
        }

        // --- 2. Build Global Inheritance Resolver ---
        final Map<String, String> inheritanceResolver = new HashMap<>();

        for (DocumentedType c : downloadClasses) registerInheritance(inheritanceResolver, c, c.getFullyQualifiedName());
        for (DocumentedType c : indexClasses) registerInheritance(inheritanceResolver, c, c.getFullyQualifiedName());
        for (DocumentedType c : indexQueryClasses) registerInheritance(inheritanceResolver, c, c.getFullyQualifiedName());
        for (DocumentedType c : inventoryEnrichmentClasses) registerInheritance(inheritanceResolver, c, c.getFullyQualifiedName());

        StringJoiner diagramsList = new StringJoiner("\n\n");

        // --- 3. Iterate per Index to create Individual Diagrams ---

        for (DocumentedType generateDetailViewForIndexClass : indexClasses) {
            JSONArray nodes = new JSONArray();
            Set<String> validNodeIds = new HashSet<>();

            Map<String, List<DocumentedType>> indexClassDependenciesForIndex = indexClassDependencies.get(generateDetailViewForIndexClass);

            // Determine Subset of Indexes
            List<DocumentedType> indicesForIndex = new ArrayList<>();
            indicesForIndex.add(generateDetailViewForIndexClass);
            for (Map.Entry<String, List<DocumentedType>> entry : indexClassDependenciesForIndex.entrySet()) {
                for (DocumentedType dependentClass : entry.getValue()) {
                    String concreteId = inheritanceResolver.get(dependentClass.getFullyQualifiedName());
                    if (concreteId == null) concreteId = inheritanceResolver.get(dependentClass.getSimpleName());

                    if (concreteId != null) {
                        String finalConcreteId = concreteId;
                        indexClasses.stream().filter(c -> c.getFullyQualifiedName().equals(finalConcreteId)).forEach(indicesForIndex::add);
                    }
                }
            }

            // Recursive inclusion
            boolean added;
            do {
                added = false;
                for (DocumentedType index : indexClasses) {
                    Map<String, List<DocumentedType>> dependencies = indexClassDependencies.get(index);
                    for (Map.Entry<String, List<DocumentedType>> entry : dependencies.entrySet()) {
                        for (DocumentedType dependentClass : entry.getValue()) {
                            String concreteId = inheritanceResolver.getOrDefault(dependentClass.getFullyQualifiedName(), dependentClass.getFullyQualifiedName());
                            if (concreteId.equals(dependentClass.getFullyQualifiedName())) concreteId = inheritanceResolver.getOrDefault(dependentClass.getSimpleName(), concreteId);

                            if (concreteId.equals(generateDetailViewForIndexClass.getFullyQualifiedName())) {
                                String finalConcreteId = concreteId;
                                boolean dependencyIsAlreadyInList = indicesForIndex.stream().anyMatch(c -> c.getFullyQualifiedName().equals(finalConcreteId));

                                if (dependencyIsAlreadyInList && !indicesForIndex.contains(index)) {
                                    indicesForIndex.add(index);
                                    added = true;
                                }
                            }
                        }
                    }
                }
            } while (added);

            // Determine Subset of IndexQueries
            List<DocumentedType> indexQueryClassesForIndex = new ArrayList<>();
            for (Map.Entry<DocumentedType, Index> entry : indexUsageInIndexQuery.entrySet()) {
                if (entry.getValue().getClass().getName().equals(generateDetailViewForIndexClass.getFullyQualifiedName())) {
                    indexQueryClassesForIndex.add(entry.getKey());
                }
            }

            // Determine Subset of Downloaders
            List<DocumentedType> downloadersForIndex = new ArrayList<>();
            Runnable addDownloaders = () -> {
                for (Map.Entry<String, List<DocumentedType>> entry : indexClassDependenciesForIndex.entrySet()) {
                    for (DocumentedType dep : entry.getValue()) {
                        String concreteId = inheritanceResolver.getOrDefault(dep.getFullyQualifiedName(), inheritanceResolver.getOrDefault(dep.getSimpleName(), dep.getFullyQualifiedName()));
                        downloadClasses.stream().filter(d -> d.getFullyQualifiedName().equals(concreteId)).filter(d -> !downloadersForIndex.contains(d)).forEach(downloadersForIndex::add);
                    }
                }
                for (DocumentedType idx : indicesForIndex) {
                    Map<String, List<DocumentedType>> deps = indexClassDependencies.get(idx);
                    for (Map.Entry<String, List<DocumentedType>> entry : deps.entrySet()) {
                        for (DocumentedType dep : entry.getValue()) {
                            String concreteId = inheritanceResolver.getOrDefault(dep.getFullyQualifiedName(), inheritanceResolver.getOrDefault(dep.getSimpleName(), dep.getFullyQualifiedName()));
                            downloadClasses.stream().filter(d -> d.getFullyQualifiedName().equals(concreteId)).filter(d -> !downloadersForIndex.contains(d)).forEach(downloadersForIndex::add);
                        }
                    }
                }
            };
            addDownloaders.run();

            // Determine Subset of Enrichers
            List<DocumentedType> enrichersForIndex = new ArrayList<>();
            for (DocumentedType enricher : inventoryEnrichmentClasses) {
                if (indexQueryUsages.get(enricher).stream().anyMatch(indexQueryClassesForIndex::contains)) {
                    enrichersForIndex.add(enricher);
                }
            }

            // Determine Subset of Phases
            Set<String> phaseGroups = new LinkedHashSet<>();
            for (String phase : enrichersByPhase.keySet()) {
                if (enrichersByPhase.get(phase).stream().anyMatch(enrichersForIndex::contains)) {
                    phaseGroups.add(phase);
                }
            }

            // --- Generate Nodes ---

            if (!downloadersForIndex.isEmpty()) addNode(nodes, validNodeIds, createGroup("downloadersGroup", "Downloaders"));
            if (!indicesForIndex.isEmpty()) addNode(nodes, validNodeIds, createGroup("indexesGroup", "Indexes"));
            if (!indexQueryClassesForIndex.isEmpty()) addNode(nodes, validNodeIds, createGroup("indexQueriesGroup", "Index Queries"));
            if (!enrichersForIndex.isEmpty()) addNode(nodes, validNodeIds, createGroup("enrichersGroup", "Enrichment Pipeline"));

            for (String phase : enrichersByPhase.keySet()) {
                if (!phaseGroups.contains(phase)) continue;
                addNode(nodes, validNodeIds, new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", "phaseGroup_" + phase)
                                .put("label", InventoryEnrichmentPhase.valueOf(phase).displayName())
                                .put("parent", "enrichersGroup"))
                        .put("classes", new JSONArray().put("graph-container").put("enricher-phase")));
            }

            for (DocumentedType downloader : downloadClasses) {
                if (!downloadersForIndex.contains(downloader)) continue;
                MirrorMetadata metadata = downloader.as(MirrorMetadata.class);
                final JSONArray classes = new JSONArray().put("graph-node").put("downloader");
                if (downloader.isDeprecated()) classes.put("deprecated");
                addNode(nodes, validNodeIds, new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", downloader.getFullyQualifiedName())
                                .put("label", "<b>" + formatClassName(downloader) + "</b><br>" + metadata.getDirectoryName() + " / " + metadata.getMavenPropertyName())
                                .put("parent", "downloadersGroup"))
                        .put("classes", classes));
            }

            for (DocumentedType index : indexClasses) {
                if (!indicesForIndex.contains(index)) continue;
                MirrorMetadata metadata = index.as(MirrorMetadata.class);
                final JSONArray classes = new JSONArray().put("graph-node").put("index");
                if (index.isDeprecated()) classes.put("deprecated");
                addNode(nodes, validNodeIds, new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", index.getFullyQualifiedName())
                                .put("label", "<b>" + formatClassName(index) + "</b><br>" + metadata.getDirectoryName() + " / " + metadata.getMavenPropertyName())
                                .put("parent", "indexesGroup"))
                        .put("classes", classes));
            }

            for (DocumentedType indexQuery : indexQueryClasses) {
                if (!indexQueryClassesForIndex.contains(indexQuery)) continue;
                final JSONArray classes = new JSONArray().put("graph-node").put("index-query");
                if (indexQuery.isDeprecated()) classes.put("deprecated");
                addNode(nodes, validNodeIds, new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", indexQuery.getFullyQualifiedName())
                                .put("label", "<b>" + formatClassName(indexQuery) + "</b>")
                                .put("parent", "indexQueriesGroup"))
                        .put("classes", classes));
            }

            for (Map.Entry<String, List<DocumentedType>> entry : enrichersByPhase.entrySet()) {
                if (!phaseGroups.contains(entry.getKey())) continue;
                for (DocumentedType enricher : entry.getValue()) {
                    if (!enrichersForIndex.contains(enricher)) continue;
                    EnricherMetadata metadata = enricher.as(EnricherMetadata.class);

                    addNode(nodes, validNodeIds, new JSONObject()
                            .put("data", new JSONObject()
                                    .put("id", enricher.getFullyQualifiedName())
                                    .put("label", "<b>" + formatClassName(enricher) + "</b><br>" + metadata.getIntermediateFileSuffix() + " / " + metadata.getMavenPropertyName())
                                    .put("parent", "phaseGroup_" + entry.getKey()))
                            .put("classes", new JSONArray().put("graph-node").put("enricher")));
                }
            }

            // --- Generate Edges ---

            final JSONArray edges = new JSONArray();

            for (DocumentedType index : indexClasses) {
                if (!indicesForIndex.contains(index)) continue;

                final Map<String, List<DocumentedType>> dependencies = indexClassDependencies.get(index);
                for (Map.Entry<String, List<DocumentedType>> entry : dependencies.entrySet()) {
                    final String dependencyType = entry.getKey();
                    for (DocumentedType dependentClass : entry.getValue()) {
                        String sourceId = resolveId(inheritanceResolver, dependentClass);
                        safeAddEdge(edges, validNodeIds, sourceId, index.getFullyQualifiedName(), "Index -> " + dependencyType);
                    }
                }
            }

            for (Map.Entry<DocumentedType, List<DocumentedType>> entry : indexQueryUsages.entrySet()) {
                if (!enrichersForIndex.contains(entry.getKey())) continue;
                final String enricherId = entry.getKey().getFullyQualifiedName();
                for (DocumentedType indexQuery : entry.getValue()) {
                    if (!indexQueryClassesForIndex.contains(indexQuery)) continue;

                    String sourceId = resolveId(inheritanceResolver, indexQuery);
                    safeAddEdge(edges, validNodeIds, sourceId, enricherId, "IndexQuery -> Enricher");
                }
            }

            for (Map.Entry<DocumentedType, Index> entry : indexUsageInIndexQuery.entrySet()) {
                if (!indexQueryClassesForIndex.contains(entry.getKey())) continue;
                final String indexQueryId = entry.getKey().getFullyQualifiedName();
                final String indexId = entry.getValue().getClass().getName();

                String sourceId = resolveId(inheritanceResolver, indexId);
                String targetId = resolveId(inheritanceResolver, indexQueryId);

                safeAddEdge(edges, validNodeIds, sourceId, targetId, "Index -> IndexQuery");
            }

            // --- Side Effect ---
            try {
                File templateFile = new File(context.getDocumentationProjectPath(), "metaeffekt-vulnerability-management/large-overview-diagram.template.html");
                if (templateFile.exists()) {
                    String content = FileUtils.readFileToString(templateFile, StandardCharsets.UTF_8);
                    content = content.replace("$gen{overview-chart-nodes}", nodes.toString().replace("\\/", "/"));
                    content = content.replace("$gen{overview-chart-edges}", edges.toString().replace("\\/", "/"));
                    content = content.replace("$gen{overview-chart-png-save-scale}", "2");
                    content = content.replace("$gen{overview-chart-download-name}", "individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getSimpleName());

                    File outFile = new File(context.getDocumentationProjectPath(), "metaeffekt-vulnerability-management/diagrams/individual-detail-overview-diagram-html/individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getSimpleName() + ".html");
                    FileUtils.writeStringToFile(outFile, content, StandardCharsets.UTF_8);
                }
            } catch (Exception e) {
                log.error("Failed to generate individual diagram side-effect file for {}", generateDetailViewForIndexClass.getSimpleName(), e);
            }

            diagramsList.add("### " + formatClassName(generateDetailViewForIndexClass));
            diagramsList.add("![" + generateDetailViewForIndexClass.getSimpleName() + "](individual-detail-overview-diagram-rendered/individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getSimpleName() + ".png)");
        }

        return diagramsList.toString();
    }

    private void registerInheritance(Map<String, String> map, DocumentedType concreteClass, String concreteId) {
        map.put(concreteClass.getFullyQualifiedName(), concreteId);
        map.put(concreteClass.getSimpleName(), concreteId);
        List<DocumentedType> hierarchy = concreteClass.getTypeHierarchy(Object.class);
        for (DocumentedType parent : hierarchy) {
            map.putIfAbsent(parent.getFullyQualifiedName(), concreteId);
            map.putIfAbsent(parent.getSimpleName(), concreteId);
        }
    }

    private String resolveId(Map<String, String> resolver, DocumentedType clazz) {
        return resolveId(resolver, clazz.getFullyQualifiedName());
    }

    private String resolveId(Map<String, String> resolver, String key) {
        String resolved = resolver.get(key);
        if (resolved == null && key.contains(".")) {
            String simple = key.substring(key.lastIndexOf('.') + 1);
            resolved = resolver.get(simple);
        }
        return resolved != null ? resolved : key;
    }

    private void addNode(JSONArray nodes, Set<String> validIds, JSONObject node) {
        nodes.put(node);
        validIds.add(node.getJSONObject("data").getString("id"));
    }

    private JSONObject createGroup(String id, String label) {
        return new JSONObject()
                .put("data", new JSONObject().put("id", id).put("label", label))
                .put("classes", new JSONArray().put("graph-container"));
    }

    private void safeAddEdge(JSONArray edges, Set<String> validNodeIds, String source, String target, String label) {
        if (validNodeIds.contains(source) && validNodeIds.contains(target)) {
            JSONObject data = new JSONObject()
                    .put("source", source)
                    .put("target", target);
            if (label != null) {
                data.put("label", label);
            }
            edges.put(new JSONObject().put("data", data));
        } else {
            log.debug("Skipping edge creation: {} -> {} (Nodes not in this individual diagram)", source, target);
        }
    }

    private Map<String, List<DocumentedType>> groupEnrichersByPhases(DocumentationContext context, List<DocumentedType> classes) {
        Map<String, List<DocumentedType>> map = new LinkedHashMap<>();
        for (InventoryEnrichmentPhase phase : InventoryEnrichmentPhase.values()) map.put(phase.name(), new ArrayList<>());
        for (DocumentedType clazz : classes) {
            String p = clazz.as(EnricherMetadata.class).getPhase();
            if (p != null && map.containsKey(p)) map.get(p).add(clazz);
        }
        return map;
    }

    public List<DocumentedType> getEnricherIndexQueryUsages(DocumentationContext context, DocumentedType enricherClass, List<DocumentedType> indexQueryClasses) {
        final List<DocumentedType> usages = new ArrayList<>();
        final Map<String, DocumentedType> queryClassMap = indexQueryClasses.stream()
                .collect(Collectors.toMap(DocumentedType::getFullyQualifiedName, d -> d));

        Map<String, List<JavaField>> aggregatedFields = new HashMap<>();
        recursiveFindAllFields(context, enricherClass, aggregatedFields);

        for (List<JavaField> fields : aggregatedFields.values()) {
            for (JavaField field : fields) {
                String typeName = field.getType().getFullyQualifiedName();
                if (queryClassMap.containsKey(typeName)) {
                    usages.add(queryClassMap.get(typeName));
                }

                if (field.getType() instanceof DefaultJavaParameterizedType) {
                    DefaultJavaParameterizedType pType = (DefaultJavaParameterizedType) field.getType();
                    for (JavaType arg : pType.getActualTypeArguments()) {
                        if (queryClassMap.containsKey(arg.getFullyQualifiedName())) {
                            usages.add(queryClassMap.get(arg.getFullyQualifiedName()));
                        }
                    }
                }
            }
        }
        return usages;
    }

    private void recursiveFindAllFields(DocumentationContext context, DocumentedType type, Map<String, List<JavaField>> aggregatedFields) {
        if (type == null) return;
        if (aggregatedFields.containsKey(type.getFullyQualifiedName())) return;

        List<JavaField> fields = type.getFields(false);
        aggregatedFields.put(type.getFullyQualifiedName(), fields);

        DocumentedType sup = type.getContext().getType(type.getJavaClass().getSuperJavaClass());
        if (sup != null && !sup.getFullyQualifiedName().equals("java.lang.Object")) {
            recursiveFindAllFields(context, sup, aggregatedFields);
        }

        for (JavaField field : fields) {
            String fieldTypeName = field.getType().getFullyQualifiedName();
            if (!fieldTypeName.startsWith("java.") && !aggregatedFields.containsKey(fieldTypeName)) {
                DocumentedType fieldType = context.getType(fieldTypeName);
                if (fieldType != null) {
                    recursiveFindAllFields(context, fieldType, aggregatedFields);
                }
            }

            if (field.getType() instanceof DefaultJavaParameterizedType) {
                DefaultJavaParameterizedType pType = (DefaultJavaParameterizedType) field.getType();
                for (JavaType arg : pType.getActualTypeArguments()) {
                    String argName = arg.getFullyQualifiedName();
                    if (!argName.startsWith("java.") && !aggregatedFields.containsKey(argName)) {
                        DocumentedType argType = context.getType(argName);
                        if (argType != null) {
                            recursiveFindAllFields(context, argType, aggregatedFields);
                        }
                    }
                }
            }
        }
    }
}