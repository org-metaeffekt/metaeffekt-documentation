package com.metaeffekt.documentation.provider;

import com.metaeffekt.documentation.DocumentationContext;
import com.metaeffekt.documentation.DocumentationDataProvider;
import com.metaeffekt.documentation.util.MirrorUtils;
import com.metaeffekt.mirror.download.documentation.InventoryEnrichmentPhase;
import com.metaeffekt.mirror.index.Index;
import com.metaeffekt.mirror.query.IndexQuery;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.JavaType;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import com.thoughtworks.qdox.model.expression.TypeRef;
import com.thoughtworks.qdox.model.impl.DefaultJavaParameterizedType;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.function.Supplier;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class IndividualIndexDiagramsDataProvider implements DocumentationDataProvider {

    @Override
    public Map<String, Supplier<String>> getTemplateVariables(DocumentationContext context) {
        Map<String, Supplier<String>> variables = new HashMap<>();
        variables.put("index-diagrams", () -> generateDiagrams(context));
        return variables;
    }

    private String generateDiagrams(DocumentationContext context) {
        // --- 1. Collect and Filter Classes (Identical Setup to OverviewChart) ---

        List<JavaClass> inventoryEnrichmentClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderEnrichmentClasses(context, context.findClassesExtending("com.metaeffekt.artifact.enrichment.InventoryEnricher")));
        inventoryEnrichmentClasses.removeIf(c -> InventoryEnrichmentDataProvider.EXCLUDED_ENRICHERS.contains(c.getFullyQualifiedName()));
        Map<String, List<JavaClass>> enrichersByPhase = groupEnrichersByPhases(inventoryEnrichmentClasses);
        for (String phase : InventoryEnrichmentDataProvider.POM_EXCLUDED_PHASES) {
            inventoryEnrichmentClasses.removeAll(enrichersByPhase.get(phase));
        }
        enrichersByPhase.keySet().removeAll(InventoryEnrichmentDataProvider.POM_EXCLUDED_PHASES);

        List<JavaClass> downloadClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context, context.findClassesExtending("com.metaeffekt.mirror.download.Download")));
        List<JavaClass> indexClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context, context.findClassesExtending("com.metaeffekt.mirror.index.Index")));

        Map<JavaClass, Map<String, List<JavaClass>>> indexClassDependencies = new LinkedHashMap<>();
        for (JavaClass indexClass : indexClasses) {
            indexClassDependencies.put(indexClass, MirrorUtils.getIndexDependencies(context, indexClass));
        }

        List<JavaClass> indexQueryClasses = excludeAllThatAreExtendedByOthers(MirrorUtils.orderMirrorClasses(context, context.findClassesExtending("com.metaeffekt.mirror.query.IndexQuery")));
        Map<JavaClass, List<JavaClass>> indexQueryUsages = new LinkedHashMap<>();
        for (JavaClass enrichmentClass : inventoryEnrichmentClasses) {
            indexQueryUsages.put(enrichmentClass, getEnricherIndexQueryUsages(enrichmentClass, indexQueryClasses));
        }

        Map<JavaClass, Index> indexUsageInIndexQuery = new LinkedHashMap<>();
        for (JavaClass indexQuery : indexQueryClasses) {
            if (indexQuery.getFullyQualifiedName().contains("CustomVulnerabilityIndexQuery")) continue;
            try {
                Class<?> indexQueryClass = context.loadClass(indexQuery.getFullyQualifiedName());
                Object indexQueryInstance = indexQueryClass.getConstructor(File.class).newInstance(context.getMirrorPath());
                IndexQuery typedIndexQueryInstance = (IndexQuery) indexQueryInstance;
                indexUsageInIndexQuery.put(indexQuery, typedIndexQueryInstance.getIndex());
            } catch (Exception e) {
                log.error("Failed to create query instance for class {}", indexQuery.getName(), e);
            }
        }

        // --- 2. Build Global Inheritance Resolver ---
        // We map Base Classes (FQN & SimpleName) -> Concrete Implementation ID
        final Map<String, String> inheritanceResolver = new HashMap<>();

        for (JavaClass c : downloadClasses) registerInheritance(inheritanceResolver, c, c.getFullyQualifiedName());
        for (JavaClass c : indexClasses) registerInheritance(inheritanceResolver, c, c.getFullyQualifiedName());
        for (JavaClass c : indexQueryClasses) registerInheritance(inheritanceResolver, c, c.getFullyQualifiedName());
        for (JavaClass c : inventoryEnrichmentClasses) registerInheritance(inheritanceResolver, c, c.getFullyQualifiedName());

        StringJoiner diagramsList = new StringJoiner("\n\n");

        // --- 3. Iterate per Index to create Individual Diagrams ---

        for (JavaClass generateDetailViewForIndexClass : indexClasses) {
            JSONArray nodes = new JSONArray();
            Set<String> validNodeIds = new HashSet<>(); // To ensure we only link to nodes in this specific subset graph

            Map<String, List<JavaClass>> indexClassDependenciesForIndex = indexClassDependencies.get(generateDetailViewForIndexClass);

            // Determine Subset of Indexes
            List<JavaClass> indicesForIndex = new ArrayList<>();
            indicesForIndex.add(generateDetailViewForIndexClass);
            for (Map.Entry<String, List<JavaClass>> entry : indexClassDependenciesForIndex.entrySet()) {
                for (JavaClass dependentClass : entry.getValue()) {
                    // Check via Resolver: does the dependency map to a known index class?
                    String concreteId = inheritanceResolver.get(dependentClass.getFullyQualifiedName());
                    if (concreteId == null) concreteId = inheritanceResolver.get(dependentClass.getSimpleName());

                    if (concreteId != null) {
                        String finalConcreteId = concreteId;
                        indexClasses.stream().filter(c -> c.getFullyQualifiedName().equals(finalConcreteId)).forEach(indicesForIndex::add);
                    }
                }
            }

            // Recursive inclusion of indexes referenced by other indexes
            boolean added;
            do {
                added = false;
                for (JavaClass index : indexClasses) {
                    Map<String, List<JavaClass>> dependencies = indexClassDependencies.get(index);
                    for (Map.Entry<String, List<JavaClass>> entry : dependencies.entrySet()) {
                        for (JavaClass dependentClass : entry.getValue()) {
                            // Resolve dependency
                            String concreteId = inheritanceResolver.getOrDefault(dependentClass.getFullyQualifiedName(), dependentClass.getFullyQualifiedName());
                            if (concreteId.equals(dependentClass.getFullyQualifiedName())) concreteId = inheritanceResolver.getOrDefault(dependentClass.getSimpleName(), concreteId);

                            if (concreteId.equals(generateDetailViewForIndexClass.getFullyQualifiedName())) {
                                // Ignore self references or upstream checks if that was the intent,
                                // essentially we want to know if 'index' depends on something in 'indicesForIndex', or vice versa?
                                // The original logic: if (indicesForIndex.contains(dependentClass) && !indicesForIndex.contains(index))

                                // We check if the RESOLVED class is in our list
                                String finalConcreteId = concreteId;
                                boolean dependencyIsAlreadyInList = indicesForIndex.stream().anyMatch(c -> c.getFullyQualifiedName().equals(finalConcreteId));

                                if (dependencyIsAlreadyInList && !indicesForIndex.contains(index)) {
                                    indicesForIndex.add(index);
                                    added = true;
                                }
                            }
                        }
                    }
                }
            } while (added);

            // Determine Subset of IndexQueries
            List<JavaClass> indexQueryClassesForIndex = new ArrayList<>();
            for (Map.Entry<JavaClass, Index> entry : indexUsageInIndexQuery.entrySet()) {
                if (entry.getValue().getClass().getName().equals(generateDetailViewForIndexClass.getFullyQualifiedName())) {
                    indexQueryClassesForIndex.add(entry.getKey());
                }
            }

            // Determine Subset of Downloaders
            List<JavaClass> downloadersForIndex = new ArrayList<>();
            // Helper to add resolved downloaders
            Runnable addDownloaders = () -> {
                // Scan direct dependencies
                for (Map.Entry<String, List<JavaClass>> entry : indexClassDependenciesForIndex.entrySet()) {
                    for (JavaClass dep : entry.getValue()) {
                        String concreteId = inheritanceResolver.getOrDefault(dep.getFullyQualifiedName(), inheritanceResolver.getOrDefault(dep.getSimpleName(), dep.getFullyQualifiedName()));
                        downloadClasses.stream().filter(d -> d.getFullyQualifiedName().equals(concreteId)).filter(d -> !downloadersForIndex.contains(d)).forEach(downloadersForIndex::add);
                    }
                }
                // Scan recursive index dependencies
                for (JavaClass idx : indicesForIndex) {
                    Map<String, List<JavaClass>> deps = indexClassDependencies.get(idx);
                    for (Map.Entry<String, List<JavaClass>> entry : deps.entrySet()) {
                        for (JavaClass dep : entry.getValue()) {
                            String concreteId = inheritanceResolver.getOrDefault(dep.getFullyQualifiedName(), inheritanceResolver.getOrDefault(dep.getSimpleName(), dep.getFullyQualifiedName()));
                            downloadClasses.stream().filter(d -> d.getFullyQualifiedName().equals(concreteId)).filter(d -> !downloadersForIndex.contains(d)).forEach(downloadersForIndex::add);
                        }
                    }
                }
            };
            addDownloaders.run();

            // Determine Subset of Enrichers
            List<JavaClass> enrichersForIndex = new ArrayList<>();
            for (JavaClass enricher : inventoryEnrichmentClasses) {
                if (indexQueryUsages.get(enricher).stream().anyMatch(indexQueryClassesForIndex::contains)) {
                    enrichersForIndex.add(enricher);
                }
            }

            // Determine Subset of Phases
            Set<String> phaseGroups = new LinkedHashSet<>();
            for (String phase : enrichersByPhase.keySet()) {
                if (enrichersByPhase.get(phase).stream().anyMatch(enrichersForIndex::contains)) {
                    phaseGroups.add(phase);
                }
            }

            // --- Generate Nodes (Groups & Items) ---

            if (!downloadersForIndex.isEmpty()) addNode(nodes, validNodeIds, createGroup("downloadersGroup", "Downloaders"));
            if (!indicesForIndex.isEmpty()) addNode(nodes, validNodeIds, createGroup("indexesGroup", "Indexes"));
            if (!indexQueryClassesForIndex.isEmpty()) addNode(nodes, validNodeIds, createGroup("indexQueriesGroup", "Index Queries"));
            if (!enrichersForIndex.isEmpty()) addNode(nodes, validNodeIds, createGroup("enrichersGroup", "Enrichment Pipeline"));

            for (String phase : enrichersByPhase.keySet()) {
                if (!phaseGroups.contains(phase)) continue;
                addNode(nodes, validNodeIds, new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", "phaseGroup_" + phase)
                                .put("label", InventoryEnrichmentPhase.valueOf(phase).displayName())
                                .put("parent", "enrichersGroup"))
                        .put("classes", new JSONArray().put("graph-container").put("enricher-phase")));
            }

            for (JavaClass downloader : downloadClasses) {
                if (!downloadersForIndex.contains(downloader)) continue;
                final JavaAnnotation metadata = getMirrorMetadata(downloader);
                final JSONArray classes = new JSONArray().put("graph-node").put("downloader");
                if (isDeprecated(downloader)) classes.put("deprecated");
                addNode(nodes, validNodeIds, new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", downloader.getFullyQualifiedName())
                                .put("label", "<b>" + formatClassName(downloader.getName()) + "</b><br>" + getAnnotationStringValue(metadata, "directoryName") + " / " + getAnnotationStringValue(metadata, "mavenPropertyName"))
                                .put("parent", "downloadersGroup"))
                        .put("classes", classes));
            }

            for (JavaClass index : indexClasses) {
                if (!indicesForIndex.contains(index)) continue;
                final JavaAnnotation metadata = getMirrorMetadata(index);
                final JSONArray classes = new JSONArray().put("graph-node").put("index");
                if (isDeprecated(index)) classes.put("deprecated");
                addNode(nodes, validNodeIds, new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", index.getFullyQualifiedName())
                                .put("label", "<b>" + formatClassName(index.getName()) + "</b><br>" + getAnnotationStringValue(metadata, "directoryName") + " / " + getAnnotationStringValue(metadata, "mavenPropertyName"))
                                .put("parent", "indexesGroup"))
                        .put("classes", classes));
            }

            for (JavaClass indexQuery : indexQueryClasses) {
                if (!indexQueryClassesForIndex.contains(indexQuery)) continue;
                final JSONArray classes = new JSONArray().put("graph-node").put("index-query");
                if (isDeprecated(indexQuery)) classes.put("deprecated");
                addNode(nodes, validNodeIds, new JSONObject()
                        .put("data", new JSONObject()
                                .put("id", indexQuery.getFullyQualifiedName())
                                .put("label", "<b>" + formatClassName(indexQuery) + "</b>")
                                .put("parent", "indexQueriesGroup"))
                        .put("classes", classes));
            }

            for (Map.Entry<String, List<JavaClass>> entry : enrichersByPhase.entrySet()) {
                if (!phaseGroups.contains(entry.getKey())) continue;
                for (JavaClass enricher : entry.getValue()) {
                    if (!enrichersForIndex.contains(enricher)) continue;
                    addNode(nodes, validNodeIds, new JSONObject()
                            .put("data", new JSONObject()
                                    .put("id", enricher.getFullyQualifiedName())
                                    .put("label", "<b>" + formatClassName(enricher) + "</b><br>" + getEnricherIntermediateFileSuffix(enricher) + " / " + getEnricherMavenPropertyName(enricher))
                                    .put("parent", "phaseGroup_" + entry.getKey()))
                            .put("classes", new JSONArray().put("graph-node").put("enricher")));
                }
            }

            // --- Generate Edges (With Resolution & Safe Add) ---

            final JSONArray edges = new JSONArray();

            // Download -> Index (for subset)
            for (JavaClass index : indexClasses) {
                if (!indicesForIndex.contains(index)) continue;

                final Map<String, List<JavaClass>> dependencies = indexClassDependencies.get(index);
                for (Map.Entry<String, List<JavaClass>> entry : dependencies.entrySet()) {
                    final String dependencyType = entry.getKey();
                    for (JavaClass dependentClass : entry.getValue()) {
                        // Resolve
                        String sourceId = resolveId(inheritanceResolver, dependentClass);
                        safeAddEdge(edges, validNodeIds, sourceId, index.getFullyQualifiedName(), dependencyType);
                    }
                }
            }

            // IndexQuery -> Enricher (for subset)
            for (Map.Entry<JavaClass, List<JavaClass>> entry : indexQueryUsages.entrySet()) {
                if (!enrichersForIndex.contains(entry.getKey())) continue;
                final String enricherId = entry.getKey().getFullyQualifiedName();
                for (JavaClass indexQuery : entry.getValue()) {
                    if (!indexQueryClassesForIndex.contains(indexQuery)) continue;

                    String sourceId = resolveId(inheritanceResolver, indexQuery);
                    safeAddEdge(edges, validNodeIds, sourceId, enricherId, null);
                }
            }

            // Index -> IndexQuery (for subset)
            for (Map.Entry<JavaClass, Index> entry : indexUsageInIndexQuery.entrySet()) {
                if (!indexQueryClassesForIndex.contains(entry.getKey())) continue;
                final String indexQueryId = entry.getKey().getFullyQualifiedName();
                final String indexId = entry.getValue().getClass().getName();

                String sourceId = resolveId(inheritanceResolver, indexId);
                String targetId = resolveId(inheritanceResolver, indexQueryId);

                safeAddEdge(edges, validNodeIds, sourceId, targetId, null);
            }

            // --- Side Effect: Write File ---
            try {
                File templateFile = new File(context.getDocumentationProjectPath(), "metaeffekt-vulnerability-management/large-overview-diagram.template.html");
                if (templateFile.exists()) {
                    String content = FileUtils.readFileToString(templateFile, StandardCharsets.UTF_8);
                    content = content.replace("$gen{overview-chart-nodes}", nodes.toString().replace("\\/", "/"));
                    content = content.replace("$gen{overview-chart-edges}", edges.toString().replace("\\/", "/"));
                    content = content.replace("$gen{overview-chart-png-save-scale}", "2");
                    content = content.replace("$gen{overview-chart-download-name}", "individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getName());

                    File outFile = new File(context.getDocumentationProjectPath(), "metaeffekt-vulnerability-management/diagrams/individual-detail-overview-diagram-html/individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getName() + ".html");
                    FileUtils.writeStringToFile(outFile, content, StandardCharsets.UTF_8);
                }
            } catch (Exception e) {
                log.error("Failed to generate individual diagram side-effect file for " + generateDetailViewForIndexClass.getName(), e);
            }

            diagramsList.add("### " + formatClassName(generateDetailViewForIndexClass));
            diagramsList.add("![" + generateDetailViewForIndexClass.getName() + "](individual-detail-overview-diagram-rendered/individual-detail-overview-diagram-" + generateDetailViewForIndexClass.getName() + ".png)");
        }

        return diagramsList.toString();
    }

    // --- Helpers ---

    private void registerInheritance(Map<String, String> map, JavaClass concreteClass, String concreteId) {
        map.put(concreteClass.getFullyQualifiedName(), concreteId);
        map.put(concreteClass.getSimpleName(), concreteId);
        JavaClass superClass = concreteClass.getSuperJavaClass();
        while (superClass != null && !superClass.getFullyQualifiedName().equals("java.lang.Object")) {
            map.putIfAbsent(superClass.getFullyQualifiedName(), concreteId);
            map.putIfAbsent(superClass.getSimpleName(), concreteId);
            superClass = superClass.getSuperJavaClass();
        }
    }

    private String resolveId(Map<String, String> resolver, JavaClass clazz) {
        return resolveId(resolver, clazz.getFullyQualifiedName());
    }

    private String resolveId(Map<String, String> resolver, String key) {
        String resolved = resolver.get(key);
        if (resolved == null && key.contains(".")) {
            // try simple name fallback
            String simple = key.substring(key.lastIndexOf('.') + 1);
            resolved = resolver.get(simple);
        }
        return resolved != null ? resolved : key;
    }

    private void addNode(JSONArray nodes, Set<String> validIds, JSONObject node) {
        nodes.put(node);
        validIds.add(node.getJSONObject("data").getString("id"));
    }

    private JSONObject createGroup(String id, String label) {
        return new JSONObject()
                .put("data", new JSONObject().put("id", id).put("label", label))
                .put("classes", new JSONArray().put("graph-container"));
    }

    private void safeAddEdge(JSONArray edges, Set<String> validNodeIds, String source, String target, String label) {
        if (validNodeIds.contains(source) && validNodeIds.contains(target)) {
            JSONObject data = new JSONObject()
                    .put("source", source)
                    .put("target", target);
            if (label != null) {
                data.put("label", label);
            }
            edges.put(new JSONObject().put("data", data));
        } else {
            // Log at DEBUG to avoid spamming console for individual diagrams where exclusion is expected
            log.debug("Skipping edge creation: {} -> {} (Nodes not in this individual diagram)", source, target);
        }
    }

    private Map<String, List<JavaClass>> groupEnrichersByPhases(List<JavaClass> classes) {
        Map<String, List<JavaClass>> map = new LinkedHashMap<>();
        for (InventoryEnrichmentPhase phase : InventoryEnrichmentPhase.values()) map.put(phase.name(), new ArrayList<>());
        for (JavaClass clazz : classes) {
            String p = getEnricherPhase(clazz);
            if (p != null && map.containsKey(p)) map.get(p).add(clazz);
        }
        return map;
    }

    private String getEnricherPhase(JavaClass clazz) {
        AnnotationValue v = clazz.getAnnotations().stream().filter(a -> a.getType().getValue().contains("EnricherMetadata")).findFirst().map(a->a.getProperty("phase")).orElse(null);
        return v != null ? v.getParameterValue().toString().replace("\"", "").replace(InventoryEnrichmentPhase.class.getSimpleName() + ".", "") : null;
    }

    private String getEnricherIntermediateFileSuffix(JavaClass clazz) {
        return getAnnotationStringValue(getMirrorMetadata(clazz, "EnricherMetadata"), "intermediateFileSuffix");
    }

    private String getEnricherMavenPropertyName(JavaClass clazz) {
        return getAnnotationStringValue(getMirrorMetadata(clazz, "EnricherMetadata"), "mavenPropertyName");
    }

    private List<JavaClass> getEnricherIndexQueryUsages(JavaClass enricherClass, List<JavaClass> indexQueryClasses) {
        final List<JavaClass> usages = new ArrayList<>();
        final Map<JavaClass, List<JavaField>> aggregatedFields = new LinkedHashMap<>();
        recursiveFindAllFields(enricherClass, aggregatedFields);

        for (Map.Entry<JavaClass, List<JavaField>> reference : aggregatedFields.entrySet()) {
            for (JavaField field : reference.getValue()) {
                for (JavaClass type : getAllTypes(field)) {
                    if (indexQueryClasses.contains(type)) {
                        usages.add(type);
                    }
                }
            }
        }
        return usages;
    }

    private void recursiveFindAllFields(JavaClass clazz, Map<JavaClass, List<JavaField>> aggregatedFields) {
        if (aggregatedFields.containsKey(clazz)) return;
        try {
            aggregatedFields.put(clazz, new ArrayList<>(clazz.getFields()));
        } catch (Exception e) { return; }

        if (clazz.getSuperJavaClass() != null) {
            recursiveFindAllFields(clazz.getSuperJavaClass(), aggregatedFields);
        }

        for (JavaField field : clazz.getFields()) {
            final JavaClass type = field.getType();
            recursiveFindAllFields(type, aggregatedFields);

            if (type instanceof DefaultJavaParameterizedType) {
                final DefaultJavaParameterizedType parameterizedType = (DefaultJavaParameterizedType) type;
                for (JavaType typeArgument : parameterizedType.getActualTypeArguments()) {
                    if (typeArgument instanceof JavaClass) {
                        recursiveFindAllFields((JavaClass) typeArgument, aggregatedFields);
                    }
                }
            }
        }
    }

    private List<JavaClass> getAllTypes(JavaField field) {
        final List<JavaClass> types = new ArrayList<>();
        types.add(field.getType());
        if (field.getType() instanceof DefaultJavaParameterizedType) {
            final DefaultJavaParameterizedType parameterizedType = (DefaultJavaParameterizedType) field.getType();
            for (JavaType typeArgument : parameterizedType.getActualTypeArguments()) {
                if (typeArgument instanceof JavaClass) {
                    types.add((JavaClass) typeArgument);
                }
            }
        }
        return types;
    }

    private JavaAnnotation getMirrorMetadata(JavaClass clazz) {
        return getMirrorMetadata(clazz, "MirrorMetadata");
    }

    private JavaAnnotation getMirrorMetadata(JavaClass clazz, String name) {
        return clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().contains(name))
                .findFirst().orElse(null);
    }

    private String getAnnotationStringValue(JavaAnnotation annotation, String property) {
        if (annotation == null) return null;
        AnnotationValue val = annotation.getProperty(property);
        if (val == null) return null;
        if (val instanceof TypeRef) return ((TypeRef) val).getType().getFullyQualifiedName();
        return val.getParameterValue().toString().replace("\"", "");
    }
}