package com.metaeffekt.documentation.generator;

import com.metaeffekt.documentation.DocumentationGenerator;
import com.metaeffekt.documentation.IDocumentationGenerator;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.metaeffekt.documentation.util.MarkdownDocUtils;
import com.metaeffekt.mirror.Mirror;
import com.metaeffekt.mirror.MirrorRunner;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.*;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.*;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

@Slf4j
public class MirrorDocumentationGenerator implements IDocumentationGenerator {

    private static final Set<String> IGNORED_INITIALIZER_CLASSES = new HashSet<>(Arrays.asList(
            "com.metaeffekt.mirror.initializer.MirrorInitializer",
            "com.metaeffekt.mirror.initializer.DownloadInitializer",
            "com.metaeffekt.mirror.initializer.IndexInitializer",
            "MirrorInitializer",
            "DownloadInitializer",
            "IndexInitializer",
            "java.lang.Object"
    ));

    private static class MirrorContext {
        final JavaClass mirrorClass;
        final JavaClass initializerClass;
        final String mavenPropertyName;
        final boolean isDeprecated;

        public MirrorContext(JavaClass mirrorClass, JavaClass initializerClass, String mavenPropertyName) {
            this.mirrorClass = mirrorClass;
            this.initializerClass = initializerClass;
            this.mavenPropertyName = mavenPropertyName;
            this.isDeprecated = isDeprecated(mirrorClass);
        }
    }

    private static class SectionResult {
        final StringJoiner listActive = new StringJoiner("\n- ", "- ", "");
        final StringJoiner listDeprecated = new StringJoiner("\n- ", "- ", "");
        final StringJoiner details = new StringJoiner("\n\n");
        String pomComplete = "";
        String pomShort = "";
    }

    @Override
    public void generateDocumentation(JavaProjectBuilder project) throws IOException {
        final List<JavaClass> rawDownloads = excludeAllThatAreExtendedByOthers(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.download.Download"));
        final List<JavaClass> rawIndexes = excludeAllThatAreExtendedByOthers(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.index.Index"));

        // Combine and sort
        final List<JavaClass> allToOrder = new ArrayList<>(rawDownloads);
        allToOrder.addAll(rawIndexes);
        final List<JavaClass> sortedAll = orderMirrorClasses(allToOrder);

        // Analyze DataMirrorMojo
        final JavaClass mojoClass = project.getClassByName("com.metaeffekt.mirror.plugin.DataMirrorMojo");
        final Map<String, JavaClass> mojoInitializerMap = mapMojoInitializers(mojoClass);

        // Classify Contexts
        final List<MirrorContext> downloadContexts = new ArrayList<>();
        final List<MirrorContext> indexContexts = new ArrayList<>();

        for (JavaClass clazz : sortedAll) {
            final boolean isDownload = rawDownloads.contains(clazz);
            final boolean isIndex = rawIndexes.contains(clazz);

            if (!isDownload && !isIndex) continue;

            final JavaAnnotation metadata = getMirrorMetadata(clazz);
            final String propertyName = metadata.getProperty("mavenPropertyName").getParameterValue().toString().replace("\"", "");
            final JavaClass initializerClass = mojoInitializerMap.get(propertyName);

            final MirrorContext context = new MirrorContext(clazz, initializerClass, propertyName);

            if (isDownload) {
                downloadContexts.add(context);
            } else {
                indexContexts.add(context);
            }
        }

        // Process Sections
        final SectionResult downloadsResult = processSection(project, downloadContexts, true);
        final SectionResult indexesResult = processSection(project, indexContexts, false);

        // Fill Template
        final Map<String, String> templateReplacements = new HashMap<>();

        templateReplacements.put("download-list-active", downloadsResult.listActive.toString());
        templateReplacements.put("download-list-deprecated", downloadsResult.listDeprecated.toString());
        templateReplacements.put("download-full-doc", downloadsResult.details.toString());
        templateReplacements.put("download-pom-complete-configuration", indent(downloadsResult.pomComplete, 20));
        templateReplacements.put("download-pom-short-configuration", indent(downloadsResult.pomShort, 20));

        templateReplacements.put("index-list-active", indexesResult.listActive.toString());
        templateReplacements.put("index-list-deprecated", indexesResult.listDeprecated.toString());
        templateReplacements.put("index-full-doc", indexesResult.details.toString());
        templateReplacements.put("index-pom-complete-configuration", indent(indexesResult.pomComplete, 20));

        // Write Files
        writeTemplate("download.md", "data-mirror/template/download.md", "data-mirror/download.md", templateReplacements);
        writeTemplate("index.md", "data-mirror/template/index.md", "data-mirror/index.md", templateReplacements);
    }

    private SectionResult processSection(JavaProjectBuilder project, List<MirrorContext> contexts, boolean generateShortPom) {
        final SectionResult result = new SectionResult();

        for (MirrorContext context : contexts) {
            final String className = formatClassNameApplyDeprecated(context.mirrorClass);
            final String link = "[" + className + "](#" + toMarkdownId(className) + ")";

            if (context.isDeprecated) {
                result.listDeprecated.add(link);
            } else {
                result.listActive.add(link);
            }

            if (generateShortPom && context.mirrorClass.getName().contains("Download")) {
                result.details.add(generateDownloadDocumentation(project, context.mirrorClass));
            } else {
                result.details.add(generateIndexDocumentation(project, context.mirrorClass));
            }
        }

        final List<MirrorContext> notDeprecatedContexts = contexts.stream().filter(c -> !c.isDeprecated).collect(Collectors.toList());
        final List<MirrorContext> deprecatedContexts = contexts.stream().filter(c -> c.isDeprecated).collect(Collectors.toList());

        result.pomComplete = generatePomBlock(notDeprecatedContexts, true);
        if (!deprecatedContexts.isEmpty()) {
            result.pomComplete += "\n\n<!-- Deprecated steps -->\n" + generatePomBlock(deprecatedContexts, false);
        }
        if (generateShortPom) {
            result.pomShort = generatePomBlock(notDeprecatedContexts, false);
            if (!deprecatedContexts.isEmpty()) {
                result.pomShort += "\n\n<!-- Deprecated steps -->\n" + generatePomBlock(deprecatedContexts, false);
            }
        }

        return result;
    }

    private void writeTemplate(String templateName, String sourcePath, String destPath, Map<String, String> replacements) throws IOException {
        final List<String> lines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile(sourcePath), replacements);
        DocumentationGenerator.assertTemplateFullyFilled(templateName, lines);
        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile(destPath), lines);
    }

    private String generatePomBlock(List<MirrorContext> contexts, boolean includeDetails) {
        final List<String> entries = new ArrayList<>();
        for (MirrorContext context : contexts) {
            entries.add(generatePomEntry(context, includeDetails));
        }

        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < entries.size(); i++) {
            String current = entries.get(i);
            if (i > 0) {
                String previous = entries.get(i - 1);
                // Gap logic: Single-to-Single = 1 newline; Any-to-Block or Block-to-Any = 2 newlines
                if (previous.contains("\n") || current.contains("\n")) {
                    sb.append("\n\n");
                } else {
                    sb.append("\n");
                }
            }
            sb.append(current);
        }
        return sb.toString();
    }

    private String generatePomEntry(MirrorContext context, boolean includeDetails) {
        if (context.isDeprecated) {
            return "<!-- <" + context.mavenPropertyName + "/> -->";
        }

        if (!includeDetails) {
            return "<" + context.mavenPropertyName + "/>";
        }

        final StringBuilder innerContent = new StringBuilder();
        appendInitializerConfiguration(innerContent, context);
        appendResourceLocations(innerContent, context);

        if (innerContent.length() == 0) {
            return "<" + context.mavenPropertyName + "/>";
        }

        return "<" + context.mavenPropertyName + ">\n" + innerContent + "</" + context.mavenPropertyName + ">";
    }

    private void appendInitializerConfiguration(StringBuilder sb, MirrorContext context) {
        if (context.initializerClass == null) return;

        final Object initializerInstance = instantiateInitializer(context.initializerClass);

        final List<JavaField> fieldsToDocument = new ArrayList<>();
        JavaClass current = context.initializerClass;

        while (current != null && !IGNORED_INITIALIZER_CLASSES.contains(current.getName()) && !IGNORED_INITIALIZER_CLASSES.contains(current.getSimpleName())) {
            fieldsToDocument.addAll(0, current.getFields());
            current = current.getSuperJavaClass();
        }

        for (JavaField field : fieldsToDocument) {
            if (field.isStatic()) continue;
            if (field.isFinal() && !isCollectionOrMap(field.getType())) continue;

            final String value = resolveDefaultValue(context, initializerInstance, field);
            appendXmlComment(sb, "    ", field.getComment());

            if (value == null || value.isEmpty()) {
                sb.append("    <").append(field.getName()).append("/>\n");
            } else {
                sb.append("    <").append(field.getName()).append(">")
                        .append(xmlEncode(value))
                        .append("</").append(field.getName()).append(">\n");
            }
        }
    }

    private boolean isCollectionOrMap(JavaClass type) {
        if (type == null) return false;
        // Check for common collection interfaces (checking hierarchy via name since full reflection might vary)
        // Ideally we use isA() but QDox context matters. Checking names is robust for standard JDK types.
        if (type.isA("java.util.Collection") || type.isA("java.util.Map")) return true;

        // Fallback checks for simple names if resolution fails
        String name = type.getFullyQualifiedName();
        return name.startsWith("java.util.List") || name.startsWith("java.util.Set") ||
               name.startsWith("java.util.Map") || name.startsWith("java.util.Collection");
    }

    private void appendResourceLocations(StringBuilder sb, MirrorContext context) {
        final JavaClass resourceLocationEnum = context.mirrorClass.getNestedClasses().stream()
                .filter(c -> c.isEnum() && c.getName().contains("ResourceLocation"))
                .findFirst()
                .orElse(null);

        if (resourceLocationEnum == null) return;

        if (sb.length() > 0) sb.append("\n");
        sb.append("    <resourceLocations>\n");

        boolean first = true;
        for (JavaField enumConstant : resourceLocationEnum.getEnumConstants()) {
            if (!first) sb.append("\n");
            first = false;

            appendXmlComment(sb, "        ", enumConstant.getComment());

            String paramValue = enumConstant.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "");
            sb.append("        <!-- <").append(enumConstant.getName()).append(">")
                    .append(xmlEncode(paramValue))
                    .append("</").append(enumConstant.getName()).append("> -->\n");
        }
        sb.append("    </resourceLocations>\n");
    }

    private String resolveDefaultValue(MirrorContext context, Object instance, JavaField field) {
        if ("apiKey".equals(field.getName())) {
            return "${env.nvd.apikey}";
        }

        if (instance != null) {
            try {
                Object runtimeValue = getFieldValue(instance, field.getName());
                if (runtimeValue != null) {
                    return runtimeValue.toString();
                }
            } catch (Exception ignored) {
                // Handled by fallthrough
            }
        }

        // Fallback to QDox
        if (field.getInitializationExpression() != null) {
            String expression = field.getInitializationExpression().replace("\"", "");
            if (expression.contains("new JSONArray().toString()")) {
                return "[]";
            } else if (expression.contains("new ArrayList") || expression.contains("new HashMap")) {
                return "";
            }
            if (instance != null) {
                // Log only if we expected reflection to work but it failed/returned null, necessitating fallback
                System.err.println("Reflection failed or value null for field [" + context.initializerClass.getSimpleName() + "." + field.getName() + "]. Falling back to QDox expression: " + expression);
            }
            return expression;
        }
        return "";
    }

    private Object instantiateInitializer(JavaClass initializerClass) {
        try {
            final Class<?> clazz = Class.forName(initializerClass.getBinaryName());
            return clazz.getConstructor().newInstance();
        } catch (Throwable t) {
            System.err.println("Could not instantiate initializer [" + initializerClass.getBinaryName() + "] to retrieve default values. Reason: " + t);
            return null;
        }
    }

    private Object getFieldValue(Object instance, String fieldName) {
        Class<?> clazz = instance.getClass();
        while (clazz != null) {
            try {
                java.lang.reflect.Field f = clazz.getDeclaredField(fieldName);
                f.setAccessible(true);
                return f.get(instance);
            } catch (NoSuchFieldException e) {
                clazz = clazz.getSuperclass();
            } catch (Exception e) {
                return null;
            }
        }
        return null;
    }

    private Map<String, JavaClass> mapMojoInitializers(JavaClass mojoClass) {
        final Map<String, JavaClass> map = new HashMap<>();
        if (mojoClass == null) {
            log.warn("DataMirrorMojo class not found in project sources. Initializer mapping will be empty.");
            return map;
        }
        for (JavaField field : mojoClass.getFields()) {
            map.put(field.getName(), field.getType());
        }
        return map;
    }

    /**
     * Orders classes based on the topological dependency order defined by the runtime MirrorRunner.
     */
    public static List<JavaClass> orderMirrorClasses(List<JavaClass> classes) {
        final Map<Class<?>, JavaClass> classMap = new HashMap<>();
        final List<Mirror> instances = new ArrayList<>();

        for (JavaClass jc : classes) {
            try {
                final Class<?> clazz = Class.forName(jc.getBinaryName());
                final Mirror mirror = instantiateMirror(clazz);
                instances.add(mirror);
                classMap.put(clazz, jc);
            } catch (Exception e) {
                log.warn("Could not instantiate class [{}] for ordering. It will be appended to the end.", jc.getBinaryName());
            }
        }

        final MirrorRunner runner = new MirrorRunner(null);
        final List<Mirror> sortedMirrors = runner.resolveExecutionOrder(instances);

        final List<JavaClass> sortedJavaClasses = new ArrayList<>();
        for (Mirror m : sortedMirrors) {
            sortedJavaClasses.add(classMap.get(m.getClass()));
        }

        for (JavaClass jc : classes) {
            if (!sortedJavaClasses.contains(jc)) {
                sortedJavaClasses.add(jc);
            }
        }

        // Deprecated to bottom
        final List<JavaClass> deprecated = sortedJavaClasses.stream()
                .filter(MarkdownDocUtils::isDeprecated)
                .collect(Collectors.toList());
        sortedJavaClasses.removeAll(deprecated);
        sortedJavaClasses.addAll(deprecated);

        return sortedJavaClasses;
    }

    private static Mirror instantiateMirror(Class<?> clazz) throws Exception {
        try {
            final Constructor<?> constructor = clazz.getConstructor(File.class);
            return (Mirror) constructor.newInstance((File) null);
        } catch (NoSuchMethodException ignored) {
        }
        final Constructor<?> constructor = clazz.getConstructor();
        return (Mirror) constructor.newInstance();
    }

    private String generateDownloadDocumentation(JavaProjectBuilder project, JavaClass clazz) {
        final StringBuilder content = new StringBuilder();
        content.append(generateGeneralMirrorHeaderDocumentation(project, clazz, "performDownload"));
        appendResourceLocationTable(content, clazz);
        return content.toString();
    }

    private String generateIndexDocumentation(JavaProjectBuilder project, JavaClass clazz) {
        final StringBuilder content = new StringBuilder();
        content.append(generateGeneralMirrorHeaderDocumentation(project, clazz, "createIndexDocuments"));
        appendIndexDependenciesTable(content, project, clazz);
        return content.toString();
    }

    private void appendResourceLocationTable(StringBuilder content, JavaClass clazz) {
        final JavaClass resourceLocationEnum = clazz.getNestedClasses().stream()
                .filter(c -> c.isEnum() && c.getName().contains("ResourceLocation"))
                .findFirst()
                .orElse(null);

        if (resourceLocationEnum != null) {
            content.append("| Resource Location | Description |\n| --- | --- |\n");
            for (JavaField enumConstant : resourceLocationEnum.getEnumConstants()) {
                if (enumConstant.getComment() == null) {
                    System.err.println("Resource location does not have a JavaDoc definition attached: " + enumConstant + " " + enumConstant.getClass().getName());
                }
                content.append("| `").append(enumConstant.getName()).append("` | <p>");
                content.append(enumConstant.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "")).append("</p>")
                        .append(enumConstant.getComment() == null ? "" : enumConstant.getComment().replace("\r\n", " ").replace("\n", " ").replace("\r", " "))
                        .append(" |\n");
            }
        }
    }

    private void appendIndexDependenciesTable(StringBuilder content, JavaProjectBuilder project, JavaClass clazz) {
        final Map<String, List<JavaClass>> classDependencies = getIndexDependencies(project, clazz);
        final boolean isDeprecated = isDeprecated(clazz);

        content.append("| Dependency Type | Depends on |\n| --- | --- |\n");
        for (Map.Entry<String, List<JavaClass>> dependencyEntry : classDependencies.entrySet()) {
            final String type = dependencyEntry.getKey();
            final List<JavaClass> dependencies = dependencyEntry.getValue();

            if (dependencies.isEmpty()) continue;

            content.append("| **").append(type).append("** | ");
            final StringJoiner classNameJoiner = new StringJoiner(", ");
            for (JavaClass dependency : dependencies) {
                final StringBuilder dependencyContent = new StringBuilder();
                if (isDeprecated) {
                    dependencyContent.append("_").append(formatClassName(dependency)).append("_");
                } else {
                    dependencyContent.append("[").append(formatClassName(dependency)).append("](");
                    if (type.toLowerCase().contains("download")) {
                        dependencyContent.append("download.md");
                    }
                    dependencyContent.append("#").append(toMarkdownId(formatClassName(dependency))).append(")");
                }
                classNameJoiner.add(dependencyContent.toString());
            }
            content.append(classNameJoiner).append(" |\n");
        }
    }

    private void appendXmlComment(StringBuilder sb, String indent, String javadoc) {
        List<String> lines = formatJavadocForXmlComment(javadoc);
        if (lines.isEmpty()) return;

        sb.append(indent).append("<!-- ");
        if (lines.size() == 1) {
            sb.append(lines.get(0)).append(" -->\n");
        } else {
            sb.append(lines.get(0)).append("\n");
            for (int i = 1; i < lines.size(); i++) {
                sb.append(indent).append("     ").append(lines.get(i));
                if (i < lines.size() - 1) {
                    sb.append("\n");
                } else {
                    sb.append(" -->\n");
                }
            }
        }
    }

    private List<String> formatJavadocForXmlComment(String javadoc) {
        if (javadoc == null || javadoc.isEmpty()) return Collections.emptyList();

        String text = javadoc.replace("\r\n", "\n").replace("\r", "\n");
        text = text.replaceAll("<a\\s+href=\"([^\"]+)\"[^>]*>(.*?)</a>", "$2 ($1)");
        text = text.replaceAll("<code>(.*?)</code>", "'$1'");
        text = text.replaceAll("<ol>", "\n").replaceAll("<ul>", "\n")
                .replaceAll("</ol>", "").replaceAll("</ul>", "")
                .replaceAll("<li>", "\n- ").replaceAll("</li>", "");
        text = text.replaceAll("<p>", "\n").replaceAll("</p>", "")
                .replaceAll("<br\\s*/?>", "\n")
                .replaceAll("<pre>", "\n").replaceAll("</pre>", "");
        text = text.replaceAll("<[^>]+>", "");
        text = text.replace("&lt;", "<").replace("&gt;", ">").replace("&amp;", "&").replace("&quot;", "\"");
        text = text.replace("--", "__");

        final List<String> cleanedLines = new ArrayList<>();
        for (String line : text.split("\n")) {
            String trimmed = line.trim();
            if (!trimmed.isEmpty()) cleanedLines.add(trimmed);
        }
        return cleanedLines;
    }

    // Static Helpers for Dependencies and Header (kept as requested/referenced by other logic)

    public static Map<String, List<JavaClass>> getIndexDependencies(JavaProjectBuilder project, JavaClass clazz) {
        final Map<String, List<JavaClass>> dependencies = new LinkedHashMap<>();
        final JavaAnnotation indexDependencies = clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().endsWith("IndexDependencies"))
                .findFirst()
                .orElse(null);

        if (indexDependencies != null) {
            dependencies.put("Download", resolveDependenciesFromAnnotation(project, indexDependencies, "requiredDownloads"));
            dependencies.put("Index", resolveDependenciesFromAnnotation(project, indexDependencies, "requiredIndexes"));
            dependencies.put("Optional Download", resolveDependenciesFromAnnotation(project, indexDependencies, "optionalDownloads"));
            dependencies.put("Optional Index", resolveDependenciesFromAnnotation(project, indexDependencies, "optionalIndexes"));
        } else {
            dependencies.put("Download", Collections.emptyList());
            dependencies.put("Index", Collections.emptyList());
            dependencies.put("Optional Download", Collections.emptyList());
            dependencies.put("Optional Index", Collections.emptyList());
        }
        return dependencies;
    }

    private static List<JavaClass> resolveDependenciesFromAnnotation(JavaProjectBuilder project, JavaAnnotation annotation, String property) {
        final AnnotationValue value = annotation.getProperty(property);
        if (value == null) return Collections.emptyList();

        final List<String> classNames = new ArrayList<>();
        final Object parameterValue = value.getParameterValue();

        if (parameterValue instanceof List) {
            for (Object o : (List<?>) parameterValue) classNames.add(o.toString());
        } else {
            classNames.add(parameterValue.toString());
        }

        final List<JavaClass> resolvedClasses = new ArrayList<>();
        for (String rawClassName : classNames) {
            final String className = rawClassName.replace(".class", "").replace("\"", "").trim();
            if (className.isEmpty()) continue;
            final JavaClass referencedClass = project.getClasses().stream()
                    .filter(c -> c.getSimpleName().equals(className) || c.getName().equals(className))
                    .findFirst()
                    .orElseThrow(() -> new RuntimeException("Referenced class [" + className + "] not found in project."));
            resolvedClasses.add(referencedClass);
        }
        return resolvedClasses;
    }

    private String generateGeneralMirrorHeaderDocumentation(JavaProjectBuilder project, JavaClass clazz, String relevantMethodName) {
        final StringBuilder content = new StringBuilder();
        final JavaAnnotation mirrorMetadata = getMirrorMetadata(clazz);
        final AnnotationValue directoryName = mirrorMetadata.getProperty("directoryName");
        final AnnotationValue mavenPropertyName = mirrorMetadata.getProperty("mavenPropertyName");

        content.append("## ").append(formatClassNameApplyDeprecated(clazz)).append("\n\n");
        content.append("`").append(directoryName.getParameterValue().toString().replace("\"", ""))
                .append("` / `").append(mavenPropertyName.getParameterValue().toString().replace("\"", ""))
                .append("`\n\n");

        content.append(generateDocRelevantMethodExpandables(project, clazz, relevantMethodName)).append("\n");

        if (clazz.getComment() != null && !clazz.getComment().isEmpty()) {
            content.append(clazz.getComment()).append("\n\n");
        }
        return content.toString();
    }

    public static JavaAnnotation getMirrorMetadata(JavaClass clazz) {
        return clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("MirrorMetadata"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No @MirrorMetadata annotation found on " + clazz.getName()));
    }

    public static String getAnnotationStringValue(JavaAnnotation annotation, String property) {
        final AnnotationValue value = annotation.getProperty(property);
        return value != null ? value.getParameterValue().toString().replace("\"", "") : null;
    }

    public static String generateDocRelevantMethodExpandables(JavaProjectBuilder project, JavaClass clazz, String relevantMethodName) {
        if (relevantMethodName != null) {
            final JavaMethod baseClassMethod = clazz.getMethods().stream().filter(m -> m.getName().equals(relevantMethodName)).findFirst().orElse(null);
            final JavaMethod superClassMethod = clazz.getSuperJavaClass() != null ? clazz.getSuperJavaClass().getMethods().stream().filter(m -> m.getName().equals(relevantMethodName)).findFirst().orElse(null) : null;
            final JavaMethod method = firstNonNull(baseClassMethod, superClassMethod);

            if (method == null) {
                System.err.println("Method [" + relevantMethodName + "] not found on [" + clazz.getName() + "]");
                return null;
            }

            final Pair<String, JavaMethod> methods = createSourceCodeExpandable(baseClassMethod == null ? clazz.getSuperJavaClass() : clazz, method);
            final StringJoiner inBetweenContent = new StringJoiner("\n");
            inBetweenContent.add(methods.getKey());

            final List<Pair<JavaClass, JavaMethod>> docRelevantMethods = findDocRelevantMethod(project, clazz, methods);
            for (Pair<JavaClass, JavaMethod> docRelevantMethod : docRelevantMethods) {
                inBetweenContent.add(createSourceCodeExpandable(docRelevantMethod.getKey(), docRelevantMethod.getValue()).getKey());
            }

            return inBetweenContent.toString();
        }
        return null;
    }

    public static List<Pair<JavaClass, JavaMethod>> findDocRelevantMethod(JavaProjectBuilder project, JavaClass clazz, Pair<String, JavaMethod> methods) {
        final JavaAnnotation docRelevantMethods = methods.getValue().getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("DocRelevantMethods"))
                .findFirst()
                .orElse(null);

        if (docRelevantMethods != null) {
            final List<Pair<JavaClass, JavaMethod>> relevantMethods = new ArrayList<>();
            final Object value = docRelevantMethods.getProperty("value").getParameterValue();

            if (value instanceof List) {
                for (String reference : (List<String>) value) {
                    final String[] parts = reference.replace("\"", "").split("#");
                    if (parts.length == 2) {
                        final String className = parts[0];
                        final String methodName = parts[1].replaceAll("([^(]+)(\\(.*\\))", "$1");
                        final String[] methodParams = parts[1].contains("(") ? parts[1].replaceAll("([^(]+)\\((.*)\\)", "$2").split(" *, *") : null;

                        final JavaClass relevantClass = firstNonNull(
                                className.contains(".") ? project.getClassByName(className) : null,
                                className.equals(clazz.getName()) ? clazz : null,
                                project.getClasses().stream().filter(c -> c.getName().equals(className)).findFirst().orElse(null)
                        );

                        if (relevantClass != null) {
                            final JavaMethod relevantMethod = findMethodByNameAndParams(relevantClass, methodName, methodParams);
                            if (relevantMethod != null) {
                                relevantMethods.add(new Pair<>(relevantClass, relevantMethod));
                            } else {
                                throw new IllegalStateException("Relevant Method [" + methodName + "] with params " + Arrays.toString(methodParams) + " not found on [" + className + "]");
                            }
                        } else {
                            throw new IllegalStateException("Class [" + className + "] not found for relevant method [" + methodName + "]");
                        }
                    } else {
                        throw new IllegalStateException("Invalid reference [" + reference + "]" + (parts.length == 1 ? " (did you forget to add a method name with \"#\"?)" : ""));
                    }
                }
            }
            return relevantMethods;
        }
        return new ArrayList<>();
    }

    private static JavaMethod findMethodByNameAndParams(JavaClass clazz, String methodName, String[] methodParams) {
        if (methodParams == null) {
            return clazz.getMethods().stream().filter(m -> m.getName().equals(methodName)).findFirst().orElse(null);
        }
        return clazz.getMethods().stream()
                .filter(m -> m.getName().equals(methodName))
                .filter(m -> m.getParameters().size() == methodParams.length)
                .filter(m -> {
                    for (int i = 0; i < methodParams.length; i++) {
                        if (!m.getParameters().get(i).getType().getValue().equals(methodParams[i])) return false;
                    }
                    return true;
                })
                .findFirst().orElse(null);
    }

    public static List<JavaClass> orderEnrichmentClasses(List<JavaClass> classes) {
        return orderClasses(classes, DocumentationProperties.loadResource("/enrichment/enrichment-order.txt"));
    }

    public static List<JavaClass> orderClasses(List<JavaClass> classes, List<String> order) {
        final Map<String, JavaClass> classMap = new HashMap<>();
        for (JavaClass clazz : classes) classMap.put(clazz.getName(), clazz);

        final List<JavaClass> orderedClasses = new ArrayList<>();
        for (String className : order) {
            if (classMap.containsKey(className)) orderedClasses.add(classMap.get(className));
        }
        for (JavaClass clazz : classes) {
            if (!orderedClasses.contains(clazz)) orderedClasses.add(clazz);
        }

        final List<JavaClass> deprecated = orderedClasses.stream().filter(MarkdownDocUtils::isDeprecated).collect(Collectors.toList());
        orderedClasses.removeAll(deprecated);
        orderedClasses.addAll(deprecated);

        return orderedClasses;
    }

    public static Pair<String, JavaMethod> createSourceCodeExpandable(JavaClass clazz, JavaMethod method) {
        final StringBuilder inBetweenContent = new StringBuilder();
        if (method != null) {
            final String baseCodeBlock = unindentCodeBlock(method.getCodeBlock(), 4);
            final String onlyCodePart = unindentCodeBlock(retainMiddlePart(baseCodeBlock.replaceAll("\\) throws [A-Za-z0-9_,. ]+ \\{", ") {"), ") {", "}"), 4);

            inBetweenContent.append("<details>\n\n<summary>Source Code for <code>")
                    .append(clazz.getName())
                    .append(".").append(method.getName())
                    .append("(").append(method.getParameters().stream().map(p -> p.getType().getValue() + " " + p.getName()).collect(Collectors.joining(", ")).replace("java.lang.", "")).append(")")
                    .append("</code> </summary>\n\n```java\n")
                    .append(onlyCodePart)
                    .append("\n```\n\n</details>\n\n");
        }
        return new Pair<>(inBetweenContent.toString(), method);
    }

    public static class Pair<K, V> {
        private final K key;
        private final V value;

        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }
    }
}
