package com.metaeffekt.documentation.generator;

import com.metaeffekt.documentation.DocumentationGenerator;
import com.metaeffekt.documentation.IDocumentationGenerator;
import com.metaeffekt.documentation.util.DocumentationProperties;
import com.metaeffekt.documentation.util.MarkdownDocUtils;
import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.model.*;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import org.apache.commons.io.FileUtils;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

import static com.metaeffekt.documentation.util.MarkdownDocUtils.*;

public class MirrorDocumentationGenerator implements IDocumentationGenerator {

    public void generateDocumentation(JavaProjectBuilder project) throws IOException {
        final List<JavaClass> downloadClasses = excludeAllThatAreExtendedByOthers(orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.download.Download")));
        final List<JavaClass> indexClasses = excludeAllThatAreExtendedByOthers(orderMirrorClasses(DocumentationGenerator.findClassesExtending(project, "com.metaeffekt.mirror.index.Index")));


        final Map<String, String> templateReplacements = new HashMap<>();

        final StringJoiner downloadClassesListJoiner = new StringJoiner("\n- ", "- ", "");
        final StringJoiner downloadDeprecatedClassesListJoiner = new StringJoiner("\n- ", "- ", "");
        final StringJoiner downloadClassesDetailsJoiner = new StringJoiner("\n\n");
        final StringJoiner downloadClassesMavenPomJoiner = new StringJoiner("\n");
        final StringJoiner downloadClassesMavenPomShortJoiner = new StringJoiner("\n");
        for (JavaClass clazz : downloadClasses) {
            if (isDeprecated(clazz)) {
                downloadDeprecatedClassesListJoiner.add("[" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
            } else {
                downloadClassesListJoiner.add("[" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
                downloadClassesMavenPomJoiner.add(generateMavenPomConfigurationEntryForDownloader(clazz, true));
                downloadClassesMavenPomShortJoiner.add(generateMavenPomConfigurationEntryForDownloader(clazz, false));
            }
            downloadClassesDetailsJoiner.add(generateDownloadDocumentation(project, clazz));
        }
        templateReplacements.put("download-list-active", downloadClassesListJoiner.toString());
        templateReplacements.put("download-list-deprecated", downloadDeprecatedClassesListJoiner.toString());
        templateReplacements.put("download-full-doc", downloadClassesDetailsJoiner.toString());
        templateReplacements.put("download-pom-complete-configuration", indent(downloadClassesMavenPomJoiner.toString(), 20));
        templateReplacements.put("download-pom-short-configuration", indent(downloadClassesMavenPomShortJoiner.toString(), 20));

        final StringJoiner indexClassesDetailsJoiner = new StringJoiner("\n\n");
        final StringJoiner indexDeprecatedClassesListJoiner = new StringJoiner("\n- ", "- ", "");
        final StringJoiner indexClassesListJoiner = new StringJoiner("\n- ", "- ", "");
        final StringJoiner indexClassesMavenPomJoiner = new StringJoiner("\n");
        for (JavaClass clazz : indexClasses) {
            if (isDeprecated(clazz)) {
                indexDeprecatedClassesListJoiner.add("[" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
            } else {
                indexClassesListJoiner.add("[" + formatClassNameApplyDeprecated(clazz) + "](#" + toMarkdownId(formatClassNameApplyDeprecated(clazz)) + ")");
                indexClassesMavenPomJoiner.add(generateMavenPomConfigurationEntryForIndexer(clazz));
            }
            indexClassesDetailsJoiner.add(generateIndexDocumentation(project, clazz));
        }
        templateReplacements.put("index-list-active", indexClassesListJoiner.toString());
        templateReplacements.put("index-list-deprecated", indexDeprecatedClassesListJoiner.toString());
        templateReplacements.put("index-full-doc", indexClassesDetailsJoiner.toString());
        templateReplacements.put("index-pom-complete-configuration", indent(indexClassesMavenPomJoiner.toString(), 20));


        final List<String> downloadTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/template/download.md"), templateReplacements);
        final List<String> indexTargetLines = DocumentationGenerator.fillTemplate(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/template/index.md"), templateReplacements);

        DocumentationGenerator.assertTemplateFullyFilled("download.md", downloadTargetLines);
        DocumentationGenerator.assertTemplateFullyFilled("index.md", indexTargetLines);

        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/download.md"), downloadTargetLines);
        FileUtils.writeLines(DocumentationGenerator.getVulnerabilityDocumentationFile("data-mirror/index.md"), indexTargetLines);
    }

    private String generateDownloadDocumentation(JavaProjectBuilder project, JavaClass clazz) {
        final StringBuilder content = new StringBuilder();

        content.append(generateGeneralMirrorHeaderDocumentation(project, clazz, "performDownload"));

        // search the class for a definition of an enum that implements ResourceLocation
        final JavaClass resourceLocationEnum = clazz.getNestedClasses().stream()
                .filter(c -> c.isEnum() && c.getName().contains("ResourceLocation"))
                .findFirst()
                .orElse(null);

        if (resourceLocationEnum != null) {
            content.append("| Resource Location | Description |\n")
                    .append("| --- | --- |\n");
            for (JavaField enumConstant : resourceLocationEnum.getEnumConstants()) {
                content.append("| `").append(enumConstant.getName()).append("` | <p>");
                content.append(enumConstant.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "")).append("</p>")
                        .append(enumConstant.getComment().replace("\r\n", " ").replace("\n", " ").replace("\r", " "))
                        .append(" |\n");
            }
        }

        return content.toString();
    }

    private String generateMavenPomConfigurationEntryForDownloader(JavaClass clazz, boolean includeDetails) {
        final JavaAnnotation mirrorMetadata = getMirrorMetadata(clazz);
        final AnnotationValue mavenPropertyName = mirrorMetadata.getProperty("mavenPropertyName");

        // search the class for a definition of an enum that implements ResourceLocation
        final JavaClass resourceLocationEnum = clazz.getNestedClasses().stream()
                .filter(c -> c.isEnum() && c.getName().contains("ResourceLocation"))
                .findFirst()
                .orElse(null);

        final StringBuilder resourceLocationEnumContent = new StringBuilder();
        if (includeDetails && resourceLocationEnum != null) {
            for (JavaField enumConstant : resourceLocationEnum.getEnumConstants()) {
                resourceLocationEnumContent.append("    <").append(enumConstant.getName()).append(">")
                        .append(xmlEncode(enumConstant.getEnumConstantArguments().get(0).getParameterValue().toString().replace("\"", "")))
                        .append("</").append(enumConstant.getName()).append(">\n");
            }

            return "\n<" + mavenPropertyName.getParameterValue().toString().replace("\"", "") + ">" +
                    "\n  <resourceLocations>\n" + resourceLocationEnumContent + "  </resourceLocations>\n" +
                    "</" + mavenPropertyName.getParameterValue().toString().replace("\"", "") + ">";
        } else {
            return (includeDetails ? "\n" : "") + "<" + mavenPropertyName.getParameterValue().toString().replace("\"", "") + "/>";
        }
    }

    private String generateMavenPomConfigurationEntryForIndexer(JavaClass clazz) {
        final JavaAnnotation mirrorMetadata = getMirrorMetadata(clazz);
        final AnnotationValue mavenPropertyName = mirrorMetadata.getProperty("mavenPropertyName");

        return "<" + mavenPropertyName.getParameterValue().toString().replace("\"", "") + "/>";
    }

    public static Pair<String, JavaMethod> createSourceCodeExpandable(JavaClass clazz, JavaMethod method) {
        final StringBuilder inBetweenContent = new StringBuilder();

        if (method != null) {
            final String baseCodeBlock = unindentCodeBlock(method.getCodeBlock(), 4);
            final String onlyCodePart = unindentCodeBlock(retainMiddlePart(baseCodeBlock.replaceAll("\\) throws [A-Za-z0-9_,. ]+ \\{", ") {"), ") {", "}"), 4);

            inBetweenContent.append("<details>\n\n<summary>Source Code for <code>")
                    .append(clazz.getName())
                    .append(".").append(method.getName())
                    .append("(").append(method.getParameters().stream().map(p -> p.getType().getValue() + " " + p.getName()).collect(Collectors.joining(", ")).replace("java.lang.", "")).append(")")
                    .append("</code> </summary>\n\n```java\n")
                    .append(onlyCodePart)
                    .append("\n```\n\n</details>\n\n");
        }

        return new Pair<>(inBetweenContent.toString(), method);
    }

    private String generateIndexDocumentation(JavaProjectBuilder project, JavaClass clazz) {
        final StringBuilder content = new StringBuilder();

        final boolean isDeprecated = isDeprecated(clazz);
        content.append(generateGeneralMirrorHeaderDocumentation(project, clazz, "createIndexDocuments"));

        final Map<String, List<JavaClass>> classDependencies = getIndexDependencies(project, clazz);

        content.append("| Dependency Type | Depends on |\n")
                .append("| --- | --- |\n");
        for (Map.Entry<String, List<JavaClass>> dependencyEntry : classDependencies.entrySet()) {
            final String type = dependencyEntry.getKey();
            final List<JavaClass> dependencies = dependencyEntry.getValue();

            if (dependencies.isEmpty()) {
                continue;
            }

            content.append("| **").append(type).append("** | ");
            final StringJoiner classNameJoiner = new StringJoiner(", ");
            for (JavaClass dependency : dependencies) {
                final StringBuilder dependencyContent = new StringBuilder();
                if (isDeprecated) {
                    dependencyContent.append("_").append(formatClassName(dependency)).append("_");
                } else {
                    dependencyContent.append("[").append(formatClassName(dependency)).append("](");
                    if (type.toLowerCase().contains("download")) {
                        dependencyContent.append("download.md");
                    }
                    dependencyContent.append("#").append(toMarkdownId(formatClassName(dependency))).append(")");
                }
                classNameJoiner.add(dependencyContent.toString());
            }
            content.append(classNameJoiner).append(" |\n");
        }

        return content.toString();
    }

    public static Map<String, List<JavaClass>> getIndexDependencies(JavaProjectBuilder project, JavaClass clazz) {
        // relevant part in constructor: super(baseMirrorDirectory, GhsaAdvisorIndex.class, Collections.singletonList(GhsaDownload.class), Collections.emptyList());
        final JavaConstructor classConstructor = clazz.getConstructors().stream()
                .filter(c -> c.getParameters().size() == 1)
                .filter(c -> c.getParameters().get(0).getType().getValue().equals("File"))
                .findFirst().orElseThrow(() -> new RuntimeException("No constructor with one file parameter found on " + clazz.getName()));

        // now access the inside of the constructor, the super call
        String[] constructorParameters = classConstructor.getCodeBlock()
                .replace("\n", "").replace("\r", "").replace(" ", "")
                .replaceAll(".*super\\(([^;]+)\\);.*", "$1")
                .split(",");

        // [baseMirrorDirectory, MsrcKbChainIndex.class, Collections.singletonList(MsrcSecurityGuideDownload.class), Arrays.asList(MsrcAdvisorIndex.class, MsrcProductIndex.class), Collections.singletonList(MsrcManualCsvDownload.class), Collections.emptyList()]
        // [baseMirrorDirectory, MsrcProductIndex.class, Collections.singletonList(MsrcDownload.class), Collections.emptyList()]
        // now skip the first two parameters and grab the rest, make sure to collect each parameter until the value ends in a ")"
        final List<List<JavaClass>> classDependencies = new ArrayList<>();
        List<JavaClass> currentClassDependency = new ArrayList<>();
        for (int i = 2, constructorParametersLength = constructorParameters.length; i < constructorParametersLength; i++) {
            final String parameter = constructorParameters[i];

            if (parameter.contains("()")) {
                classDependencies.add(currentClassDependency);
                currentClassDependency = new ArrayList<>();
                continue;
            }

            // extract the "*.class" part
            // final String className = parameter.replaceAll(".*?([A-Za-z0-9]+\\.class).*", "$1");
            // final String simpleClassName = className.substring(0, className.length() - ".class".length());

            final String className = parameter.replaceAll(".*?([A-Za-z0-9]+\\.class).*", "$1").replace(".class", "");
            final JavaClass referencedClass = project.getClasses().stream()
                    .filter(c -> c.getSimpleName().equals(className))
                    .findFirst()
                    .orElseThrow(() -> new RuntimeException("Referenced class [" + className + "] not found in project"));

            currentClassDependency.add(referencedClass);
            if (parameter.endsWith(")")) {
                classDependencies.add(currentClassDependency);
                currentClassDependency = new ArrayList<>();
            }
        }
        if (!currentClassDependency.isEmpty()) {
            classDependencies.add(currentClassDependency);
        }

        // [[MsrcSecurityGuideDownload], [MsrcAdvisorIndex, MsrcProductIndex], [MsrcManualCsvDownload], []]
        final List<String> dependencyTypes = Arrays.asList("Download", "Index", "Optional Download", "Optional Index");

        final Map<String, List<JavaClass>> dependencies = new LinkedHashMap<>();

        for (int i = 0; i < classDependencies.size(); i++) {
            dependencies.put(dependencyTypes.get(i), classDependencies.get(i));
        }

        return dependencies;
    }

    private String generateGeneralMirrorHeaderDocumentation(JavaProjectBuilder project, JavaClass clazz, String relevantMethodName) {
        final StringBuilder content = new StringBuilder();

        // search the cass for the @MirrorMetadata annotation
        final JavaAnnotation mirrorMetadata = getMirrorMetadata(clazz);
        final AnnotationValue directoryName = mirrorMetadata.getProperty("directoryName");
        final AnnotationValue mavenPropertyName = mirrorMetadata.getProperty("mavenPropertyName");

        content.append("## ").append(formatClassNameApplyDeprecated(clazz)).append("\n\n");
        content.append("`").append(directoryName.getParameterValue().toString().replace("\"", ""))
                .append("` / `").append(mavenPropertyName.getParameterValue().toString().replace("\"", ""))
                .append("`\n\n");


        content.append(generateDocRelevantMethodExpandables(project, clazz, relevantMethodName)).append("\n");

        if (clazz.getComment() != null && !clazz.getComment().isEmpty()) {
            content.append(clazz.getComment()).append("\n\n");
        }

        return content.toString();
    }

    public static JavaAnnotation getMirrorMetadata(JavaClass clazz) {
        return clazz.getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("MirrorMetadata"))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No @MirrorMetadata annotation found on " + clazz.getName()));
    }

    public static String getAnnotationStringValue(JavaAnnotation annotation, String property) {
        final AnnotationValue value = annotation.getProperty(property);
        return value != null ? value.getParameterValue().toString().replace("\"", "") : null;
    }

    public static String generateDocRelevantMethodExpandables(JavaProjectBuilder project, JavaClass clazz, String relevantMethodName) {
        if (relevantMethodName != null) {
            final JavaMethod baseClassMethod = clazz.getMethods().stream().filter(m -> m.getName().equals(relevantMethodName)).findFirst().orElse(null);
            final JavaMethod superClassMethod = clazz.getSuperJavaClass() != null ? clazz.getSuperJavaClass().getMethods().stream().filter(m -> m.getName().equals(relevantMethodName)).findFirst().orElse(null) : null;
            final JavaMethod method = firstNonNull(baseClassMethod, superClassMethod);

            if (method == null) {
                System.err.println("Method [" + relevantMethodName + "] not found on [" + clazz.getName() + "]");
                return null;
            }

            final Pair<String, JavaMethod> methods = createSourceCodeExpandable(baseClassMethod == null ? clazz.getSuperJavaClass() : clazz, method);
            final StringJoiner inBetweenContent = new StringJoiner("\n");
            inBetweenContent.add(methods.getKey());

            final List<Pair<JavaClass, JavaMethod>> docRelevantMethods = findDocRelevantMethod(project, clazz, methods);
            for (Pair<JavaClass, JavaMethod> docRelevantMethod : docRelevantMethods) {
                inBetweenContent.add(createSourceCodeExpandable(docRelevantMethod.getKey(), docRelevantMethod.getValue()).getKey());
            }

            return inBetweenContent.toString();
        }

        return null;
    }

    public static List<Pair<JavaClass, JavaMethod>> findDocRelevantMethod(JavaProjectBuilder project, JavaClass clazz, Pair<String, JavaMethod> methods) {
        final JavaAnnotation docRelevantMethods = methods.getValue().getAnnotations().stream()
                .filter(a -> a.getType().getValue().equals("DocRelevantMethods"))
                .findFirst()
                .orElse(null);

        if (docRelevantMethods != null) {
            final List<Pair<JavaClass, JavaMethod>> relevantMethods = new ArrayList<>();

            final Object value = docRelevantMethods.getProperty("value").getParameterValue();
            if (value instanceof List) {
                for (String reference : (List<String>) value) {
                    // split method and class name, split by "."
                    final String[] parts = reference.replace("\"", "").split("#");
                    if (parts.length == 2) {
                        final String className = parts[0];
                        final String methodName = parts[1].replaceAll("([^(]+)(\\(.*\\))", "$1");
                        final String[] methodParams = parts[1].contains("(") ? parts[1].replaceAll("([^(]+)\\((.*)\\)", "$2").split(" *, *") : null;

                        final JavaClass relevantClass = firstNonNull(
                                className.contains(".") ? project.getClassByName(className) : null,
                                className.equals(clazz.getName()) ? clazz : null,
                                project.getClasses().stream().filter(c -> c.getName().equals(className)).findFirst().orElse(null)
                        );

                        if (relevantClass != null) {
                            final JavaMethod relevantMethod = findMethodByNameAndParams(relevantClass, methodName, methodParams);
                            if (relevantMethod != null) {
                                relevantMethods.add(new Pair<>(relevantClass, relevantMethod));
                            } else {
                                System.err.println("Relevant Method [" + methodName + "] with params "+ Arrays.toString(methodParams) +" not found on [" + className + "]");
                            }
                        } else {
                            System.err.println("Class [" + className + "] not found for relevant method [" + methodName + "]");
                        }
                    } else {
                        System.err.println("Invalid reference [" + reference + "]" + (parts.length == 1 ? " (did you forget to add a method name with \"#\"?)" : ""));
                    }
                }
            }

            return relevantMethods;
        }

        return new ArrayList<>();
    }

    private static JavaMethod findMethodByNameAndParams(JavaClass clazz, String methodName, String[] methodParams) {
        if (methodParams == null) {
            return clazz.getMethods().stream().filter(m -> m.getName().equals(methodName)).findFirst().orElse(null);
        }

        return clazz.getMethods().stream()
                .filter(m -> m.getName().equals(methodName))
                .filter(m -> m.getParameters().size() == methodParams.length)
                .filter(m -> {
                    for (int i = 0; i < methodParams.length; i++) {
                        if (!m.getParameters().get(i).getType().getValue().equals(methodParams[i])) {
                            return false;
                        }
                    }
                    return true;
                })
                .findFirst().orElse(null);
    }

    public static List<JavaClass> orderMirrorClasses(List<JavaClass> classes) {
        final List<String> downloadOrder = DocumentationProperties.loadResource("/mirror/download-order.txt");
        final List<String> indexOrder = DocumentationProperties.loadResource("/mirror/index-order.txt");

        final List<String> order = new ArrayList<>();
        order.addAll(downloadOrder);
        order.addAll(indexOrder);

        return orderClasses(classes, order);
    }

    public static List<JavaClass> orderEnrichmentClasses(List<JavaClass> classes) {
        return orderClasses(classes, DocumentationProperties.loadResource("/enrichment/enrichment-order.txt"));
    }

    public static List<JavaClass> orderClasses(List<JavaClass> classes, List<String> order) {
        final Map<String, JavaClass> classMap = new HashMap<>();
        for (JavaClass clazz : classes) {
            classMap.put(clazz.getName(), clazz);
        }

        final List<JavaClass> orderedClasses = new ArrayList<>();

        for (String className : order) {
            if (classMap.containsKey(className)) {
                orderedClasses.add(classMap.get(className));
            }
        }

        for (JavaClass clazz : classes) {
            if (!orderedClasses.contains(clazz)) {
                orderedClasses.add(clazz);
            }
        }

        // now remove all deprecated and add them at the bottom in the order
        final List<JavaClass> deprecated = orderedClasses.stream().filter(MarkdownDocUtils::isDeprecated).collect(Collectors.toList());
        orderedClasses.removeAll(deprecated);
        orderedClasses.addAll(deprecated);

        return orderedClasses;
    }

    public static class Pair<K, V> {
        private final K key;
        private final V value;

        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }
    }
}
