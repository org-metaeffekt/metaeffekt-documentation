> [Documentation](../../README.md) >
> [Vulnerability Management](../vulnerability-management.md) >
> [Inventory Enrichment Pipeline](inventory-enrichment-pipeline.md) >
> Inventory Enrichment Steps

# Inventory Enrichment Steps

> [Overview](#overview) -
> [Steps](#product-identification)

## Overview

The inventory enrichment pipeline has already been described with a quick overview in the
[Inventory Enrichment Pipeline](inventory-enrichment-pipeline.md) chapter.
This chapter provides a detailed description of each step in the inventory enrichment pipeline.
While it is theoretically possible to construct a pipeline that runs the following steps in any order,
on a conceptual level, only a specific order makes sense.
This is why the steps are divided into separate phases, which are executed in a specific order, but within each phase,
the steps can be executed in any order.

In some cases, such as with the Vulnerability Details Fill phase,
a phase might have to run twice if certain conditions are met.
In order to reduce the length of the following list, these duplications have been omitted.
The descriptions when a phase has to run twice are included in the respective phase's description,
but the responsible maven plugin manages this automatically, so that you, as a user, will not have to worry about this.

$gen{enrichment-steps-active}

---

# Product Identification

A challenge for the vulnerability matching is that every vulnerability and security advisory provider uses different
formats and methods of identifying products and versions in their knowledge database.
A couple of examples for actual product identification methods are:

- The [National Vulnerability Database (NVD)](https://nvd.nist.gov/vuln)
  uses the [Common Platform Enumeration (CPE)](https://cpe.mitre.org/specification) to identify products,
- [Microsoft Security Response Center (MSRC)](https://www.microsoft.com/en-us/msrc)
  uses a numeric registry with a number for each product and version,
- [GitHub Security Advisories (GHSA)](https://github.com/advisories)
  and others use [Package URLs (PURLs)](https://github.com/package-url/purl-spec),
- [End Of Life](https://endoflife.date) uses unique string identifiers for each product,
- and so on.

This diversity of product identifiers is not represented in the initial software component inventory.
Therefore, the first step in the vulnerability matching process is to attempt to automatically derive product
identifiers from the component metadata, including artifact names, versions, and vendor information.

The following two steps are always performed to enable and improve the matching accuracy:

$gen{enrichment-steps-full-doc-PRODUCT_IDENTIFICATION}

---

# Vulnerability Matching

The next phase represents the main part of the inventory enrichment process,
where the actual vulnerabilities from different sources are matched against the products identified in the previous
steps.
Note that only the _vulnerabilities themselves_ are identified in this step, not the vulnerability metadata, such as
descriptions or CVSS vectors.
This separation is made to allow for adding those details whenever changes to the vulnerability list were made and to
prevent having to run the details step after each vulnerability identification step.

$gen{enrichment-steps-full-doc-VULNERABILITY_MATCHING}

---

# Vulnerability Details Filling

$gen{enrichment-steps-full-doc-VULNERABILITY_DETAILS_FILLING}

---

# Assessments

$gen{enrichment-steps-full-doc-ASSESSMENTS}

---

# Security Advisory Matching

$gen{enrichment-steps-full-doc-SECURITY_ADVISORY_MATCHING}

---

# Vulnerability Prioritization

$gen{enrichment-steps-full-doc-VULNERABILITY_PRIORITIZATION}

---

# Post Processing

$gen{enrichment-steps-full-doc-INVENTORY_POST_PROCESSING}

---

# Reporting

$gen{enrichment-steps-full-doc-REPORTING}

---

# Other standalone steps

$gen{enrichment-steps-full-doc-STANDALONE}

---
