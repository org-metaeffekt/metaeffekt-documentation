> [Documentation](../../README.md) >
> [Vulnerability Management](../vulnerability-management.md) >
> [Inventory Enrichment Pipeline](inventory-enrichment-pipeline.md) >
> Inventory Enrichment Steps

# Inventory Enrichment Steps

> [Overview](#overview) -
> [POM Configuration](#pom-configuration) -
> [Steps](#product-identification)

## Overview

The inventory enrichment pipeline has already been described with a quick overview in the
[Inventory Enrichment Pipeline](inventory-enrichment-pipeline.md) chapter.
This chapter provides a detailed description of each step in the inventory enrichment pipeline.
While it is theoretically possible to construct a pipeline that runs the following steps in any order,
on a conceptual level, only a specific order makes sense.
This is why the steps are divided into separate phases, which are executed in a specific order, but within each phase,
the steps can be executed in any order.

In some cases, such as with the Vulnerability Details Fill phase,
a phase might have to run twice if certain conditions are met.
In order to reduce the length of the following list, these duplications have been omitted.
The descriptions when a phase has to run twice are included in the respective phase's description,
but the responsible maven plugin manages this automatically, so that you, as a user, will not have to worry about this.

- **[Product Identification](#product-identification)**
  - [CPE URI derivation](#cpe-uri-derivation)
  - [Artifact Correlation YAML](#artifact-correlation-yaml)
- **[Vulnerability Matching](#vulnerability-matching)**
  - [NVD CVE from CPE](#nvd-cve-from-cpe)
  - [MSRC Vulnerabilities by Products](#msrc-vulnerabilities-by-products)
  - [GHSA Vulnerabilities](#ghsa-vulnerabilities)
  - [Custom Vulnerabilities from CPE](#custom-vulnerabilities-from-cpe)
- **[Vulnerability Details Filling](#vulnerability-details-filling)**
  - [NVD Vulnerability Details](#nvd-vulnerability-details)
  - [MSRC Vulnerability Details](#msrc-vulnerability-details)
  - [Custom Vulnerability Details](#custom-vulnerability-details)
- **[Assessments](#assessments)**
  - [Vulnerability Status](#vulnerability-status)
  - [Vulnerability Keywords](#vulnerability-keywords)
- **[Security Advisory Matching](#security-advisory-matching)**
  - [GHSA Vulnerability Details](#ghsa-vulnerability-details)
  - [CERT-FR Advisor Details](#cert-fr-advisor-details)
  - [CERT-SEI Advisor Details](#cert-sei-advisor-details)
  - [CERT-EU Advisor Details](#cert-eu-advisor-details)
- **[Vulnerability Prioritization](#vulnerability-prioritization)**
  - [EOL Date](#eol-date)
  - [EPSS Enrichment](#epss-enrichment)
  - [KEV Enrichment](#kev-enrichment)
- **[Inventory Post Processing](#inventory-post-processing)**
  - [Vulnerability Status Post Processing](#vulnerability-status-post-processing)
  - [Vulnerability Filtering](#vulnerability-filtering)
  - [Inventory Validation](#inventory-validation)
- **[Reporting](#reporting)**
  - [Vulnerability Assessment Dashboard](#vulnerability-assessment-dashboard)
- **[Standalone](#standalone)**
  - [Advisor periodic](#advisor-periodic)


## POM Configuration

The enrichment configuration is part of the `ae-inventory-enrichment-plugin` configuration in the Maven POM.
An example configuration with all available enrichment steps is provided below.

<details>

<summary>Click to show the full POM configuration with all configuration parameters</summary>

```xml
<plugins>
    <plugin>
        <groupId>com.metaeffekt.artifact.analysis</groupId>
        <artifactId>ae-inventory-enrichment-plugin</artifactId>
        <version>${ae.artifact.analysis.version}</version>

        <executions>
            <execution>
                <id>enrich-inventory</id>
                <goals>
                    <goal>enrich-inventory</goal>
                </goals>

                <configuration>
                    <!-- General Configuration -->
                    <mirrorDirectory>${database.path}</mirrorDirectory>

                    <inventoryInputFile>${inventory.path}</inventoryInputFile>
                    <inventoryOutputFile>${inventory.path}-result.xlsx</inventoryOutputFile>
                    <intermediateInventoriesDirectory>${inventory.path}/intermediate-inventories</intermediateInventoriesDirectory>

                    <writeIntermediateInventories>true</writeIntermediateInventories>
                    <storeIntermediateStepsInInventoryInfo>true</storeIntermediateStepsInInventoryInfo>

                    <!-- resume the pipeline at a specific step by its id -->
                    <!--<resumeAtEnrichment></resumeAtEnrichment>-->

                    <!-- Security Policy Configuration -->
                    <!--<securityPolicy></securityPolicy>-->
                    <!--<securityPolicyFile></securityPolicyFile>-->


                    <!-- Product Identification -->
                    <cpeDerivationEnrichment>
                      <maxCorrelatedCpePerArtifact>2147483647</maxCorrelatedCpePerArtifact>
                      <!-- <requireSecondaryIndicationTermsLimiters/> --> <!-- type: List -->
                      <addDetailedMatchingInformation>false</addDetailedMatchingInformation>
                    </cpeDerivationEnrichment>
                    
                    <correlationYamlEnrichment>
                      <yamlFiles>
                        <!-- <file>...</file> -->
                      </yamlFiles>
                    </correlationYamlEnrichment>
                    
                    <!-- Vulnerability Matching -->
                    <nvdMatchCveFromCpeEnrichment/>
                    
                    <msVulnerabilitiesByProductEnrichment/>
                    
                    <ghsaVulnerabilitiesEnrichment>
                      <maven>false</maven>
                      <packagist>false</packagist>
                      <rubygems>false</rubygems>
                      <githubactions>false</githubactions>
                      <pypi>false</pypi>
                      <purl_type_swift>false</purl_type_swift>
                      <go>false</go>
                      <hex>false</hex>
                      <npm>false</npm>
                      <crates_io>false</crates_io>
                      <pub>false</pub>
                      <nuget>false</nuget>
                      <githubReviewed>false</githubReviewed>
                    </ghsaVulnerabilitiesEnrichment>
                    
                    <customVulnerabilitiesFromCpeEnrichment/>
                    
                    <!-- Vulnerability Details Filling -->
                    <nvdCveFillDetailsEnrichment/>
                    
                    <msrcAdvisorFillDetailsEnrichment/>
                    
                    <customVulnerabilitiesFillDetailsEnrichment>
                      <vulnerabilityFiles>
                        <!-- <file>...</file> -->
                      </vulnerabilityFiles>
                    </customVulnerabilitiesFillDetailsEnrichment>
                    
                    <!-- Assessments -->
                    <vulnerabilityStatusEnrichment>
                      <statusFiles>
                        <!-- <file>...</file> -->
                      </statusFiles>
                      <additionalStatus>
                        <!-- <status>...</status> -->
                      </additionalStatus>
                      <activeLabels>
                        <!-- <activeLabel>...</activeLabel> -->
                      </activeLabels>
                      <failOnValidationErrors>false</failOnValidationErrors>
                      <failOnAmbiguousMatchingInformation>false</failOnAmbiguousMatchingInformation>
                      <debugMatchingCriteria>false</debugMatchingCriteria>
                    </vulnerabilityStatusEnrichment>
                    
                    <vulnerabilityKeywordsEnrichment>
                      <yamlFiles>
                        <!-- <file>...</file> -->
                      </yamlFiles>
                      <activeLabels>
                        <!-- <activeLabel>...</activeLabel> -->
                      </activeLabels>
                      <failOnValidationErrors>false</failOnValidationErrors>
                    </vulnerabilityKeywordsEnrichment>
                    
                    <!-- Security Advisory Matching -->
                    <ghsaAdvisorFillDetailsEnrichment/>
                    
                    <certFrAdvisorEnrichment/>
                    
                    <certSeiAdvisorEnrichment/>
                    
                    <certEuAdvisorEnrichment/>
                    
                    <!-- Vulnerability Prioritization -->
                    <eolEnrichment>
                      <warningThresholdDaysSupport>180</warningThresholdDaysSupport>
                      <warningThresholdDaysExtendedSupport>180</warningThresholdDaysExtendedSupport>
                    </eolEnrichment>
                    
                    <epssEnrichment/>
                    
                    <kevEnrichment/>
                    
                    <!-- Inventory Post Processing -->
                    <vulnerabilityStatusPostProcessingEnrichment/>
                    
                    <vulnerabilityFilterEnrichment>
                      <!-- <vulnerabilityIncludeFilter/> --> <!-- type: String -->
                      <!-- <vulnerabilityIncludeFilterAttribute/> --> <!-- type: FilterAttribute -->
                    </vulnerabilityFilterEnrichment>
                    
                    <inventoryValidationEnrichment>
                      <failOnValidationErrors>false</failOnValidationErrors>
                      <addAsCorrelationWarnings>true</addAsCorrelationWarnings>
                      <!-- <additionalCpeIsNotEffectiveInventoryValidator/> --> <!-- type: AdditionalCpeIsNotEffectiveInventoryValidator -->
                      <!-- <multipleArtifactsAndVersionsOnVulnerabilityInventoryValidator/> --> <!-- type: MultipleArtifactsAndVersionsOnVulnerabilityInventoryValidator -->
                      <!-- <artifactAndCpeVersionsDifferGreatlyInventoryValidator/> --> <!-- type: ArtifactAndCpeVersionsDifferGreatlyInventoryValidator -->
                      <!-- <vulnerabilityInvalidNameValidator/> --> <!-- type: VulnerabilityInvalidNameValidator -->
                      <additionalValidators>
                        <!-- <validator>...</validator> -->
                      </additionalValidators>
                    </inventoryValidationEnrichment>
                    
                    <!-- Reporting -->
                    <vulnerabilityAssessmentDashboardEnrichment>
                      <maximumVulnerabilitiesPerDashboardCount>2147483647</maximumVulnerabilitiesPerDashboardCount>
                      <!-- <vulnerabilityIncludeFilter/> --> <!-- type: String -->
                      <!-- <vulnerabilityIncludeFilterAttribute/> --> <!-- type: FilterAttribute -->
                      <maximumCpeForTimelinesPerVulnerability>2147483647</maximumCpeForTimelinesPerVulnerability>
                      <maximumVulnerabilitiesPerTimeline>2147483647</maximumVulnerabilitiesPerTimeline>
                      <maximumVersionsPerTimeline>2147483647</maximumVersionsPerTimeline>
                      <maximumTimeSpentOnTimelines>2147483647</maximumTimeSpentOnTimelines>
                      <maximumTimeSpentPerTimeline>2147483647</maximumTimeSpentPerTimeline>
                      <vulnerabilityTimelinesGlobalEnabled>true</vulnerabilityTimelinesGlobalEnabled>
                      <vulnerabilityTimelineHideIrrelevantVersions>true</vulnerabilityTimelineHideIrrelevantVersions>
                      <failOnVulnerabilityWithoutSpecifiedRisk>true</failOnVulnerabilityWithoutSpecifiedRisk>
                      <failOnUnreviewedAdvisories>true</failOnUnreviewedAdvisories>
                      <!-- <svgDirectory/> --> <!-- type: File -->
                      <vulnerabilitySvgChartInterpolationMethod>BASE_METRICS</vulnerabilitySvgChartInterpolationMethod>
                      <detailLevels>
                        <!-- <level>...</level> -->
                      </detailLevels>
                      <failOnUnreviewedAdvisoriesTypes>[]</failOnUnreviewedAdvisoriesTypes>
                      <!-- <outputDashboardFile/> --> <!-- type: File -->
                    </vulnerabilityAssessmentDashboardEnrichment>

                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

</details>

<details>

<summary>Click to show the shortened POM configuration</summary>

```xml
<plugins>
    <plugin>
        <groupId>com.metaeffekt.artifact.analysis</groupId>
        <artifactId>ae-inventory-enrichment-plugin</artifactId>
        <version>${ae.artifact.analysis.version}</version>

        <executions>
            <execution>
                <id>enrich-inventory</id>
                <goals>
                    <goal>enrich-inventory</goal>
                </goals>

                <configuration>
                    <!-- General Configuration -->
                    <mirrorDirectory>${database.path}</mirrorDirectory>

                    <inventoryInputFile>${inventory.path}</inventoryInputFile>
                    <inventoryOutputFile>${inventory.path}-result.xlsx</inventoryOutputFile>
                    <intermediateInventoriesDirectory>${inventory.path}/intermediate-inventories</intermediateInventoriesDirectory>

                    <writeIntermediateInventories>true</writeIntermediateInventories>
                    <storeIntermediateStepsInInventoryInfo>true</storeIntermediateStepsInInventoryInfo>

                    <!-- resume the pipeline at a specific step by its id -->
                    <!--<resumeAtEnrichment></resumeAtEnrichment>-->

                    <!-- Security Policy Configuration -->
                    <!--<securityPolicy></securityPolicy>-->
                    <!--<securityPolicyFile></securityPolicyFile>-->


                    <!-- Product Identification -->
                    <cpeDerivationEnrichment/>
                    <correlationYamlEnrichment/>
                    
                    <!-- Vulnerability Matching -->
                    <nvdMatchCveFromCpeEnrichment/>
                    <msVulnerabilitiesByProductEnrichment/>
                    <ghsaVulnerabilitiesEnrichment/>
                    <customVulnerabilitiesFromCpeEnrichment/>
                    
                    <!-- Vulnerability Details Filling -->
                    <nvdCveFillDetailsEnrichment/>
                    <msrcAdvisorFillDetailsEnrichment/>
                    <customVulnerabilitiesFillDetailsEnrichment/>
                    
                    <!-- Assessments -->
                    <vulnerabilityStatusEnrichment/>
                    <vulnerabilityKeywordsEnrichment/>
                    
                    <!-- Security Advisory Matching -->
                    <ghsaAdvisorFillDetailsEnrichment/>
                    <certFrAdvisorEnrichment/>
                    <certSeiAdvisorEnrichment/>
                    <certEuAdvisorEnrichment/>
                    
                    <!-- Vulnerability Prioritization -->
                    <eolEnrichment/>
                    <epssEnrichment/>
                    <kevEnrichment/>
                    
                    <!-- Inventory Post Processing -->
                    <vulnerabilityStatusPostProcessingEnrichment/>
                    <vulnerabilityFilterEnrichment/>
                    <inventoryValidationEnrichment/>
                    
                    <!-- Reporting -->
                    <vulnerabilityAssessmentDashboardEnrichment/>

                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

</details>

---

# Product Identification

A challenge for the vulnerability matching is that every vulnerability and security advisory provider uses different
formats and methods of identifying products and versions in their knowledge database.
A couple of examples for actual product identification methods are:

- The [National Vulnerability Database (NVD)](https://nvd.nist.gov/vuln)
  uses the [Common Platform Enumeration (CPE)](https://cpe.mitre.org/specification) to identify products,
- [Microsoft Security Response Center (MSRC)](https://www.microsoft.com/en-us/msrc)
  uses a numeric registry with a number for each product and version,
- [GitHub Security Advisories (GHSA)](https://github.com/advisories)
  and others use [Package URLs (PURLs)](https://github.com/package-url/purl-spec),
- [End Of Life](https://endoflife.date) uses unique string identifiers for each product,
- and so on.

This diversity of product identifiers is not represented in the initial software component inventory.
Therefore, the first step in the vulnerability matching process is to attempt to automatically derive product
identifiers from the component metadata, including artifact names, versions, and vendor information.

The following two steps are always performed to enable and improve the matching accuracy:

## CPE URI derivation

`cpe-derived` / `cpeDerivationEnrichment` / `cpe-derivation`

<details>

<summary>Source Code for <code>CpeDerivationEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final AtomicInteger progress = new AtomicInteger(0);

this.cpeDerivationUtilities.setConfiguration(this.configuration);

final List<Artifact> artifacts = inventory.getArtifacts();
final Map<Artifact, Long> startTimes = new HashMap<>();

for (final Artifact artifact : artifacts) {
    if (!isValidForEnrichment(artifact)) {
        LOG.info("Missing required information on artifact [{}], skipping CPE URI derivation", artifact.getId());

        new InventoryWarnings(inventory).addArtifactWarning(new InventoryWarningEntry<>(artifact,
                "Cannot perform CPE URI derivation, missing required information.",
                this.getEnrichmentName()
        ));
        continue;
    }

    super.executor.submit(() -> {
        final int currentElement = progress.incrementAndGet();
        if (currentElement % 100 == 0 && currentElement > 0) {
            LOG.info("Deriving CPE URIs for artifact [{} / {}]", currentElement, inventory.getArtifacts().size());
        }

        synchronized (startTimes) {
            startTimes.put(artifact, System.currentTimeMillis());
        }

        this.cpeDerivationUtilities.deriveCpeUris(inventory, artifact);

        synchronized (startTimes) {
            startTimes.remove(artifact);
        }
    });
}

final TimerTask checkArtifactTimerTask = new TimerTask() {
    @Override
    public void run() {
        final long currentTime = System.currentTimeMillis();
        synchronized (startTimes) {
            final List<Map.Entry<Artifact, Long>> longRunningArtifacts = startTimes.entrySet().stream()
                    .filter(e -> currentTime - e.getValue() >= 30000)
                    .sorted((o1, o2) -> o2.getValue().compareTo(o1.getValue()))
                    .collect(Collectors.toList());
            if (!longRunningArtifacts.isEmpty()) {
                LOG.warn("CPE URI derivation is taking longer than 30 seconds for [{}] artifacts: {}", longRunningArtifacts.size(), longRunningArtifacts.stream().map(Map.Entry::getKey).map(Artifact::getId).collect(Collectors.joining(", ")));
            }
        }
    }
};

final Timer checkArtifactTimer = new Timer();
checkArtifactTimer.schedule(checkArtifactTimerTask, 30000, 30000);

super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Interrupted while waiting for CPE URI derivation to finish", e);
}

checkArtifactTimer.cancel();
```

</details>


<p>CPE URIs are vendor-product pairs that apply to single (or sometimes to multiple) components.
In order to derive them for each artifact, the certain artifact attributes are used to search for vendors/products.
These CPEs are then appended to the <code>Derived CPE URIs</code> of the artifacts.
This step is based on the principle of allowing more false positives than false negatives, since it is more important to identify all potential vulnerabilities which can be filtered out in later steps
either manually or automatically than to potentially miss critical vulnerabilities.</p>
<p>Example:</p>
<ul>
<li>Artifact with Id=<code>gdk-pixbuf2-2.36.12</code>, Component=<code>gdk-pixbuf2</code>, Version=<code>2.36.12</code></li>
<li>derives these aliases:
<code>gdk_pixbuf, gdk_pixbuf2, gdkpixbuf2, gdkpixbuf, gdk pixbuf2, gdk-pixbuf2, gdk pixbuf, gdk-pixbuf</code></li>
<li>finding these products → vendors: <code>gdk_pixbuf -&gt; [redhat], gdkpixbuf -&gt; [gnome], gdk-pixbuf -&gt; [gnome]</code></li>
<li>which maps to these CPEs: <code>cpe:/a:gnome:gdk-pixbuf, cpe:/a:gnome:gdkpixbuf, cpe:/a:redhat:gdk_pixbuf</code></li>
</ul>

#### Configuration: CPE Derivation

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maxCorrelatedCpePerArtifact</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>requireSecondaryIndicationTermsLimiters</code></td><td><code>new ArrayList<>(Collections.singletonList(new NvdCpeApiVendorProductIndexQuery.MinTermsLimiter(60).toJson().toMap()))</code></td></tr><tr><td colspan=2>The list of terms limiters to be used for determining the secondary indication terms. If multiple are provided, they will be applied in the order they are provided. <p> Default value is: <code>[{"type":"MinTermsLimiter","minTerms":60}]</code> which uses the <code>NvdCpeApiVendorProductIndexQuery.MinTermsLimiter</code> with a minimum of 60 terms. <p> Available types can be found next to <code>NvdCpeApiVendorProductIndexQuery.TermsLimiter</code> and include: <ul>     <li><code>NvdCpeApiVendorProductIndexQuery.MinTermsLimiter</code></li>     <li><code>NvdCpeApiVendorProductIndexQuery.MaxTermsLimiter</code></li>     <li><code>NvdCpeApiVendorProductIndexQuery.TopPTermsLimiter</code></li>     <li><code>NvdCpeApiVendorProductIndexQuery.TopNTermsLimiter</code></li></td></tr><tr><td><code>addDetailedMatchingInformation</code></td><td><code>false</code></td></tr></table>



## Artifact Correlation YAML

`correlation` / `correlationYamlEnrichment` / `artifact-correlation`

<details>

<summary>Source Code for <code>ArtifactCorrelationEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
LOG.info("Performing enrichment using [{}] yaml file{} or director{}", configuration.getYamlFiles().size(), configuration.getYamlFiles().size() == 1 ? "" : "s", configuration.getYamlFiles().size() == 1 ? "y" : "ies");

for (File file : configuration.getYamlFiles()) {
    ArtifactCorrelationUtil.addYamlToInventory(inventory, file, super.getSecurityPolicyConfiguration().getJsonSchemaValidationErrorsHandling());
}
```

</details>


<details>

<summary>Source Code for <code>ArtifactCorrelationUtil.addYamlToInventory(Inventory inventory, List dataEntries)</code> </summary>

```java
if (inventory == null) {
    LOG.error("Inventory is null, canceling enrichment");
    return;
}

long totalCount = 0;
int appliedArtifacts = 0;

final List<Artifact> artifacts = inventory.getArtifacts();

for (int i = 0; i < artifacts.size(); i++) {
    final Artifact artifact = artifacts.get(i);
    final long count = dataEntries.stream()
            .filter(d -> d.affects(artifact))
            .peek(d -> d.apply(artifact, inventory))
            .count();

    totalCount += count;
    appliedArtifacts += count > 0 ? 1 : 0;

    if (i % 100 == 0 && i > 0) {
        LOG.info("[{} / {}] Applied [{}] entries to [{}] artifacts", i, artifacts.size(), totalCount, appliedArtifacts);
    }
}

LOG.info("Applied [{}] entries to [{}] artifacts", totalCount, appliedArtifacts);

CommonEnumerationUtil.distinctAndSortedWithWildcards(inventory);
```

</details>


<p>The automatic <code>com.metaeffekt.artifact.enrichment.vulnerability.CpeDerivationEnrichment</code>
and other automatic product identifier matching algorithms have no way of reliably and correctly performing their
task perfectly in all cases for several reasons
(such as spelling mistakes in the product data on either side, differing naming conventions, multiple products with the same name, and so on).</p>
<p>To improve the quality of these steps and to enable matching via Microsoft, EOL and other data sources,
a custom data format is used (Correlation Files) to manually map the component metadata to the product identifiers.
More details on the <code>artifact-data</code> schema <a href="https://metaeffekt.com/schema/artifact-analysis">can be found here</a>.</p>

#### Configuration: Artifact Correlation

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>yamlFiles</code></td><td><code>new ArrayList<>()</code></td></tr></table>



---

# Vulnerability Matching

The next phase represents the main part of the inventory enrichment process, responsible for the actual matching process
of finding vulnerabilities from various sources to the products identified in the earlier steps.

It is important to note that _only the vulnerabilities themselves_ are identified during this phase, excluding any
vulnerability metadata such as descriptions or CVSS vectors.
This distinction between finding identifiers and adding details is made to allow for adding those details after any
amount of vulnerability identification steps exactly once,
instead of performing them after each one individually.

Each of the steps below uses a different method to identify vulnerabilities, since each source uses different formats
and methods to identify vulnerabilities.
But all of them have in common that they identify vulnerabilities based on the products present in the inventory.

## NVD CVE from CPE

`nvd-cve-from-cpe` / `nvdMatchCveFromCpeEnrichment` / `vulnerabilities-from-cpe`

<details>

<summary>Source Code for <code>NvdVulnerabilitiesFromCpeEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final AtomicInteger progress = new AtomicInteger(0);

final List<Artifact> artifacts = inventory.getArtifacts();
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
for (final Artifact artifact : artifacts) {
    super.executor.submit(() -> {
        final int currentElement = progress.incrementAndGet();
        if (currentElement % 100 == 0 && currentElement > 0) {
            log.info("Collecting CVE from CPE for artifact [{} / {}]", currentElement, inventory.getArtifacts().size());
        }

        super.enrichVulnerabilitiesForCpe(vInventory, artifact);
    });
}

super.executor.setSize(16);
super.executor.setLogEveryPercent(10);
super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to join executor while waiting for NVD CVE from CPE enrichment to finish.", e);
}

vInventory.writeBack();
```

</details>


<details>

<summary>Source Code for <code>VulnerabilitiesFromCpeEnrichment.enrichVulnerabilitiesForCpe(VulnerabilityContextInventory vInventory, Artifact artifact)</code> </summary>

```java
final Map<Cpe, List<Vulnerability>> vulnerabilitiesForCpes = this.queryVulnerabilitiesForArtifact(vInventory, artifact);

// collect matched cpes
final Set<String> matchedCpes = new HashSet<>();
vulnerabilitiesForCpes.keySet().forEach(cpe -> matchedCpes.add(CommonEnumerationUtil.toCpe22UriOrFallbackToCpe23FS(cpe)));

// add matched cpes as field in the artifact
if (!matchedCpes.isEmpty()) {
    artifact.set(InventoryAttribute.MATCHED_CPES,
            matchedCpes.stream().filter(cpe -> cpe != null && !cpe.equals("null")).collect(Collectors.joining(", ")));
} else {
    artifact.set(InventoryAttribute.MATCHED_CPES, null);
}
```

</details>


<details>

<summary>Source Code for <code>VulnerabilitiesFromCpeEnrichment.queryVulnerabilitiesForArtifact(VulnerabilityContextInventory vInventory, Artifact artifact)</code> </summary>

```java
// represents return value: collects vulnerabilities for artifact
final Map<Cpe, List<Vulnerability>> aggregatedVulnerabilitiesForCpes = new LinkedHashMap<>();

// only used for tracking the amount of vulnerabilities for the config parameter
final Set<String> aggregatedVulnerabilities = new HashSet<>();

// The aggregation of CPEs is often version agnostic. This is why a specification on the artifact version is
// required below.
final List<Cpe> artifactCpes = CommonEnumerationUtil.parseEffectiveCpe(artifact);

// query CVEs for CPE with matching version
for (Cpe cpe : artifactCpes) {

    try {
        final Optional<Cpe> optionalQueryCpe = deriveQueryCpe(vInventory, this.getEnrichmentName(), artifact, cpe);
        if (!optionalQueryCpe.isPresent()) {
            continue;
        }
        final Cpe queryCpe = optionalQueryCpe.get();

        final Map<Vulnerability, VulnerableSoftwareVersionRangeCpe> vulnerabilitiesWithSources = getVulnerabilityQuery().findVulnerabilitiesByFlatAffectedConfigurationRetainSource(queryCpe);
        final List<Vulnerability> vulnerabilitiesForCpes = vulnerabilitiesWithSources.keySet().stream()
                .map(AmbDataClass::getId)
                .map(vInventory::findOrCreateVulnerabilityByName)
                .collect(Collectors.toList());

        if (!vulnerabilitiesForCpes.isEmpty()) {
            for (Vulnerability vulnerability : vulnerabilitiesForCpes) {
                final VulnerableSoftwareVersionRangeCpe affectedConfiguration = vulnerabilitiesWithSources.get(vulnerability);
                final DataSourceIndicator matchingSource = DataSourceIndicator.cpe(artifact, this.getVulnerabilitySource(), queryCpe, affectedConfiguration != null ? affectedConfiguration.toString() : null);
                vulnerability.addMatchingSource(matchingSource);
            }
        }

        aggregatedVulnerabilities.addAll(vulnerabilitiesForCpes.stream().map(Vulnerability::getId).collect(Collectors.toSet()));
        aggregatedVulnerabilitiesForCpes.put(cpe, vulnerabilitiesForCpes);

        if (aggregatedVulnerabilities.size() > configuration.getMaxCorrelatedVulnerabilitiesPerArtifact()) {
            break;
        }
    } catch (Exception e) {
        throw new RuntimeException("Failed to query vulnerabilities for artifact [" + artifact.getId() + "] on CPE [" + CommonEnumerationUtil.toCpe22UriOrFallbackToCpe23FS(cpe) + "]: " + e.getMessage(), e);
    }
}

if (aggregatedVulnerabilities.size() > configuration.getMaxCorrelatedVulnerabilitiesPerArtifact()) {
    LOG.warn("Found [{}] vulnerabilities for artifact [{}] but only the first [{}] will be considered.",
            aggregatedVulnerabilities.size(), artifact.getId(), configuration.getMaxCorrelatedVulnerabilitiesPerArtifact());

    vInventory.getInventoryWarnings().addArtifactWarning(new InventoryWarningEntry<>(artifact,
            "Found " + aggregatedVulnerabilities.size() + " vulnerabilities but only the first "
                    + configuration.getMaxCorrelatedVulnerabilitiesPerArtifact() + " will be considered.",
            this.getEnrichmentName()
    ));

    int count = 0;
    boolean clearAll = false;
    for (Map.Entry<Cpe, List<Vulnerability>> entry : aggregatedVulnerabilitiesForCpes.entrySet()) {
        final List<Vulnerability> vulnerabilities = entry.getValue();
        count += vulnerabilities.size();

        if (count > configuration.getMaxCorrelatedVulnerabilitiesPerArtifact()) {
            if (clearAll) {
                vulnerabilities.clear();
            } else {
                final int removeCount = count - configuration.getMaxCorrelatedVulnerabilitiesPerArtifact();
                vulnerabilities.subList(vulnerabilities.size() - removeCount, vulnerabilities.size()).clear();
                clearAll = true;
            }
        }
    }
}

final VulnerabilityTypeIdentifier<?> vulnerabilityIdentifier = this.getVulnerabilityQuery().getVulnerabilityType();
for (List<Vulnerability> vulnerabilities : aggregatedVulnerabilitiesForCpes.values()) {
    for (Vulnerability vulnerability : vulnerabilities) {
        vulnerability.setSourceIdentifier(vulnerabilityIdentifier);
    }
}

return aggregatedVulnerabilitiesForCpes;
```

</details>


<p>The NVD CVE from CPE enrichment step is responsible for linking vulnerabilities from the National Vulnerability
Database (NVD) to specific products (artifacts) identified in an inventory.
The process works by utilizing Common Platform Enumerations (CPEs) to identify which vulnerabilities (CVE entries)
affect each product based on its known CPEs.</p>

<b>What Happens During This Step</b>
<p>When this step begins, the system processes each product (artifact) in the inventory by first identifying its CPEs.
These CPEs are derived using the product&#39;s attributes and version information.
In case the CPE version does not match the artifact version, an algorithm is used to combine them in a meaningful way
or pick one of the two as the query version.
The CPEs are then used as queries to look up vulnerabilities from the NVD:
For each product, the system performs a query to retrieve a list of vulnerabilities that specifically match the
product&#39;s CPE and version.</p>
Once the query is executed, the system retrieves vulnerabilities and performs a secondary, more detailed version
comparison match against the product/CPE version to ensure only accurate matches are considered.
Along with this, the system also stores the CPEs and other data like version ranges that led to each vulnerability
match as metadata for the product, allowing for traceability in later steps.</p>
<p>Finally, all identified vulnerabilities are stored in the inventory, linked to their respective products.</p>

#### Configuration: Vulnerabilities from CPE

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maxCorrelatedVulnerabilitiesPerArtifact</code></td><td><code>Integer.MAX_VALUE</code></td></tr></table>



## MSRC Vulnerabilities by Products

`msrc-cve-from-product` / `msVulnerabilitiesByProductEnrichment` / `msrc-vulnerabilities-by-product`

<details>

<summary>Source Code for <code>MsrcVulnerabilitiesByProductEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final MsrcAdvisorIndexQuery msrcAdvisorQuery = this.msrcAdvisorQuery.get();
final MsrcKbChainIndexQuery msrcKbChainQuery = this.msrcKbChainQuery.get();

final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

for (final Artifact artifact : inventory.getArtifacts()) {

    // find Microsoft product from artifact
    final String artifactMsProductIdOrName = artifact.get(InventoryAttribute.MS_PRODUCT_ID.getKey());
    if (artifactMsProductIdOrName == null) {
        continue;
    }

    final List<String> productList = Arrays.stream(artifactMsProductIdOrName.split(", ")).map(String::trim).collect(Collectors.toList());

    if (productList.size() >= 2) {
        LOG.warn("Multiple products found for artifact [{}], usually an artifact is only affected by a single product. Products: [{}]", artifact.getId(), artifactMsProductIdOrName);
    }

    for (String msProductIdOrName : productList) {
        final MsrcProduct msrcProduct = findProductFromIdOrName(msProductIdOrName);
        if (msrcProduct == null) {
            LOG.error("Skipping over MS Product ID [{}] from Artifact [{}] as it cannot be found in local index, make sure that the ID is correct", msProductIdOrName, artifact.getId());
            continue;
        }

        // extract KB Ids from artifact
        final Set<String> appliedMsKbIdentifiers = extractKbIdentifiers(artifact);


        // find Microsoft vulnerabilities affected by product
        final List<String> msVulnerabilitiesOnProductFromAdvisors = msrcAdvisorQuery.findByProduct(msrcProduct).stream()
                .map(MsrcAdvisorEntry::getId)
                .map(id -> id.replace("MSRC-", ""))
                .collect(Collectors.toList());
        final List<String> msVulnerabilitiesOnProductFromKbChains = msrcKbChainQuery.findVulnerabilitiesByProductId(msrcProduct.getId());

        final Set<String> allPotentialVulnerabilities = new HashSet<>();
        allPotentialVulnerabilities.addAll(msVulnerabilitiesOnProductFromAdvisors);
        allPotentialVulnerabilities.addAll(msVulnerabilitiesOnProductFromKbChains);


        msrcKbChainQuery.collectSupersedingKbIdentifiers(allPotentialVulnerabilities, msProductIdOrName, appliedMsKbIdentifiers);

        final Set<String> msVulnerabilitiesNotFixed = new HashSet<>();
        final Set<String> msAdvisoriesNotFixed = new HashSet<>();
        final Set<String> msVulnerabilitiesAndAdvisoriesFixed = new HashSet<>();

        for (String vulnerabilityId : allPotentialVulnerabilities) {
            final boolean isFixed = msrcKbChainQuery.isVulnerabilityFixed(vulnerabilityId, msrcProduct.getId(), appliedMsKbIdentifiers);

            if (isFixed) {
                msVulnerabilitiesAndAdvisoriesFixed.add(vulnerabilityId);
            } else {
                if (vulnerabilityId.startsWith("ADV")) {
                    msAdvisoriesNotFixed.add(vulnerabilityId);
                } else {
                    msVulnerabilitiesNotFixed.add(vulnerabilityId);
                }
            }
        }


        // convert to vulnerability instances
        final DataSourceIndicator msrcProductDataSourceIndicator = DataSourceIndicator.msrcProduct(artifact, msrcProduct, appliedMsKbIdentifiers);

        for (String v : msVulnerabilitiesNotFixed) {
            vInventory.findOrCreateVulnerabilityByName(v)
                    .addMatchingSource(msrcProductDataSourceIndicator);
        }

        for (String v : msAdvisoriesNotFixed) {
            vInventory.findOrCreateAdvisoryEntryByName(v, MsrcAdvisorEntry::new)
                    .addMatchingSource(msrcProductDataSourceIndicator);
        }

        for (String v : msVulnerabilitiesAndAdvisoriesFixed) {
            vInventory.findOrCreateWithoutAddingVulnerabilityByName(v)
                    .manuallyAffectsArtifact(InventoryAttribute.VULNERABILITIES_FIXED_BY_KB, artifact);
        }


        artifact.set(InventoryAttribute.MS_SUPERSEDED_KB_IDENTIFIER.getKey(), String.join(", ", appliedMsKbIdentifiers));

        LOG.info("Artifact [{}] with product [{}] ([{}]) and [{}] KB has [{} vulnerabilities] [{} advisories] [{} fixed by KB] from [{} & {} -> {}] vulnerabilities/advisories",
                artifact.getId(), msProductIdOrName, msrcProduct.getId(), appliedMsKbIdentifiers.size(),
                msVulnerabilitiesNotFixed.size(), msAdvisoriesNotFixed.size(), msVulnerabilitiesAndAdvisoriesFixed.size(),
                msVulnerabilitiesOnProductFromAdvisors.size(), msVulnerabilitiesOnProductFromKbChains.size(), allPotentialVulnerabilities.size());

    }
}

vInventory.writeBack();
```

</details>


<p>The MSRC (Microsoft Security Response Center) Vulnerabilities by Products enrichment step is responsible for identifying vulnerabilities affecting Microsoft products within an inventory.
This process works by linking artifacts (products) to their associated vulnerabilities using Microsoft’s product and advisory databases.
The enrichment step uses various Microsoft data sources, including product IDs, advisories, and Knowledge Base (KB) chains, to ensure that relevant vulnerabilities, based on the product and its applied updates, are considered.</p>
<b>What Happens During This Step</b>
<p>When this step begins, the system first processes each artifact in the inventory to identify those associated with Microsoft products.
It does this by checking for a Microsoft Product ID or name within the artifact&#39;s metadata.
If an artifact contains such information, it is further analyzed to determine the specific Microsoft product it represents.
Once the product is identified, the system extracts any relevant KB identifiers from the artifact.
These KB identifiers represent updates or patches applied to the product and are relevant when determining whether a given vulnerability has already been resolved and should not be added to the inventory.</p>
<p>The system then queries the Microsoft advisory data source to retrieve potential vulnerabilities for the product.
First, it queries Microsoft advisories using the MSRC advisory index to find vulnerabilities linked to the product.
This part is simple, as advisories directly contain the affected products, with them being a unique numerical id.</p>
<p>Now the system can check these for any superseding KB identifiers, making sure that if the product has received newer updates, the patched vulnerabilities are filtered out.
This is done by following the KB chain, which is a list of KBs that are superseded by other KBs.
If any of the superseding KBs are found in the applied KB identifiers, the vulnerability is considered fixed.
Using this, vulnerabilities are classified into three categories:
those that remain applicable, those that are applicable advisories (Microsoft-internal <code>ADV</code>-identifiers), and those that have been fixed by the applied KB updates.</p>
<p>For applicable vulnerabilities, the system links them directly to the product (artifact) and stores them in the inventory.
For fixed vulnerabilities, the system marks them as resolved and notes the KB that addressed them.</p>



## GHSA Vulnerabilities

`ghsa-cve` / `ghsaVulnerabilitiesEnrichment` / `ghsa-vulnerabilities`

<details>

<summary>Source Code for <code>GhsaVulnerabilitiesEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final List<GhsaArtifactVulnerabilityMatcher> matchers = configuration.buildMatchers(ghsaAdvisorQuery.get());

final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

LOG.info("Matching GHSA vulnerabilities for [{}] artifacts using [{}] matcher{}", inventory.getArtifacts().size(), matchers.size(), matchers.size() > 1 ? "s" : "");

for (final Artifact artifact : inventory.getArtifacts()) {
    for (GhsaArtifactVulnerabilityMatcher matcher : matchers) {
        if (matcher.mayMatch(artifact)) {
            final Map<GhsaAdvisorEntry, DataSourceIndicator> ghsaAdvisorEntries = matcher.match(artifact);

            // differentiate entries based on whether they have CVEs or not.
            // we are mainly interested in the entries that have vulnerabilities in this step
            for (Map.Entry<GhsaAdvisorEntry, DataSourceIndicator> matchedEntry : ghsaAdvisorEntries.entrySet()) {
                final GhsaAdvisorEntry ghsaAdvisorEntry = matchedEntry.getKey();
                final DataSourceIndicator dataSourceIndicator = matchedEntry.getValue();

                final Set<String> entryCves = ghsaAdvisorEntry.getReferencedVulnerabilities(VulnerabilityTypeStore.CVE);
                if (entryCves.isEmpty()) {
                    vInventory.add(vInventory.findOrCreateAdvisoryEntryByName(ghsaAdvisorEntry.getId(), GhsaAdvisorEntry::new)
                            .addMatchingSource(dataSourceIndicator));
                } else {
                    for (String entryCve : entryCves) {
                        final Vulnerability vulnerability = vInventory
                                .findOrCreateVulnerabilityByName(entryCve)
                                .addMatchingSource(dataSourceIndicator);
                        vulnerability.setSourceIdentifier(VulnerabilityTypeStore.CVE);
                        vInventory.add(vulnerability);
                    }
                }
            }
        }
    }
}

vInventory.writeBack(true);
```

</details>


#### Configuration: GHSA Vulnerabilities

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maven</code></td><td><code>false</code></td></tr><tr><td><code>packagist</code></td><td><code>false</code></td></tr><tr><td><code>rubygems</code></td><td><code>false</code></td></tr><tr><td><code>githubactions</code></td><td><code>false</code></td></tr><tr><td><code>pypi</code></td><td><code>false</code></td></tr><tr><td><code>purl_type_swift</code></td><td><code>false</code></td></tr><tr><td><code>go</code></td><td><code>false</code></td></tr><tr><td><code>hex</code></td><td><code>false</code></td></tr><tr><td><code>npm</code></td><td><code>false</code></td></tr><tr><td><code>crates_io</code></td><td><code>false</code></td></tr><tr><td><code>pub</code></td><td><code>false</code></td></tr><tr><td><code>nuget</code></td><td><code>false</code></td></tr><tr><td><code>githubReviewed</code></td><td><code>false</code></td></tr></table>



## Custom Vulnerabilities from CPE

`custom-vulnerabilities-from-cpe` / `customVulnerabilitiesFromCpeEnrichment` / `vulnerabilities-from-cpe`

<details>

<summary>Source Code for <code>CustomVulnerabilitiesFromCpeEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
vulnerabilityQuery = new CustomVulnerabilityIndexQuery(getConfiguration().getVulnerabilityFiles());

final List<Artifact> artifacts = inventory.getArtifacts();
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
for (int i = 0, artifactsSize = artifacts.size(); i < artifactsSize; i++) {
    final Artifact artifact = artifacts.get(i);

    int finalI = i;
    super.executor.submit(() -> {
        LOG.info("Collecting vulnerabilities from CPE for artifact [{} / {}] [{}: {} {}]", finalI + 1, inventory.getArtifacts().size(), artifact.getId(), artifact.get(Artifact.Attribute.COMPONENT), artifact.get(Artifact.Attribute.VERSION));

        super.enrichVulnerabilitiesForCpe(vInventory, artifact);
    });
}

super.executor.setSize(16);
super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Interrupted while waiting for custom vulnerability enrichment to finish.", e);
}
```

</details>


#### Configuration: Vulnerabilities from CPE

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maxCorrelatedVulnerabilitiesPerArtifact</code></td><td><code>Integer.MAX_VALUE</code></td></tr></table>



---

# Vulnerability Details Filling

As mentioned in the [Vulnerability Matching](#vulnerability-matching) section, only the vulnerabilities themselves are
identified during the matching process.
This phase is responsible for adding the details to the vulnerabilities identified in the previous phase.
This includes details like descriptions, CVSS vectors, references, and more.

The steps in this phase might have to be run multiple times in your pipeline, depending on whether you use the
assessments steps or similar steps that require the details to be present, but may add new vulnerabilities to the
inventory that then again require details to be filled.

## NVD Vulnerability Details

`details-vulnerability-nvd` / `nvdCveFillDetailsEnrichment` / `details-filling-nvd`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## MSRC Vulnerability Details

`details-vulnerability-msrc` / `msrcAdvisorFillDetailsEnrichment` / `details-filling-msrc`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## Custom Vulnerability Details

`details-vulnerability-custom` / `customVulnerabilitiesFillDetailsEnrichment` / `custom-vulnerabilities-details-filling`

<details>

<summary>Source Code for <code>DetailsFillingEnrichmentCustom.performEnrichment(Inventory inventory)</code> </summary>

```java
vulnerabilityQuery = new CustomVulnerabilityIndexQuery(getConfiguration().getVulnerabilityFiles());
super.performEnrichment(inventory);
```

</details>


#### Configuration: Custom Vulnerabilities Details filling

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>vulnerabilityFiles</code></td><td><code>new ArrayList<>()</code></td></tr></table>



---

# Assessments

To allow teams of assessors to evaluate the identified vulnerabilities and security advisories,
this phase allows for injecting assessments for vulnerabilities and security advisories into the inventory.
For this, the [Assessment File format](https://metaeffekt.com/schema/artifact-analysis) is used, see the link for
more details on how to create such files.
These assessments will show up in the generated reports and dashboards.

Since this step both requires vulnerability details to be present and may add new vulnerabilities to the inventory
(void vulnerabilities), the [Vulnerability Details Filling](#vulnerability-details-filling) phase has to be run before
and after this phase.

## Vulnerability Status

`status` / `vulnerabilityStatusEnrichment` / `vulnerability-status`

<details>

<summary>Source Code for <code>VulnerabilityStatusEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final boolean logMatchingCriteriaPreviousValue = VulnerabilityStatus.LOG_MATCHING_CRITERIA;
VulnerabilityStatus.LOG_MATCHING_CRITERIA = configuration.isDebugMatchingCriteria();

try {
    LOG.info("");
    if (!configuration.getStatusFiles().isEmpty()) {
        LOG.info("Adding data from status files from:");
        configuration.getStatusFiles().stream().map(File::getAbsolutePath).map(f -> " - " + f).forEach(LOG::info);
    }
    if (!configuration.getAdditionalStatus().isEmpty()) {
        LOG.info("Adding data from [{}] additional status entries added programmatically", configuration.getAdditionalStatus().size());
    }

    final Set<VulnerabilityStatus> anyScopeStatus = configuration.readVulnerabilityStatusEntries(super.getSecurityPolicyConfiguration().getJsonSchemaValidationErrorsHandling());

    // log the status files found with metadata
    if (anyScopeStatus.isEmpty()) {
        LOG.info("No status files found in provided directories");
    } else {
        final Map<String, List<VulnerabilityStatus>> scopeStatusMap = anyScopeStatus.stream()
                .collect(Collectors.groupingBy(s -> s.getOriginYamlFile() == null ? "programmatic" : s.getOriginYamlFile().getAbsolutePath()));
        for (Map.Entry<String, List<VulnerabilityStatus>> entry : scopeStatusMap.entrySet()) {
            final List<VulnerabilityStatus> statuses = entry.getValue();
            final String filePath = entry.getKey();
            LOG.info("Found [{}] ({}) status file{} in file: {}",
                    statuses.size(),
                    statuses.stream().map(VulnerabilityStatus::getScope).distinct().map(Enum::toString).collect(Collectors.joining(", ")),
                    statuses.size() == 1 ? "" : "s", filePath);
        }
    }
    LOG.info("");

    final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
    final int vulnerabilityCountBefore = vInventory.getVulnerabilities().size();


    // filter out all INVENTORY and ARTIFACT scope entries
    final List<VulnerabilityStatus> inventoryScopeStatus = anyScopeStatus.stream()
            .filter(s -> s.isScope(VulnerabilityStatus.Scope.INVENTORY))
            .collect(Collectors.toList());
    final List<VulnerabilityStatus> artifactScopeStatus = anyScopeStatus.stream()
            .filter(s -> s.isScope(VulnerabilityStatus.Scope.ARTIFACT))
            .collect(Collectors.toList());


    // do not yet add the vulnerabilities from the status files to the inventory, as INVENTORY scope statuses should not be applied on these
    if (!inventoryScopeStatus.isEmpty()) {
        LOG.info("Found [{}] status file{} with scope [{}]", inventoryScopeStatus.size(), inventoryScopeStatus.size() == 1 ? "" : "s", VulnerabilityStatus.Scope.INVENTORY);

        for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
            addStatusEntriesForVulnerability(vInventory, inventoryScopeStatus, vulnerability, false);
        }

        // add information about the inventory scope status files to the inventory info
        final InventoryInfo info = vInventory.getInventory().findOrCreateInventoryInfo(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_KEY);

        final JSONArray statusJson = inventoryScopeStatus.stream()
                .map(VulnerabilityStatus::toJson)
                .collect(CustomCollectors.toJsonArray());

        if (info.has(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY)) {
            final JSONArray existingStatusJson = new JSONArray(info.get(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY));
            for (int i = 0; i < existingStatusJson.length(); i++) {
                statusJson.put(existingStatusJson.get(i));
            }
        }

        info.set(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY, statusJson.toString());
    }


    // all vulnerabilities from the statuses that are non-existent in the inventory will be added as 'void' status entries later
    final Map<Vulnerability, File> createdVulnerabilitySources = new HashMap<>();
    for (VulnerabilityStatus cveStatusHistory : anyScopeStatus) {
        for (String name : cveStatusHistory.getAffectedVulnerabilitiesWithoutWildcards()) {
            if (!vInventory.findVulnerabilityByName(name).isPresent()) {
                final Vulnerability vulnerability = vInventory.findOrCreateVulnerabilityByName(name);
                VulnerabilityTypeStore.get().inferSourceIdentifierFromIdIfAbsent(vulnerability);
                createdVulnerabilitySources.put(vulnerability, cveStatusHistory.getOriginYamlFile());
            }
        }
    }

    // add a matching source to all vulnerabilities that have been created by status files
    for (Map.Entry<Vulnerability, File> vulnerabilityFileEntry : createdVulnerabilitySources.entrySet()) {
        final Vulnerability vulnerability = vulnerabilityFileEntry.getKey();
        final File file = vulnerabilityFileEntry.getValue();

        vulnerability.addMatchingSource(DataSourceIndicator.assessmentStatus(file));
    }

    final int vulnerabilityCountAfter = vInventory.getVulnerabilities().size();

    LOG.info("Found [{}] status files with a total of [{}] affected vulnerabilities, applying to an inventory with [{}] vulnerabilities (merged & deduplicated total: [{}])",
            anyScopeStatus.size(), vulnerabilityCountAfter - vulnerabilityCountBefore, vulnerabilityCountBefore, vulnerabilityCountAfter);


    // iterate over remaining vulnerabilities and apply the ARTIFACT status entries
    for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
        addStatusEntriesForVulnerability(vInventory, artifactScopeStatus, vulnerability, createdVulnerabilitySources.containsKey(vulnerability));
    }

    vInventory.writeBack(true);
} finally {
    VulnerabilityStatus.LOG_MATCHING_CRITERIA = logMatchingCriteriaPreviousValue;
}
```

</details>


#### Configuration: Vulnerability Status

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>statusFiles</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>additionalStatus</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>activeLabels</code></td><td><code>new String[]{}</code></td></tr><tr><td><code>failOnValidationErrors</code></td><td><code>false</code></td></tr><tr><td><code>failOnAmbiguousMatchingInformation</code></td><td><code>false</code></td></tr><tr><td><code>debugMatchingCriteria</code></td><td><code>false</code></td></tr></table>



## Vulnerability Keywords

`vulnerability-keywords` / `vulnerabilityKeywordsEnrichment` / `vulnerability-keywords`

<details>

<summary>Source Code for <code>VulnerabilityKeywordsEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
LOG.info("Performing enrichment using [{}] yaml file{}", configuration.getYamlFiles().size(), configuration.getYamlFiles().size() == 1 ? "" : "s");

final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
final VulnerabilityKeywords keywords = configuration.makeKeywords(super.getSecurityPolicyConfiguration().getJsonSchemaValidationErrorsHandling());

for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    final List<KeywordSet> matchingKeywords = keywords.getMatching(
            vulnerability.getDescription(),
            String.join(", ", vulnerability.getCwes())
    );

    if (!matchingKeywords.isEmpty()) {
        LOG.debug("[{}] matches [{}] keyword(s): {}", vulnerability.getId(), matchingKeywords.size(), matchingKeywords.stream().map(KeywordSet::getNameScore).collect(Collectors.joining(", ")));

        final boolean anyKeywordSetHasScore = matchingKeywords.stream().anyMatch(KeywordSet::hasScore);
        final Double totalKeywordsScore = anyKeywordSetHasScore
                ? matchingKeywords.stream().filter(KeywordSet::hasScore).mapToDouble(KeywordSet::getScore).sum()
                : null;
        vulnerability.setAdditionalAttribute(InventoryAttribute.KEYWORDS_SCORE, totalKeywordsScore != null ? String.valueOf(VulnerabilityAssessmentDashboard.roundOneDecimal(totalKeywordsScore)) : null);

        final JSONArray keywordsArray = KeywordSet.toFullInformationJson(matchingKeywords);
        vulnerability.setAdditionalAttribute(InventoryAttribute.KEYWORDS, keywordsArray.toString());

        final VulnerabilityStatus status = findApplicableStatusFromKeywordSets(matchingKeywords);
        if (status != null) {
            status.appendToVulnerabilityStatus(vulnerability.getOrCreateNewVulnerabilityStatus(), configuration.getActiveLabels());
            vulnerability.getVulnerabilityStatus().applyToVulnerability(vulnerability);
        }
    }
}

vInventory.writeBack(true);
```

</details>


#### Configuration: Vulnerability Keywords

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>yamlFiles</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>activeLabels</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>addonVulnerabilityKeywords</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>failOnValidationErrors</code></td><td><code>false</code></td></tr></table>



---

# Security Advisory Matching

Once all vulnerabilities are known and have their details filled, the next phase is to match security advisories to the
vulnerabilities to support the assessment and remediation process.
For this, (as usual) each step uses a different method to identify relevant security advisories based on the
vulnerabilities and products present in the inventory.

## GHSA Vulnerability Details

`details-vulnerability-ghsa` / `ghsaAdvisorFillDetailsEnrichment` / `details-filling-ghsa`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## CERT-FR Advisor Details

`details-advisor-cert-fr` / `certFrAdvisorEnrichment` / `details-filling-advisor-cert-fr`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## CERT-SEI Advisor Details

`details-advisor-cert-sei` / `certSeiAdvisorEnrichment` / `details-filling-advisor-cert-sei`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## CERT-EU Advisor Details

`details-advisor-cert-eu` / `certEuAdvisorEnrichment` / `details-filling-advisor-cert-eu`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




---

# Vulnerability Prioritization

The final phase that adds new data to the inventory is the vulnerability prioritization information.
It adds information that allows for the prioritization of vulnerabilities based on their current exploit state,
severity, and other factors by calculating a combined priority score for each vulnerability.
This score is displayed in the generated reports and dashboards.

## EOL Date

`eol-date` / `eolEnrichment` / `eol`

<details>

<summary>Source Code for <code>EolEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
int count = 0;
final Map<String, Set<EolCycle>> matchedEolCyclesTracker = new HashMap<>();

for (Artifact artifact : inventory.getArtifacts()) {
    final Map<String, Set<EolCycle>> result = performEnrichmentOnSingleArtifact(artifact);
    if (result == null) continue;
    matchedEolCyclesTracker.putAll(result);
    count++;
}

LOG.info("Added EOL Information to [{}] artifacts for products: {}",
        count,
        matchedEolCyclesTracker.entrySet().stream().map(e -> e.getKey() + " (" + e.getValue().stream().map(EolCycle::getCycle).collect(Collectors.joining(", ")) + ")").collect(Collectors.joining(", ")));
```

</details>


<details>

<summary>Source Code for <code>EolEnrichment.performEnrichmentOnSingleArtifact(Artifact artifact)</code> </summary>

```java
if (!artifact.has(InventoryAttribute.EOL_ID.getKey())) {
    return null;
}

final String[] eolIds = artifact.get(InventoryAttribute.EOL_ID.getKey()).split(", ");
final Map<String, Set<EolCycle>> matchedEolCyclesTracker = new HashMap<>();

for (String eolId : eolIds) {
    final EolLifecycle lifecycle = this.eolIndexQuery.findCyclesByProduct(eolId);

    if (lifecycle == null || lifecycle.getCycles().isEmpty()) {
        LOG.warn("No EOL information found for product: {}", eolId);
        continue;
    }

    final String cycleQueryVersion = ObjectUtils.firstNonNull(
            artifact.get(InventoryAttribute.EOL_OVERWRITE_CYCLE_QUERY_VERSION),
            artifact.get(Artifact.Attribute.VERSION)
    );
    final String latestVersionQueryVersion = ObjectUtils.firstNonNull(
            artifact.get(InventoryAttribute.EOL_OVERWRITE_LATEST_VERSION_QUERY_VERSION),
            artifact.get(Artifact.Attribute.VERSION)
    );

    final EolCycle currentCycle = lifecycle.findCycleFromVersion(cycleQueryVersion);

    if (currentCycle == null) {
        if (cycleQueryVersion == null) {
            LOG.warn("Lifecycle found for product [{}], artifact query version [{}] [{}] is null on artifact [{}]", eolId, cycleQueryVersion, latestVersionQueryVersion, artifact.get(Artifact.Attribute.ID));
        } else {
            LOG.warn("Lifecycle found for product [{}], artifact query version [{}] [{}] on artifact [{}] cannot be found in cycle data", eolId, cycleQueryVersion, latestVersionQueryVersion, artifact.get(Artifact.Attribute.ID));
        }
        continue;
    }

    this.performEnrichmentOnArtifactAndCycle(lifecycle, artifact, currentCycle, latestVersionQueryVersion);
    matchedEolCyclesTracker.computeIfAbsent(eolId, k -> new HashSet<>()).add(currentCycle);
}

return matchedEolCyclesTracker;
```

</details>


<h3 id="interpreting-the-data">Interpreting the data</h3>
<p>The 6 values we actually use from the data source can either be a Boolean or a date:</p>
<ul>
<li>EOL (End of Life): Generally, whether something has reached the end-of-life state, i.e., both support and extended
support have expired.</li>
<li>Support: Whether the basic support is still valid.</li>
<li>Extended Support: Something like security support or similar, is usually either not set or equals the EOL date.</li>
<li>LTS (Long Term Support): If Boolean, whether the cycle is LTS; if Date, when the cycle becomes LTS.</li>
<li>Discontinued: Whether the cycle is explicitly marked as discontinued, is often not set.</li>
<li>Technical Guidance: When the technical guidance support ends, is often not set.</li>
</ul>
<p>If the value ist a date, it always indicates when this state will be reached. Except for LTS, reaching this date is
always something negative.</p>
<p>We can differentiate the lifecycle state of a product based on whether extended support is available or not. Here are
the two scenarios:</p>
<h4 id="scenario-1-extended-support-is-available">Scenario 1: Extended Support is Available</h4>
<ol>
<li>Green: EOL has not been reached, both support and extended support are still valid.</li>
<li>Light Green: Support ends in less than X months (configurable, default is 6 months).</li>
<li>Yellow: Support is no longer valid, but extended support is still in effect.</li>
<li>Orange: Extended support ends in less than X months (configurable, default is 6 months).</li>
<li>Red: EOL has been reached, extended support is no longer valid.</li>
</ol>
<h4 id="scenario-2-extended-support-is-not-available">Scenario 2: Extended Support is Not Available</h4>
<p>In this case, phases 3 and 4 are skipped and the cycle immediately reaches the end of life.</p>
<ol>
<li>Green: EOL has not been reached, support is still valid.</li>
<li>Orange: Support ends in less than X months (configurable, default is 6 months).</li>
<li>Red: EOL has been reached, support is no longer valid.</li>
</ol>

#### Configuration: EOL

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>warningThresholdDaysSupport</code></td><td><code>180</code></td></tr><tr><td><code>warningThresholdDaysExtendedSupport</code></td><td><code>180</code></td></tr></table>



## EPSS Enrichment

`epss` / `epssEnrichment` / `epss`

<details>

<summary>Source Code for <code>EpssEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    Optional<EpssData> epssData = epssIndexQuery.getEpssData(vulnerability);
    if (!epssData.isPresent()) {
        log.info("No EPSS data found for vulnerability: " + vulnerability.getId());
        continue;
    }
    vulnerability.setEpssData(epssData.get());
}

vInventory.writeBack();
```

</details>




## KEV Enrichment

`kev` / `kevEnrichment` / `kev`

<details>

<summary>Source Code for <code>KevEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
final KevIndexQuery kevIndexQuery = kevIndexQueryLazySupplier.get();

final Set<String> foundKevFromVulnerabilities = new LinkedHashSet<>();
for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    kevIndexQuery.findKevDataForVulnerability(vulnerability.getId())
            .ifPresent(kevData -> {
                vulnerability.setKevData(kevData);
                foundKevFromVulnerabilities.add(vulnerability.getId());
            });
}

log.info("Found KEV information for [{}] vulnerabilities", foundKevFromVulnerabilities.size());
log.debug("Found KEV information for the following vulnerabilities: {}", foundKevFromVulnerabilities);

vInventory.writeBack();
```

</details>




---

# Post Processing

A simple step that runs several check-ups and post-processing steps on the inventory to ensure that the inventory is
consistent and ready for the reporting phase.

## Vulnerability Status Post Processing

`status-post-processed` / `vulnerabilityStatusPostProcessingEnrichment` / `vulnerability-status-post-processing`

<details>

<summary>Source Code for <code>VulnerabilityStatusPostProcessingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final VulnerabilityStatusPostProcessor processor = new VulnerabilityStatusPostProcessor();
processor.setMsrcProductIndexQuery(this.msrcProductIndexQuery);
processor.setGhsaAdvisorIndexQuery(this.ghsaAdvisorIndexQuery);

for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    final VulnerabilityStatus assessmentStatus = vulnerability.getVulnerabilityStatus();
    if (assessmentStatus == null) {
        continue;
    }

    for (VulnerabilityStatusHistoryEntry historyEntry : assessmentStatus.getStatusHistory()) {
        processor.resolveVariablesHandler(vInventory, vulnerability, historyEntry.getMeasures(), historyEntry::setMeasures);
        processor.resolveVariablesHandler(vInventory, vulnerability, historyEntry.getRisk(), historyEntry::setRisk);
        processor.resolveVariablesHandler(vInventory, vulnerability, historyEntry.getRationale(), historyEntry::setRationale);
        processor.resolveVariablesHandler(vInventory, vulnerability, historyEntry.getAuthor(), historyEntry::setAuthor);
    }

    processor.resolveVariablesHandler(vInventory, vulnerability, assessmentStatus.getReportedDate(), assessmentStatus::setReportedDate);
}

vInventory.writeBack(true);
```

</details>




## Vulnerability Filtering

`vulnerability-filter` / `vulnerabilityFilterEnrichment` / `vulnerability-filter`

<details>

<summary>Source Code for <code>VulnerabilityFilterEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final FilterAttribute filter = configuration.getVulnerabilityIncludeFilterAttribute();
if (filter == null) {
    LOG.warn("No vulnerability filter configured, skipping enrichment [{}]", getEnrichmentName());
    return;
}
LOG.info("");
LOG.info("Filtering vulnerabilities using {}", configuration.getVulnerabilityIncludeFilter());
LOG.info("Parsed vulnerability filter: {}", filter);

final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
vInventory.calculateEffectiveCvssVectorsForVulnerabilities(super.getSecurityPolicyConfiguration());

final int size = vInventory.getVulnerabilities().size();
for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (!filter.matches(vulnerability)) {
        vInventory.remove(vulnerability);
    }
}
vInventory.writeBack(true);

LOG.info("Filtered vulnerabilities [{} - {} = {}]", size, size - inventory.getVulnerabilityMetaData().size(), inventory.getVulnerabilityMetaData().size());
```

</details>


#### Configuration: Vulnerability Filter

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>vulnerabilityIncludeFilter</code></td><td><code>null</code></td></tr><tr><td><code>vulnerabilityIncludeFilterAttribute</code></td><td><code>null</code></td></tr></table>



## Inventory Validation

`inventory-validation` / `inventoryValidationEnrichment` / `validation`

<details>

<summary>Source Code for <code>InventoryValidationEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final List<InventoryValidator> validators = configuration.buildValidators();

final Map<InventoryValidator, List<InventoryValidationReason>> validationErrorReasons = new LinkedHashMap<>();

for (InventoryValidator validator : validators) {
    validator.beforeValidation(baseMirrorDirectory);

    LOG.info("Validating inventory with validator: [{}]", validator.getValidatorName());

    try {
        final List<InventoryValidationReason> reasons = validator.validate(inventory);

        for (InventoryValidationReason reason : reasons) {
            validationErrorReasons.computeIfAbsent(validator, k -> new ArrayList<>()).add(reason);
        }
    } catch (Exception e) {
        throw new IllegalStateException("Performing the validation failed for validator " + validator.getValidatorName() + ": " + e.getMessage(), e);
    }

    if (validationErrorReasons.getOrDefault(validator, Collections.emptyList()).isEmpty()) {
        LOG.info("No validation failures found");
    } else {
        LOG.warn("Found [{}] validation failures", validationErrorReasons.values().stream().mapToInt(List::size).sum());
    }
}

cachedValidationFailReasons.computeIfAbsent(inventory, k -> new ArrayList<>())
        .addAll(validationErrorReasons.values().stream().flatMap(Collection::stream).collect(Collectors.toList()));


if (!validationErrorReasons.isEmpty()) {
    final int count = validationErrorReasons.values().stream().mapToInt(List::size).sum();
    final String longDescriptions = buildValidationLongDescriptions(Collections.singletonList(validationErrorReasons));

    final String logMessage = "Inventory Validation failures in " + count + " instance" + (count == 1 ? "" : "s") + ":\n" +
            buildValidationFailReasonsReport(validationErrorReasons) +
            "\n" + longDescriptions + "\n";

    if (configuration.isFailOnValidationErrors()) {
        throw new IllegalStateException(logMessage);
    } else {
        if (configuration.isAddAsCorrelationWarnings()) {
            addInventoryWarningsToInventory(inventory, cachedValidationFailReasons.get(inventory));
        }
        LOG.error(logMessage);
    }
} else {
    LOG.info("Inventory Validation successful.");
}
```

</details>


#### Configuration: Inventory Validation

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>LOG</code></td><td><code>LoggerFactory.getLogger(InventoryValidationEnrichmentConfiguration.class)</code></td></tr><tr><td><code>failOnValidationErrors</code></td><td><code>false</code></td></tr><tr><td><code>addAsCorrelationWarnings</code></td><td><code>true</code></td></tr><tr><td><code>additionalCpeIsNotEffectiveInventoryValidator</code></td><td><code>          </code></td></tr><tr><td><code>multipleArtifactsAndVersionsOnVulnerabilityInventoryValidator</code></td><td><code>          </code></td></tr><tr><td><code>artifactAndCpeVersionsDifferGreatlyInventoryValidator</code></td><td><code>          </code></td></tr><tr><td><code>vulnerabilityInvalidNameValidator</code></td><td><code>          </code></td></tr><tr><td><code>additionalValidators</code></td><td><code>new ArrayList<>()</code></td></tr></table>



---

# Reporting

The final phase of the inventory enrichment pipeline is the reporting phase, which generates the Vulnerability
Assessment Dashboard.
This dashboard is a web-based HTML report that provides an overview of the vulnerabilities and security advisories
identified in an inventory.

An example of the dashboard for
[OpenSSL 3.0.6 can be found here](https://metaeffekt.com/security/dashboards/openssl-3.0.6-dashboard.html?sort=7&sortDir=false).

## Vulnerability Assessment Dashboard

`vulnerability-assessment-dashboard` / `vulnerabilityAssessmentDashboardEnrichment` / `vulnerability-assessment-dashboard`

<details>

<summary>Source Code for <code>VulnerabilityAssessmentDashboard.performEnrichment(Inventory inventory)</code> </summary>

```java
LOG.info("Parsing inventory data");
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

LOG.info("Baking effective CVSS vectors");
vInventory.calculateEffectiveCvssVectorsForVulnerabilities(super.getSecurityPolicyConfiguration());
LOG.info("Applying effective vulnerability status");
vInventory.applyEffectiveVulnerabilityStatus(super.getSecurityPolicyConfiguration());

LOG.info("Using calculated values for potential vulnerability filtering");
final List<Vulnerability> effectiveVulnerabilities = VulnerabilityAssessmentDashboard.getEffectiveVulnerabilitiesAll(vInventory, configuration, super.getSecurityPolicyConfiguration());

LOG.info("Initializing dashboard");
final Dashboard dashboard = this.initializeDashboard(vInventory);

LOG.info("Starting dashboard generation");
final Map<Artifact, List<Vulnerability>> vulnerabilitiesPerArtifact = Vulnerability.groupVulnerabilitiesByArtifact(effectiveVulnerabilities);
final Map<Vulnerability, VadDetailLevelConfiguration> vulnerabilityDetails = this.determineVulnerabilityDetailLevels(effectiveVulnerabilities);

this.setFaviconDependingOnVulnerabilityPresence(dashboard, !effectiveVulnerabilities.isEmpty());

final VulnerabilityTimelineGeneratorResult vulnerabilityTimelines = generateApplicableVulnerabilityTimelines(effectiveVulnerabilities, vulnerabilityDetails);

LOG.info("Processing vulnerabilities...");

final Modal inventoryWarningsModal = createInventoryWarningsModal(inventory, vulnerabilityDetails.keySet());
dashboard.addModal(inventoryWarningsModal);

LOG.info("");
for (Vulnerability vulnerability : effectiveVulnerabilities) {
    final VadDetailLevelConfiguration detailLevel = vulnerabilityDetails.get(vulnerability);

    super.executor.submit(() -> {
        LOG.debug("Processing vulnerability: [{}]", vulnerability.getId());
        try {
            dashboard.addSheet(createVulnerabilitySheet(vulnerability, effectiveVulnerabilities, vulnerabilityTimelines, detailLevel));
        } catch (Exception e) {
            LOG.error("Failed to create vulnerability sheet for vulnerability: {}", vulnerability.getId(), e);
            throw new RuntimeException("Failed to create vulnerability sheet for vulnerability: " + vulnerability.getId(), e);
        }
    });
}

executor.setSize(1);
executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for all vulnerability sheets to be created", e);
}

dashboard.sortSheets(Comparator.comparing(sheet -> {
    final String id = sheet.getId();
    if (id.equalsIgnoreCase("inventory warnings")) {
        return "!!!inventory warnings";
    } else {
        return id;
    }
}));


LOG.info("Generating overview charts");
final VulnerabilityOverviewChartGenerator overviewChartGenerator = new VulnerabilityOverviewChartGenerator(vInventory, super.getSecurityPolicyConfiguration(), effectiveVulnerabilities, vulnerabilitiesPerArtifact);
final List<GeneratedChart> overviewCharts = overviewChartGenerator.generateOverviewCharts();

for (GeneratedChart overviewChart : overviewCharts) {
    overviewChart.writeSvgTo(configuration.getSvgDirectory());
}

dashboard.addModal(generateOverviewModal(overviewCharts));
dashboard.addModal(generateAssessmentEditorModal());

dashboard.addBottomLeftBadge(inventory.getArtifacts().size() + " artifact" + plural(inventory.getArtifacts().size()));
dashboard.addBottomLeftBadge(effectiveVulnerabilities.size() + " vulnerabilitie" + plural(effectiveVulnerabilities.size()));

final List<VulnerabilityPriorityCalculator.PriorityScoreResult> priorityScores = effectiveVulnerabilities.stream().map(vulnerability -> vulnerability.calculatePriorityScore(securityPolicyConfiguration)).collect(Collectors.toList());
final List<CvssSeverityRanges.SeverityRange> priorityScoreRanges = priorityScores.stream().filter(VulnerabilityPriorityCalculator.PriorityScoreResult::isElevated).map(score -> securityPolicyConfiguration.getPriorityScoreSeverityRanges().getRange(score.getResultingScore())).collect(Collectors.toList());
final CvssSeverityRanges.SeverityRange[] priorityScoreSeverityRanges = securityPolicyConfiguration.getPriorityScoreSeverityRanges().getRanges();
for (int i = 0; i < priorityScoreSeverityRanges.length - 1; i++) {
    final CvssSeverityRanges.SeverityRange severityRange = priorityScoreSeverityRanges[i];
    dashboard.addBottomLeftBadge(span(priorityScoreRanges.stream().filter(range -> range == severityRange).count() + " " + severityRange.getName()), i == 0 ? "danger" : "warning");
}

dashboard.addBottomLeftBadge(vInventory.getSecurityAdvisories().size() + " advisorie" + plural(vInventory.getSecurityAdvisories().size()));
{
    final int ignoredVulnerabilitiesCount = vInventory.getVulnerabilities().size() - effectiveVulnerabilities.size();
    if (ignoredVulnerabilitiesCount > 0) {
        dashboard.addBottomLeftBadge(ignoredVulnerabilitiesCount + " ignored");
    }
}
addAdditionalInventoryInformation(inventory, dashboard);

// FIXME: implement missing behavior
// checkForFailReasons(statistics);

try {
    dashboard.generateIntoFile(configuration.getOutputDashboardFile());
    LOG.info("Wrote dashboard to file: {}", configuration.getOutputDashboardFile().getAbsolutePath());
} catch (IOException e) {
    throw new RuntimeException("Failed to write dashboard to file: " + configuration.getOutputDashboardFile(), e);
}
```

</details>


This class uses an inventory to generate a 'Vulnerability Assessment Dashboard' as single-page HTML file.

#### Configuration: Vulnerability Assessment Dashboard

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>LOG</code></td><td><code>LoggerFactory.getLogger(VulnerabilityAssessmentDashboardEnrichmentConfiguration.class)</code></td></tr><tr><td><code>maximumVulnerabilitiesPerDashboardCount</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>vulnerabilityIncludeFilter</code></td><td><code>null</code></td></tr><tr><td><code>vulnerabilityIncludeFilterAttribute</code></td><td><code>null</code></td></tr><tr><td><code>maximumCpeForTimelinesPerVulnerability</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>maximumVulnerabilitiesPerTimeline</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>maximumVersionsPerTimeline</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>maximumTimeSpentOnTimelines</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>maximumTimeSpentPerTimeline</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>vulnerabilityTimelinesGlobalEnabled</code></td><td><code>true</code></td></tr><tr><td><code>vulnerabilityTimelineHideIrrelevantVersions</code></td><td><code>true</code></td></tr><tr><td><code>failOnVulnerabilityWithoutSpecifiedRisk</code></td><td><code>true</code></td></tr><tr><td><code>failOnUnreviewedAdvisories</code></td><td><code>true</code></td></tr><tr><td><code>svgDirectory</code></td><td><code>          </code></td></tr><tr><td><code>vulnerabilitySvgChartInterpolationMethod</code></td><td><code>VulnerabilityCvssSvgChartInterpolationMethod.BASE_METRICS</code></td></tr><tr><td><code>detailLevels</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>failOnUnreviewedAdvisoriesTypes</code></td><td><code>new JSONArray().toString()</code></td></tr><tr><td colspan=2>Represents a <code>List</code>&lt;<code>Map</code>&lt;<code>String</code>, <code>String</code>&gt;&gt;.<br> The key "name" is mandatory and can optionally be combined with an "implementation" value. If the implementation is not specified, the name will be used as the implementation. Each list entry represents a single advisory type. <p> Whether to fail if there are security advisories from certain providers that are not listed as reviewed in the status YAML files (<code>reviewed</code>). <p> Example: <pre>     [{"name":"CERT_FR"},      {"name":"CERT_SEI"},      {"name":"RHSA","implementation":"CSAF"}] </pre> <b>WARNING: This property is currently not implemented due to a lack of interest in this functionality.</b> It should probably be moved to the <code>InventoryValidationEnrichment</code> as a <code>VulnerabilityInventoryValidator</code>.</td></tr><tr><td><code>outputDashboardFile</code></td><td><code>null</code></td></tr></table>



---

# Other standalone steps

## Advisor periodic

`advisor-periodic` / `advisorPeriodicEnrichment` / `advisor-periodic`

<details>

<summary>Source Code for <code>AdvisorPeriodicEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final Map<String, Inventory> parsedReferenceInventories = new LinkedHashMap<>();

// reference inventory must be first for merging later on
if (configuration.hasInitialInventoryContextName()) {
    parsedReferenceInventories.put(configuration.getInitialInventoryContextName(), inventory);
}
parsedReferenceInventories.putAll(configuration.parseReferenceInventories());

if (parsedReferenceInventories.isEmpty()) {
    LOG.warn("No reference inventories have been provided.");
} else if (parsedReferenceInventories.size() == 1) {
    LOG.info("Using [{}] as the only reference inventory", parsedReferenceInventories.keySet().iterator().next());
} else {
    LOG.info("Using [{}] as the reference inventories", parsedReferenceInventories.keySet());
}


final Map<String, VulnerabilityContextInventory> vParsedReferenceInventories = VulnerabilityContextInventory.fromInventories(parsedReferenceInventories);

final Inventory outputInventory = new Inventory();
final VulnerabilityContextInventory vOutputInventory = VulnerabilityContextInventory.fromInventory(outputInventory);

final PeriodicDataSourcesOperations.QueryTimePeriod queryTimePeriod = configuration.getAdvisoryQueryPeriod();
LOG.info("Listing all advisories for changed entries of {} in period {}", configuration.getAdvisoryProviders(), queryTimePeriod);

final InventoryInfo info = outputInventory.findOrCreateInventoryInfo(ADVISOR_PERIODIC_QUERY_KEY);
info.set(ADVISOR_PERIODIC_QUERY_RANGE_START_KEY, new SimpleDateFormat("yyyy-MM-dd").format(queryTimePeriod.getStart()));
info.set(ADVISOR_PERIODIC_QUERY_RANGE_END_KEY, new SimpleDateFormat("yyyy-MM-dd").format(queryTimePeriod.getEnd()));

// set up the index for the advisory providers
final PeriodicDataSourcesOperations periodicDataSourcesOperations = new PeriodicDataSourcesOperations();
periodicDataSourcesOperations.addAdvisorIndexQueriesForContentIdentifiers(baseMirrorDirectory, configuration.getAdvisoryProviders());


final List<AdvisoryEntry> securityAdvisoriesUpdatedOrModifiedSince = periodicDataSourcesOperations.findSecurityAdvisoriesUpdatedOrModifiedSince(
        queryTimePeriod,
        configuration.getAdvisoryProviders(),
        configuration.getIncludeAdvisoryTypes()
);
vOutputInventory.addAllAdvisories(securityAdvisoriesUpdatedOrModifiedSince);

// if there are reference inventories, mark the AdvisoryMetaData entries as [unaffected, new, in progress, reviewed] based on whether they are listed as reviewed or not.
periodicDataSourcesOperations.setSecurityAdvisoryReviewedStatusFromReferenceInventories(
        vOutputInventory.getSecurityAdvisories(),
        vParsedReferenceInventories.values()
);

this.filterInventoryDataPreMerge(vOutputInventory, periodicDataSourcesOperations);

this.mergeReferenceInventoriesToSourceInventory(vOutputInventory, parsedReferenceInventories, outputInventory);

// mark all the advisories that have been added by the merger as 'unclassified'
for (AdvisoryEntry securityAdvisory : vOutputInventory.getShallowCopySecurityAdvisories()) {
    if (securityAdvisory.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS) == null) {
        securityAdvisory.setAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS, AdvisoryMetaData.STATUS_VALUE_UNCLASSIFIED);
    }
}

this.filterInventoryDataPostMerge(vOutputInventory, periodicDataSourcesOperations);

vOutputInventory.writeBack(true);
this.logReviewStateCounts(vOutputInventory.getSecurityAdvisories());

// move all data from the output inventory to the original inventory so that the original inventory is enriched
super.moveInventoryData(outputInventory, inventory);
```

</details>


#### Configuration: Advisor Periodic

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>LOG</code></td><td><code>LoggerFactory.getLogger(AdvisorPeriodicEnrichmentConfiguration.class)</code></td></tr><tr><td><code>advisoryProviders</code></td><td><code>new JSONArray()            .put(new JSONObject().put("name", "all").put("implementation", "all")).toString()</code></td></tr><tr><td colspan=2>Represents a <code>List</code>&lt;<code>Map</code>&lt;<code>String</code>, <code>String</code>&gt;&gt;.<br> The key "name" is mandatory and can optionally be combined with an "implementation" value. If the implementation is not specified, the name will be used as the implementation. Each list entry represents a single advisory type. <p> The <code>AdvisorPeriodicEnrichmentConfiguration#advisoryProviders</code> determines the data sources the advisories are fetched from. If a specified advisory type does not provide a valid index to query advisories from, it will be ignored. <p> Example: <pre>     [{"name":"CERT_FR"},      {"name":"CERT_SEI"},      {"name":"RHSA","implementation":"CSAF"}] </pre></td></tr><tr><td><code>changedSince</code></td><td><code>"3 months"</code></td></tr><tr><td colspan=2>A string that represents the start time for the period to query for advisories in. This parameter determines how far back in time advisories should be considered. The value can be a date in the format "yyyy-MM-dd" or a string like "3 months 5 hours".</td></tr><tr><td><code>changedUntil</code></td><td><code>"now"</code></td></tr><tr><td colspan=2>A string that represents the end time for the period to query for advisories in. See <code>AdvisorPeriodicEnrichmentConfiguration#changedSince</code> for more information. By default, this is set to "now", meaning the current time.</td></tr><tr><td><code>filterUnaffected</code></td><td><code>false</code></td></tr><tr><td colspan=2>Is applied after all relevant advisories have been found for the selected time period.<br> If set to true, advisories with the <code>AdvisoryMetaData#STATUS_VALUE_UNAFFECTED</code> status will be filtered out from the inventory.</td></tr><tr><td><code>filterUnclassified</code></td><td><code>false</code></td></tr><tr><td colspan=2>Is applied after all relevant advisories have been found for the selected time period.<br> If set to true, advisories with the <code>AdvisoryMetaData#STATUS_VALUE_UNCLASSIFIED</code> status will be filtered out from the inventory.</td></tr><tr><td><code>includeAdvisoryTypes</code></td><td><code>new ArrayList<>(Collections.singletonList("all"))</code></td></tr><tr><td colspan=2>What <b>TYPES</b> of advisories to include. <b>This is NOT the advisory provider or source.</b><br> Valid values include: <code>notice, alert, news</code><br> To include all types, use <code>all</code>.</td></tr><tr><td><code>filterUnaffectedVulnerabilities</code></td><td><code>false</code></td></tr><tr><td colspan=2>Is applied after all relevant advisories have been found for the selected time period and advisory filters have been applied.<br> If set to true, vulnerabilities that are not affected by any of the found advisories will be filtered out from the inventory.<br> Note: This is overwritten by the <code>AdvisorPeriodicEnrichmentConfiguration#includeVulnerabilitiesChangedSince</code> parameter.</td></tr><tr><td><code>filterVulnerabilitiesWithoutSpecifiedAdvisory</code></td><td><code>false</code></td></tr><tr><td colspan=2>Is applied after all relevant advisories have been found for the selected time period and advisory filters have been applied.<br> If set to true, vulnerabilities that do not have an advisory from the sources listen in the <code>AdvisorPeriodicEnrichmentConfiguration#vulnerabilityAdvisoryFilter</code> parameter will be filtered out from the inventory.<br> Note: This is overwritten by the <code>AdvisorPeriodicEnrichmentConfiguration#includeVulnerabilitiesChangedSince</code> parameter.</td></tr><tr><td><code>vulnerabilityAdvisoryFilter</code></td><td><code>new JSONArray().toString()</code></td></tr><tr><td colspan=2>Represents a <code>List</code>&lt;<code>Map</code>&lt;<code>String</code>, <code>String</code>&gt;&gt;.<br> The key "name" is mandatory and can optionally be combined with an "implementation" value. If the implementation is not specified, the name will be used as the implementation. Each list entry represents a single advisory type. <p> The <code>AdvisorPeriodicEnrichmentConfiguration#vulnerabilityAdvisoryFilter</code> is used to filter vulnerabilities based on the advisory type. If the vulnerability does not have one of the specified advisory types, it will be filtered out. <p> Example: <pre>     [{"name":"CERT_FR"},      {"name":"CERT_SEI"},      {"name":"RHSA","implementation":"CSAF"}] </pre></td></tr><tr><td><code>includeVulnerabilitiesChangedSince</code></td><td><code>null</code></td></tr><tr><td colspan=2>Can be set to a value similar to the <code>AdvisorPeriodicEnrichmentConfiguration#changedSince</code> value. This parameter will force all vulnerabilities from the source (<code>initial</code>) or reference inventories to be included that have been changed since the specified date, no matter if they are affected or would be filtered otherwise by the other parameters.<br> Example: "2023-11-08" or "3 months"</td></tr><tr><td><code>initialInventoryContextName</code></td><td><code>"initial"</code></td></tr><tr><td><code>referenceInventories</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>referenceInventoriesInventories</code></td><td><code>new HashMap<>()</code></td></tr></table>

#### Configuration: Vulnerabilities from CPE

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maxCorrelatedVulnerabilitiesPerArtifact</code></td><td><code>Integer.MAX_VALUE</code></td></tr></table>



---
