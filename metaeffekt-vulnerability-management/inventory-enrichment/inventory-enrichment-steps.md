> [Documentation](../../README.md) >
> [Vulnerability Management](../vulnerability-management.md) >
> [Inventory Enrichment Pipeline](inventory-enrichment-pipeline.md) >
> Inventory Enrichment Steps

# Inventory Enrichment Steps

> [Overview](#overview) -
> [Steps](#product-identification)

## Overview

The inventory enrichment pipeline has already been described with a quick overview in the
[Inventory Enrichment Pipeline](inventory-enrichment-pipeline.md) chapter.
This chapter provides a detailed description of each step in the inventory enrichment pipeline.
While it is theoretically possible to construct a pipeline that runs the following steps in any order,
on a conceptual level, only a specific order makes sense.
This is why the steps are divided into separate phases, which are executed in a specific order, but within each phase,
the steps can be executed in any order.

In some cases, such as with the Vulnerability Details Fill phase,
a phase might have to run twice if certain conditions are met.
In order to reduce the length of the following list, these duplications have been omitted.
The descriptions when a phase has to run twice are included in the respective phase's description,
but the responsible maven plugin manages this automatically, so that you, as a user, will not have to worry about this.

- **[Product Identification](#product-identification)**
  - [CPE Derivation](#cpe-derivation)
  - [Artifact Correlation](#artifact-correlation)
- **[Vulnerability Matching](#vulnerability-matching)**
  - [NVD Vulnerabilities from CPE](#nvd-vulnerabilities-from-cpe)
  - [MSRC Vulnerabilities by Product](#msrc-vulnerabilities-by-product)
  - [GHSA Vulnerabilities](#ghsa-vulnerabilities)
  - [Custom Vulnerabilities from CPE](#custom-vulnerabilities-from-cpe)
- **[Vulnerability Details Filling](#vulnerability-details-filling)**
  - [NVD metadata query](#nvd-metadata-query)
  - [MSRC metadata query](#msrc-metadata-query)
  - [Custom metadata query](#custom-metadata-query)
- **[Assessments](#assessments)**
  - [Vulnerability Keywords](#vulnerability-keywords)
  - [Vulnerability Status](#vulnerability-status)
- **[Security Advisory Matching](#security-advisory-matching)**
  - [GHSA metadata query](#ghsa-metadata-query)
  - [CERT-FR metadata query](#cert-fr-metadata-query)
  - [CERT-SEI metadata query](#cert-sei-metadata-query)
  - [CERT-EU metadata query](#cert-eu-metadata-query)
- **[Vulnerability Prioritization](#vulnerability-prioritization)**
  - [EOL](#eol)
  - [EPSS](#epss)
  - [KEV](#kev)
- **[Inventory Post Processing](#inventory-post-processing)**
  - [Vulnerability Status post-processing](#vulnerability-status-post-processing)
  - [Vulnerability Filter](#vulnerability-filter)
  - [Inventory Validation](#inventory-validation)
- **[Reporting](#reporting)**
  - [Vulnerability Assessment Dashboard](#vulnerability-assessment-dashboard)
- **[Standalone](#standalone)**
  - [Advisor Periodic](#advisor-periodic)
  - [Inventory Pipeline](#inventory-pipeline)

---

# Product Identification

A challenge for the vulnerability matching is that every vulnerability and security advisory provider uses different
formats and methods of identifying products and versions in their knowledge database.
A couple of examples for actual product identification methods are:

- The [National Vulnerability Database (NVD)](https://nvd.nist.gov/vuln)
  uses the [Common Platform Enumeration (CPE)](https://cpe.mitre.org/specification) to identify products,
- [Microsoft Security Response Center (MSRC)](https://www.microsoft.com/en-us/msrc)
  uses a numeric registry with a number for each product and version,
- [GitHub Security Advisories (GHSA)](https://github.com/advisories)
  and others use [Package URLs (PURLs)](https://github.com/package-url/purl-spec),
- [End Of Life](https://endoflife.date) uses unique string identifiers for each product,
- and so on.

This diversity of product identifiers is not represented in the initial software component inventory.
Therefore, the first step in the vulnerability matching process is to attempt to automatically derive product
identifiers from the component metadata, including artifact names, versions, and vendor information.

The following two steps are always performed to enable and improve the matching accuracy:

## CPE Derivation

<details>

<summary>Source Code for <code>CpeDerivationEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final AtomicInteger progress = new AtomicInteger(0);

this.cpeDerivationUtilities.setConfiguration(this.configuration);

final List<Artifact> artifacts = inventory.getArtifacts();
final Map<Artifact, Long> startTimes = new HashMap<>();

for (final Artifact artifact : artifacts) {
    if (!isValidForEnrichment(artifact)) {
        LOG.info("Missing required information on artifact [{}], skipping CPE URI derivation", artifact.getId());

        new InventoryWarnings(inventory).addArtifactWarning(new InventoryWarningEntry<>(artifact,
                "Cannot perform CPE URI derivation, missing required information.",
                this.getEnrichmentName()
        ));
        continue;
    }

    super.executor.submit(() -> {
        final int currentElement = progress.incrementAndGet();
        if (currentElement % 100 == 0 && currentElement > 0) {
            LOG.info("Deriving CPE URIs for artifact [{} / {}]", currentElement, inventory.getArtifacts().size());
        }

        synchronized (startTimes) {
            startTimes.put(artifact, System.currentTimeMillis());
        }

        this.cpeDerivationUtilities.deriveCpeUris(inventory, artifact);

        synchronized (startTimes) {
            startTimes.remove(artifact);
        }
    });
}

final TimerTask checkArtifactTimerTask = new TimerTask() {
    @Override
    public void run() {
        final long currentTime = System.currentTimeMillis();
        synchronized (startTimes) {
            final List<Map.Entry<Artifact, Long>> longRunningArtifacts = startTimes.entrySet().stream()
                    .filter(e -> currentTime - e.getValue() >= 30000)
                    .sorted((o1, o2) -> o2.getValue().compareTo(o1.getValue()))
                    .collect(Collectors.toList());
            if (!longRunningArtifacts.isEmpty()) {
                LOG.warn("CPE URI derivation is taking longer than 30 seconds for [{}] artifacts: {}", longRunningArtifacts.size(), longRunningArtifacts.stream().map(Map.Entry::getKey).map(Artifact::getId).collect(Collectors.joining(", ")));
            }
        }
    }
};

final Timer checkArtifactTimer = new Timer();
checkArtifactTimer.schedule(checkArtifactTimerTask, 30000, 30000);

super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Interrupted while waiting for CPE URI derivation to finish", e);
}

checkArtifactTimer.cancel();
```

</details>


<p>To find the correct product identifiers for the NVD CVE data, CPE URIs are derived from the component metadata.
This step is based on the principle of allowing more false positives than false negatives,
since it is more important to identify all potential vulnerabilities which can be filtered out in later steps
either manually or automatically than to potentially miss critical vulnerabilities.</p>



## Artifact Correlation

<details>

<summary>Source Code for <code>ArtifactCorrelationEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
LOG.info("Performing enrichment using [{}] yaml file{} or director{}", configuration.getYamlFiles().size(), configuration.getYamlFiles().size() == 1 ? "" : "s", configuration.getYamlFiles().size() == 1 ? "y" : "ies");

for (File file : configuration.getYamlFiles()) {
    ArtifactCorrelationUtil.addYamlToInventory(inventory, file, super.getSecurityPolicyConfiguration().getJsonSchemaValidationErrorsHandling());
}
```

</details>


<details>

<summary>Source Code for <code>ArtifactCorrelationUtil.addYamlToInventory(Inventory inventory, List dataEntries)</code> </summary>

```java
if (inventory == null) {
    LOG.error("Inventory is null, canceling enrichment");
    return;
}

long totalCount = 0;
int appliedArtifacts = 0;

final List<Artifact> artifacts = inventory.getArtifacts();

for (int i = 0; i < artifacts.size(); i++) {
    final Artifact artifact = artifacts.get(i);
    final long count = dataEntries.stream()
            .filter(d -> d.affects(artifact))
            .peek(d -> d.apply(artifact, inventory))
            .count();

    totalCount += count;
    appliedArtifacts += count > 0 ? 1 : 0;

    if (i % 100 == 0 && i > 0) {
        LOG.info("[{} / {}] Applied [{}] entries to [{}] artifacts", i, artifacts.size(), totalCount, appliedArtifacts);
    }
}

LOG.info("Applied [{}] entries to [{}] artifacts", totalCount, appliedArtifacts);

CommonEnumerationUtil.distinctAndSortedWithWildcards(inventory);
```

</details>


<p>However, there is no way of reliably and correctly performing an automated step like this for several reasons,
such as spelling mistakes in the product data on either side, differing naming conventions, multiple products
with the same name, and so on.
To improve the quality of the previous step and to enable matching via Microsoft, EOL and other data sources,
a custom data format is used (Correlation Files) to manually map the component metadata to the product identifiers.
More details on the <code>artifact-data</code> schema <a href="https://metaeffekt.com/schema/artifact-analysis">can be found here</a>.</p>



---

# Vulnerability Matching

The next phase represents the main part of the inventory enrichment process,
where the actual vulnerabilities from different sources are matched against the products identified in the previous
steps.
Note that only the _vulnerabilities themselves_ are identified in this step, not the vulnerability metadata, such as
descriptions or CVSS vectors.
This separation is made to allow for adding those details whenever changes to the vulnerability list were made and to
prevent having to run the details step after each vulnerability identification step.

## NVD Vulnerabilities from CPE

<details>

<summary>Source Code for <code>NvdVulnerabilitiesFromCpeEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final AtomicInteger progress = new AtomicInteger(0);

final List<Artifact> artifacts = inventory.getArtifacts();
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
for (final Artifact artifact : artifacts) {
    super.executor.submit(() -> {
        final int currentElement = progress.incrementAndGet();
        if (currentElement % 100 == 0 && currentElement > 0) {
            log.info("Collecting CVE from CPE for artifact [{} / {}]", currentElement, inventory.getArtifacts().size());
        }

        super.enrichVulnerabilitiesForCpe(vInventory, artifact);
    });
}

super.executor.setSize(16);
super.executor.setLogEveryPercent(10);
super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to join executor while waiting for NVD CVE from CPE enrichment to finish.", e);
}

vInventory.writeBack();
```

</details>




## MSRC Vulnerabilities by Product

<details>

<summary>Source Code for <code>MsrcVulnerabilitiesByProductEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final MsrcAdvisorIndexQuery msrcAdvisorQuery = this.msrcAdvisorQuery.get();
final MsrcKbChainIndexQuery msrcKbChainQuery = this.msrcKbChainQuery.get();

final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

for (final Artifact artifact : inventory.getArtifacts()) {

    // find Microsoft product from artifact
    final String artifactMsProductIdOrName = artifact.get(InventoryAttribute.MS_PRODUCT_ID.getKey());
    if (artifactMsProductIdOrName == null) {
        continue;
    }

    final List<String> productList = Arrays.stream(artifactMsProductIdOrName.split(", ")).map(String::trim).collect(Collectors.toList());

    if (productList.size() >= 2) {
        LOG.warn("Multiple products found for artifact [{}], usually an artifact is only affected by a single product. Products: [{}]", artifact.getId(), artifactMsProductIdOrName);
    }

    for (String msProductIdOrName : productList) {
        final MsrcProduct msrcProduct = findProductFromIdOrName(msProductIdOrName);
        if (msrcProduct == null) {
            LOG.error("Skipping over MS Product ID [{}] from Artifact [{}] as it cannot be found in local index, make sure that the ID is correct", msProductIdOrName, artifact.getId());
            continue;
        }

        // extract KB Ids from artifact
        final Set<String> appliedMsKbIdentifiers = extractKbIdentifiers(artifact);


        // find Microsoft vulnerabilities affected by product
        final List<String> msVulnerabilitiesOnProductFromAdvisors = msrcAdvisorQuery.findByProduct(msrcProduct).stream()
                .map(MsrcAdvisorEntry::getId)
                .map(id -> id.replace("MSRC-", ""))
                .collect(Collectors.toList());
        final List<String> msVulnerabilitiesOnProductFromKbChains = msrcKbChainQuery.findVulnerabilitiesByProductId(msrcProduct.getId());

        final Set<String> allPotentialVulnerabilities = new HashSet<>();
        allPotentialVulnerabilities.addAll(msVulnerabilitiesOnProductFromAdvisors);
        allPotentialVulnerabilities.addAll(msVulnerabilitiesOnProductFromKbChains);


        msrcKbChainQuery.collectSupersedingKbIdentifiers(allPotentialVulnerabilities, msProductIdOrName, appliedMsKbIdentifiers);

        final Set<String> msVulnerabilitiesNotFixed = new HashSet<>();
        final Set<String> msAdvisoriesNotFixed = new HashSet<>();
        final Set<String> msVulnerabilitiesAndAdvisoriesFixed = new HashSet<>();

        for (String vulnerabilityId : allPotentialVulnerabilities) {
            final boolean isFixed = msrcKbChainQuery.isVulnerabilityFixed(vulnerabilityId, msrcProduct.getId(), appliedMsKbIdentifiers);

            if (isFixed) {
                msVulnerabilitiesAndAdvisoriesFixed.add(vulnerabilityId);
            } else {
                if (vulnerabilityId.startsWith("ADV")) {
                    msAdvisoriesNotFixed.add(vulnerabilityId);
                } else {
                    msVulnerabilitiesNotFixed.add(vulnerabilityId);
                }
            }
        }


        // convert to vulnerability instances
        final DataSourceIndicator msrcProductDataSourceIndicator = DataSourceIndicator.msrcProduct(artifact, msrcProduct, appliedMsKbIdentifiers);

        for (String v : msVulnerabilitiesNotFixed) {
            vInventory.findOrCreateVulnerabilityByName(v)
                    .addMatchingSource(msrcProductDataSourceIndicator);
        }

        for (String v : msAdvisoriesNotFixed) {
            vInventory.findOrCreateAdvisoryEntryByName(v, MsrcAdvisorEntry::new)
                    .addMatchingSource(msrcProductDataSourceIndicator);
        }

        for (String v : msVulnerabilitiesAndAdvisoriesFixed) {
            vInventory.findOrCreateWithoutAddingVulnerabilityByName(v)
                    .manuallyAffectsArtifact(InventoryAttribute.VULNERABILITIES_FIXED_BY_KB, artifact);
        }


        artifact.set(InventoryAttribute.MS_SUPERSEDED_KB_IDENTIFIER.getKey(), String.join(", ", appliedMsKbIdentifiers));

        LOG.info("Artifact [{}] with product [{}] ([{}]) and [{}] KB has [{} vulnerabilities] [{} advisories] [{} fixed by KB] from [{} & {} -> {}] vulnerabilities/advisories",
                artifact.getId(), msProductIdOrName, msrcProduct.getId(), appliedMsKbIdentifiers.size(),
                msVulnerabilitiesNotFixed.size(), msAdvisoriesNotFixed.size(), msVulnerabilitiesAndAdvisoriesFixed.size(),
                msVulnerabilitiesOnProductFromAdvisors.size(), msVulnerabilitiesOnProductFromKbChains.size(), allPotentialVulnerabilities.size());

    }
}

vInventory.writeBack();
```

</details>




## GHSA Vulnerabilities

<details>

<summary>Source Code for <code>GhsaVulnerabilitiesEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final List<GhsaArtifactVulnerabilityMatcher> matchers = configuration.buildMatchers(ghsaAdvisorQuery.get());

final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

LOG.info("Matching GHSA vulnerabilities for [{}] artifacts using [{}] matcher{}", inventory.getArtifacts().size(), matchers.size(), matchers.size() > 1 ? "s" : "");

for (final Artifact artifact : inventory.getArtifacts()) {
    for (GhsaArtifactVulnerabilityMatcher matcher : matchers) {
        if (matcher.mayMatch(artifact)) {
            final Map<GhsaAdvisorEntry, DataSourceIndicator> ghsaAdvisorEntries = matcher.match(artifact);

            // differentiate entries based on whether they have CVEs or not.
            // we are mainly interested in the entries that have vulnerabilities in this step
            for (Map.Entry<GhsaAdvisorEntry, DataSourceIndicator> matchedEntry : ghsaAdvisorEntries.entrySet()) {
                final GhsaAdvisorEntry ghsaAdvisorEntry = matchedEntry.getKey();
                final DataSourceIndicator dataSourceIndicator = matchedEntry.getValue();

                final Set<String> entryCves = ghsaAdvisorEntry.getReferencedVulnerabilities(VulnerabilityTypeStore.CVE);
                if (entryCves.isEmpty()) {
                    vInventory.add(vInventory.findOrCreateAdvisoryEntryByName(ghsaAdvisorEntry.getId(), GhsaAdvisorEntry::new)
                            .addMatchingSource(dataSourceIndicator));
                } else {
                    for (String entryCve : entryCves) {
                        final Vulnerability vulnerability = vInventory
                                .findOrCreateVulnerabilityByName(entryCve)
                                .addMatchingSource(dataSourceIndicator);
                        vulnerability.setSourceIdentifier(VulnerabilityTypeStore.CVE);
                        vInventory.add(vulnerability);
                    }
                }
            }
        }
    }
}

vInventory.writeBack(true);
```

</details>




## Custom Vulnerabilities from CPE

<details>

<summary>Source Code for <code>CustomVulnerabilitiesFromCpeEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
vulnerabilityQuery = new CustomVulnerabilityIndexQuery(getConfiguration().getVulnerabilityFiles());

final List<Artifact> artifacts = inventory.getArtifacts();
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
for (int i = 0, artifactsSize = artifacts.size(); i < artifactsSize; i++) {
    final Artifact artifact = artifacts.get(i);

    int finalI = i;
    super.executor.submit(() -> {
        LOG.info("Collecting vulnerabilities from CPE for artifact [{} / {}] [{}: {} {}]", finalI + 1, inventory.getArtifacts().size(), artifact.getId(), artifact.get(Artifact.Attribute.COMPONENT), artifact.get(Artifact.Attribute.VERSION));

        super.enrichVulnerabilitiesForCpe(vInventory, artifact);
    });
}

super.executor.setSize(16);
super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Interrupted while waiting for custom vulnerability enrichment to finish.", e);
}
```

</details>




---

# Vulnerability Details Filling

## NVD metadata query

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## MSRC metadata query

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## Custom metadata query

<details>

<summary>Source Code for <code>DetailsFillingEnrichmentCustom.performEnrichment(Inventory inventory)</code> </summary>

```java
vulnerabilityQuery = new CustomVulnerabilityIndexQuery(getConfiguration().getVulnerabilityFiles());
super.performEnrichment(inventory);
```

</details>




---

# Assessments

## Vulnerability Keywords

<details>

<summary>Source Code for <code>VulnerabilityKeywordsEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
LOG.info("Performing enrichment using [{}] yaml file{}", configuration.getYamlFiles().size(), configuration.getYamlFiles().size() == 1 ? "" : "s");

final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
final VulnerabilityKeywords keywords = configuration.makeKeywords(super.getSecurityPolicyConfiguration().getJsonSchemaValidationErrorsHandling());

for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    final List<KeywordSet> matchingKeywords = keywords.getMatching(
            vulnerability.getDescription(),
            String.join(", ", vulnerability.getCwes())
    );

    if (!matchingKeywords.isEmpty()) {
        LOG.debug("[{}] matches [{}] keyword(s): {}", vulnerability.getId(), matchingKeywords.size(), matchingKeywords.stream().map(KeywordSet::getNameScore).collect(Collectors.joining(", ")));

        final boolean anyKeywordSetHasScore = matchingKeywords.stream().anyMatch(KeywordSet::hasScore);
        final Double totalKeywordsScore = anyKeywordSetHasScore
                ? matchingKeywords.stream().filter(KeywordSet::hasScore).mapToDouble(KeywordSet::getScore).sum()
                : null;
        vulnerability.setAdditionalAttribute(InventoryAttribute.KEYWORDS_SCORE, totalKeywordsScore != null ? String.valueOf(VulnerabilityAssessmentDashboard.roundOneDecimal(totalKeywordsScore)) : null);

        final JSONArray keywordsArray = KeywordSet.toFullInformationJson(matchingKeywords);
        vulnerability.setAdditionalAttribute(InventoryAttribute.KEYWORDS, keywordsArray.toString());

        final VulnerabilityStatus status = findApplicableStatusFromKeywordSets(matchingKeywords);
        if (status != null) {
            status.appendToVulnerabilityStatus(vulnerability.getOrCreateNewVulnerabilityStatus(), configuration.getActiveLabels());
            vulnerability.getVulnerabilityStatus().applyToVulnerability(vulnerability);
        }
    }
}

vInventory.writeBack(true);
```

</details>




## Vulnerability Status

<details>

<summary>Source Code for <code>VulnerabilityStatusEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final boolean logMatchingCriteriaPreviousValue = VulnerabilityStatus.LOG_MATCHING_CRITERIA;
VulnerabilityStatus.LOG_MATCHING_CRITERIA = configuration.isDebugMatchingCriteria();

try {
    LOG.info("");
    if (!configuration.getStatusFiles().isEmpty()) {
        LOG.info("Adding data from status files from:");
        configuration.getStatusFiles().stream().map(File::getAbsolutePath).map(f -> " - " + f).forEach(LOG::info);
    }
    if (!configuration.getAdditionalStatus().isEmpty()) {
        LOG.info("Adding data from [{}] additional status entries added programmatically", configuration.getAdditionalStatus().size());
    }

    final Set<VulnerabilityStatus> anyScopeStatus = configuration.readVulnerabilityStatusEntries(super.getSecurityPolicyConfiguration().getJsonSchemaValidationErrorsHandling());

    // log the status files found with metadata
    if (anyScopeStatus.isEmpty()) {
        LOG.info("No status files found in provided directories");
    } else {
        final Map<String, List<VulnerabilityStatus>> scopeStatusMap = anyScopeStatus.stream()
                .collect(Collectors.groupingBy(s -> s.getOriginYamlFile() == null ? "programmatic" : s.getOriginYamlFile().getAbsolutePath()));
        for (Map.Entry<String, List<VulnerabilityStatus>> entry : scopeStatusMap.entrySet()) {
            final List<VulnerabilityStatus> statuses = entry.getValue();
            final String filePath = entry.getKey();
            LOG.info("Found [{}] ({}) status file{} in file: {}",
                    statuses.size(),
                    statuses.stream().map(VulnerabilityStatus::getScope).distinct().map(Enum::toString).collect(Collectors.joining(", ")),
                    statuses.size() == 1 ? "" : "s", filePath);
        }
    }
    LOG.info("");

    final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
    final int vulnerabilityCountBefore = vInventory.getVulnerabilities().size();


    // filter out all INVENTORY and ARTIFACT scope entries
    final List<VulnerabilityStatus> inventoryScopeStatus = anyScopeStatus.stream()
            .filter(s -> s.isScope(VulnerabilityStatus.Scope.INVENTORY))
            .collect(Collectors.toList());
    final List<VulnerabilityStatus> artifactScopeStatus = anyScopeStatus.stream()
            .filter(s -> s.isScope(VulnerabilityStatus.Scope.ARTIFACT))
            .collect(Collectors.toList());


    // do not yet add the vulnerabilities from the status files to the inventory, as INVENTORY scope statuses should not be applied on these
    if (!inventoryScopeStatus.isEmpty()) {
        LOG.info("Found [{}] status file{} with scope [{}]", inventoryScopeStatus.size(), inventoryScopeStatus.size() == 1 ? "" : "s", VulnerabilityStatus.Scope.INVENTORY);

        for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
            addStatusEntriesForVulnerability(vInventory, inventoryScopeStatus, vulnerability, false);
        }

        // add information about the inventory scope status files to the inventory info
        final InventoryInfo info = vInventory.getInventory().findOrCreateInventoryInfo(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_KEY);

        final JSONArray statusJson = inventoryScopeStatus.stream()
                .map(VulnerabilityStatus::toJson)
                .collect(CustomCollectors.toJsonArray());

        if (info.has(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY)) {
            final JSONArray existingStatusJson = new JSONArray(info.get(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY));
            for (int i = 0; i < existingStatusJson.length(); i++) {
                statusJson.put(existingStatusJson.get(i));
            }
        }

        info.set(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY, statusJson.toString());
    }


    // all vulnerabilities from the statuses that are non-existent in the inventory will be added as 'void' status entries later
    final Map<Vulnerability, File> createdVulnerabilitySources = new HashMap<>();
    for (VulnerabilityStatus cveStatusHistory : anyScopeStatus) {
        for (String name : cveStatusHistory.getAffectedVulnerabilitiesWithoutWildcards()) {
            if (!vInventory.findVulnerabilityByName(name).isPresent()) {
                final Vulnerability vulnerability = vInventory.findOrCreateVulnerabilityByName(name);
                VulnerabilityTypeStore.get().inferSourceIdentifierFromIdIfAbsent(vulnerability);
                createdVulnerabilitySources.put(vulnerability, cveStatusHistory.getOriginYamlFile());
            }
        }
    }

    // add a matching source to all vulnerabilities that have been created by status files
    for (Map.Entry<Vulnerability, File> vulnerabilityFileEntry : createdVulnerabilitySources.entrySet()) {
        final Vulnerability vulnerability = vulnerabilityFileEntry.getKey();
        final File file = vulnerabilityFileEntry.getValue();

        vulnerability.addMatchingSource(DataSourceIndicator.assessmentStatus(file));
    }

    final int vulnerabilityCountAfter = vInventory.getVulnerabilities().size();

    LOG.info("Found [{}] status files with a total of [{}] affected vulnerabilities, applying to an inventory with [{}] vulnerabilities (merged & deduplicated total: [{}])",
            anyScopeStatus.size(), vulnerabilityCountAfter - vulnerabilityCountBefore, vulnerabilityCountBefore, vulnerabilityCountAfter);


    // iterate over remaining vulnerabilities and apply the ARTIFACT status entries
    for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
        addStatusEntriesForVulnerability(vInventory, artifactScopeStatus, vulnerability, createdVulnerabilitySources.containsKey(vulnerability));
    }

    vInventory.writeBack(true);
} finally {
    VulnerabilityStatus.LOG_MATCHING_CRITERIA = logMatchingCriteriaPreviousValue;
}
```

</details>




---

# Security Advisory Matching

## GHSA metadata query

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## CERT-FR metadata query

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## CERT-SEI metadata query

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




## CERT-EU metadata query

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(inventory, vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(inventory, vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

vInventory.writeBack(true);
```

</details>




---

# Vulnerability Prioritization

## EOL

<details>

<summary>Source Code for <code>EolEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
int count = 0;
final Map<String, Set<EolCycle>> matchedEolCyclesTracker = new HashMap<>();

for (Artifact artifact : inventory.getArtifacts()) {
    final Map<String, Set<EolCycle>> result = performEnrichmentOnSingleArtifact(artifact);
    if (result == null) continue;
    matchedEolCyclesTracker.putAll(result);
    count++;
}

LOG.info("Added EOL Information to [{}] artifacts for products: {}",
        count,
        matchedEolCyclesTracker.entrySet().stream().map(e -> e.getKey() + " (" + e.getValue().stream().map(EolCycle::getCycle).collect(Collectors.joining(", ")) + ")").collect(Collectors.joining(", ")));
```

</details>


<details>

<summary>Source Code for <code>EolEnrichment.performEnrichmentOnSingleArtifact(Artifact artifact)</code> </summary>

```java
if (!artifact.has(InventoryAttribute.EOL_ID.getKey())) {
    return null;
}

final String[] eolIds = artifact.get(InventoryAttribute.EOL_ID.getKey()).split(", ");
final Map<String, Set<EolCycle>> matchedEolCyclesTracker = new HashMap<>();

for (String eolId : eolIds) {
    final EolLifecycle lifecycle = this.eolIndexQuery.findCyclesByProduct(eolId);

    if (lifecycle == null || lifecycle.getCycles().isEmpty()) {
        LOG.warn("No EOL information found for product: {}", eolId);
        continue;
    }

    final String cycleQueryVersion = ObjectUtils.firstNonNull(
            artifact.get(InventoryAttribute.EOL_OVERWRITE_CYCLE_QUERY_VERSION),
            artifact.get(Artifact.Attribute.VERSION)
    );
    final String latestVersionQueryVersion = ObjectUtils.firstNonNull(
            artifact.get(InventoryAttribute.EOL_OVERWRITE_LATEST_VERSION_QUERY_VERSION),
            artifact.get(Artifact.Attribute.VERSION)
    );

    final EolCycle currentCycle = lifecycle.findCycleFromVersion(cycleQueryVersion);

    if (currentCycle == null) {
        if (cycleQueryVersion == null) {
            LOG.warn("Lifecycle found for product [{}], artifact query version [{}] [{}] is null on artifact [{}]", eolId, cycleQueryVersion, latestVersionQueryVersion, artifact.get(Artifact.Attribute.ID));
        } else {
            LOG.warn("Lifecycle found for product [{}], artifact query version [{}] [{}] on artifact [{}] cannot be found in cycle data", eolId, cycleQueryVersion, latestVersionQueryVersion, artifact.get(Artifact.Attribute.ID));
        }
        continue;
    }

    this.performEnrichmentOnArtifactAndCycle(lifecycle, artifact, currentCycle, latestVersionQueryVersion);
    matchedEolCyclesTracker.computeIfAbsent(eolId, k -> new HashSet<>()).add(currentCycle);
}

return matchedEolCyclesTracker;
```

</details>


<h3 id="interpreting-the-data">Interpreting the data</h3>
<p>The 6 values we actually use from the data source can either be a Boolean or a date:</p>
<ul>
<li>EOL (End of Life): Generally, whether something has reached the end-of-life state, i.e., both support and extended
support have expired.</li>
<li>Support: Whether the basic support is still valid.</li>
<li>Extended Support: Something like security support or similar, is usually either not set or equals the EOL date.</li>
<li>LTS (Long Term Support): If Boolean, whether the cycle is LTS; if Date, when the cycle becomes LTS.</li>
<li>Discontinued: Whether the cycle is explicitly marked as discontinued, is often not set.</li>
<li>Technical Guidance: When the technical guidance support ends, is often not set.</li>
</ul>
<p>If the value ist a date, it always indicates when this state will be reached. Except for LTS, reaching this date is
always something negative.</p>
<p>We can differentiate the lifecycle state of a product based on whether extended support is available or not. Here are
the two scenarios:</p>
<h4 id="scenario-1-extended-support-is-available">Scenario 1: Extended Support is Available</h4>
<ol>
<li>Green: EOL has not been reached, both support and extended support are still valid.</li>
<li>Light Green: Support ends in less than X months (configurable, default is 6 months).</li>
<li>Yellow: Support is no longer valid, but extended support is still in effect.</li>
<li>Orange: Extended support ends in less than X months (configurable, default is 6 months).</li>
<li>Red: EOL has been reached, extended support is no longer valid.</li>
</ol>
<h4 id="scenario-2-extended-support-is-not-available">Scenario 2: Extended Support is Not Available</h4>
<p>In this case, phases 3 and 4 are skipped and the cycle immediately reaches the end of life.</p>
<ol>
<li>Green: EOL has not been reached, support is still valid.</li>
<li>Orange: Support ends in less than X months (configurable, default is 6 months).</li>
<li>Red: EOL has been reached, support is no longer valid.</li>
</ol>



## EPSS

<details>

<summary>Source Code for <code>EpssEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    Optional<EpssData> epssData = epssIndexQuery.getEpssData(vulnerability);
    if (!epssData.isPresent()) {
        log.info("No EPSS data found for vulnerability: " + vulnerability.getId());
        continue;
    }
    vulnerability.setEpssData(epssData.get());
}

vInventory.writeBack();
```

</details>




## KEV

<details>

<summary>Source Code for <code>KevEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
final KevIndexQuery kevIndexQuery = kevIndexQueryLazySupplier.get();

final Set<String> foundKevFromVulnerabilities = new LinkedHashSet<>();
for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    kevIndexQuery.findKevDataForVulnerability(vulnerability.getId())
            .ifPresent(kevData -> {
                vulnerability.setKevData(kevData);
                foundKevFromVulnerabilities.add(vulnerability.getId());
            });
}

log.info("Found KEV information for [{}] vulnerabilities", foundKevFromVulnerabilities.size());
log.debug("Found KEV information for the following vulnerabilities: {}", foundKevFromVulnerabilities);

vInventory.writeBack();
```

</details>




---

# Post Processing

## Vulnerability Status post-processing

<details>

<summary>Source Code for <code>VulnerabilityStatusPostProcessingEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

final VulnerabilityStatusPostProcessor processor = new VulnerabilityStatusPostProcessor();
processor.setMsrcProductIndexQuery(this.msrcProductIndexQuery);
processor.setGhsaAdvisorIndexQuery(this.ghsaAdvisorIndexQuery);

for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    final VulnerabilityStatus assessmentStatus = vulnerability.getVulnerabilityStatus();
    if (assessmentStatus == null) {
        continue;
    }

    for (VulnerabilityStatusHistoryEntry historyEntry : assessmentStatus.getStatusHistory()) {
        processor.resolveVariablesHandler(vInventory, vulnerability, historyEntry.getMeasures(), historyEntry::setMeasures);
        processor.resolveVariablesHandler(vInventory, vulnerability, historyEntry.getRisk(), historyEntry::setRisk);
        processor.resolveVariablesHandler(vInventory, vulnerability, historyEntry.getRationale(), historyEntry::setRationale);
        processor.resolveVariablesHandler(vInventory, vulnerability, historyEntry.getAuthor(), historyEntry::setAuthor);
    }

    processor.resolveVariablesHandler(vInventory, vulnerability, assessmentStatus.getReportedDate(), assessmentStatus::setReportedDate);
}

vInventory.writeBack(true);
```

</details>




## Vulnerability Filter

<details>

<summary>Source Code for <code>VulnerabilityFilterEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final FilterAttribute filter = configuration.getVulnerabilityIncludeFilterAttribute();
if (filter == null) {
    LOG.warn("No vulnerability filter configured, skipping enrichment [{}]", getEnrichmentName());
    return;
}
LOG.info("");
LOG.info("Filtering vulnerabilities using {}", configuration.getVulnerabilityIncludeFilter());
LOG.info("Parsed vulnerability filter: {}", filter);

final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
vInventory.calculateEffectiveCvssVectorsForVulnerabilities(super.getSecurityPolicyConfiguration());

final int size = vInventory.getVulnerabilities().size();
for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (!filter.matches(vulnerability)) {
        vInventory.remove(vulnerability);
    }
}
vInventory.writeBack(true);

LOG.info("Filtered vulnerabilities [{} - {} = {}]", size, size - inventory.getVulnerabilityMetaData().size(), inventory.getVulnerabilityMetaData().size());
```

</details>




## Inventory Validation

<details>

<summary>Source Code for <code>InventoryValidationEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final List<InventoryValidator> validators = configuration.buildValidators();

final Map<InventoryValidator, List<InventoryValidationReason>> validationErrorReasons = new LinkedHashMap<>();

for (InventoryValidator validator : validators) {
    validator.beforeValidation(baseMirrorDirectory);

    LOG.info("Validating inventory with validator: [{}]", validator.getValidatorName());

    try {
        final List<InventoryValidationReason> reasons = validator.validate(inventory);

        for (InventoryValidationReason reason : reasons) {
            validationErrorReasons.computeIfAbsent(validator, k -> new ArrayList<>()).add(reason);
        }
    } catch (Exception e) {
        throw new IllegalStateException("Performing the validation failed for validator " + validator.getValidatorName() + ": " + e.getMessage(), e);
    }

    if (validationErrorReasons.getOrDefault(validator, Collections.emptyList()).isEmpty()) {
        LOG.info("No validation failures found");
    } else {
        LOG.warn("Found [{}] validation failures", validationErrorReasons.values().stream().mapToInt(List::size).sum());
    }
}

cachedValidationFailReasons.computeIfAbsent(inventory, k -> new ArrayList<>())
        .addAll(validationErrorReasons.values().stream().flatMap(Collection::stream).collect(Collectors.toList()));


if (!validationErrorReasons.isEmpty()) {
    final int count = validationErrorReasons.values().stream().mapToInt(List::size).sum();
    final String longDescriptions = buildValidationLongDescriptions(Collections.singletonList(validationErrorReasons));

    final String logMessage = "Inventory Validation failures in " + count + " instance" + (count == 1 ? "" : "s") + ":\n" +
            buildValidationFailReasonsReport(validationErrorReasons) +
            "\n" + longDescriptions + "\n";

    if (configuration.isFailOnValidationErrors()) {
        throw new IllegalStateException(logMessage);
    } else {
        if (configuration.isAddAsCorrelationWarnings()) {
            addInventoryWarningsToInventory(inventory, cachedValidationFailReasons.get(inventory));
        }
        LOG.error(logMessage);
    }
} else {
    LOG.info("Inventory Validation successful.");
}
```

</details>




---

# Reporting

## Vulnerability Assessment Dashboard

<details>

<summary>Source Code for <code>VulnerabilityAssessmentDashboard.performEnrichment(Inventory inventory)</code> </summary>

```java
LOG.info("Parsing inventory data");
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);

LOG.info("Baking effective CVSS vectors");
vInventory.calculateEffectiveCvssVectorsForVulnerabilities(super.getSecurityPolicyConfiguration());
LOG.info("Applying effective vulnerability status");
vInventory.applyEffectiveVulnerabilityStatus(super.getSecurityPolicyConfiguration());

LOG.info("Using calculated values for potential vulnerability filtering");
final List<Vulnerability> effectiveVulnerabilities = VulnerabilityAssessmentDashboard.getEffectiveVulnerabilitiesAll(vInventory, configuration, super.getSecurityPolicyConfiguration());

LOG.info("Initializing dashboard");
final Dashboard dashboard = this.initializeDashboard(vInventory);

LOG.info("Starting dashboard generation");
final Map<Artifact, List<Vulnerability>> vulnerabilitiesPerArtifact = Vulnerability.groupVulnerabilitiesByArtifact(effectiveVulnerabilities);
final Map<Vulnerability, VadDetailLevelConfiguration> vulnerabilityDetails = this.determineVulnerabilityDetailLevels(effectiveVulnerabilities);

this.setFaviconDependingOnVulnerabilityPresence(dashboard, !effectiveVulnerabilities.isEmpty());

final VulnerabilityTimelineGeneratorResult vulnerabilityTimelines = generateApplicableVulnerabilityTimelines(effectiveVulnerabilities, vulnerabilityDetails);

LOG.info("Processing vulnerabilities...");

final Modal inventoryWarningsModal = createInventoryWarningsModal(inventory, vulnerabilityDetails.keySet());
dashboard.addModal(inventoryWarningsModal);

LOG.info("");
for (Vulnerability vulnerability : effectiveVulnerabilities) {
    final VadDetailLevelConfiguration detailLevel = vulnerabilityDetails.get(vulnerability);

    super.executor.submit(() -> {
        LOG.debug("Processing vulnerability: [{}]", vulnerability.getId());
        try {
            dashboard.addSheet(createVulnerabilitySheet(vulnerability, effectiveVulnerabilities, vulnerabilityTimelines, detailLevel));
        } catch (Exception e) {
            LOG.error("Failed to create vulnerability sheet for vulnerability: {}", vulnerability.getId(), e);
            throw new RuntimeException("Failed to create vulnerability sheet for vulnerability: " + vulnerability.getId(), e);
        }
    });
}

executor.setSize(1);
executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for all vulnerability sheets to be created", e);
}

dashboard.sortSheets(Comparator.comparing(sheet -> {
    final String id = sheet.getId();
    if (id.equalsIgnoreCase("inventory warnings")) {
        return "!!!inventory warnings";
    } else {
        return id;
    }
}));


LOG.info("Generating overview charts");
final VulnerabilityOverviewChartGenerator overviewChartGenerator = new VulnerabilityOverviewChartGenerator(vInventory, super.getSecurityPolicyConfiguration(), effectiveVulnerabilities, vulnerabilitiesPerArtifact);
final List<GeneratedChart> overviewCharts = overviewChartGenerator.generateOverviewCharts();

for (GeneratedChart overviewChart : overviewCharts) {
    overviewChart.writeSvgTo(configuration.getSvgDirectory());
}

dashboard.addModal(generateOverviewModal(overviewCharts));
dashboard.addModal(generateAssessmentEditorModal());

dashboard.addBottomLeftBadge(inventory.getArtifacts().size() + " artifact" + plural(inventory.getArtifacts().size()));
dashboard.addBottomLeftBadge(effectiveVulnerabilities.size() + " vulnerabilitie" + plural(effectiveVulnerabilities.size()));
dashboard.addBottomLeftBadge(vInventory.getSecurityAdvisories().size() + " advisorie" + plural(vInventory.getSecurityAdvisories().size()));
{
    final int ignoredVulnerabilitiesCount = vInventory.getVulnerabilities().size() - effectiveVulnerabilities.size();
    if (ignoredVulnerabilitiesCount > 0) {
        dashboard.addBottomLeftBadge(ignoredVulnerabilitiesCount + " ignored");
    }
}
addAdditionalInventoryInformation(inventory, dashboard);

// FIXME: implement missing behavior
// checkForFailReasons(statistics);

try {
    dashboard.generateIntoFile(configuration.getOutputDashboardFile());
    LOG.info("Wrote dashboard to file: {}", configuration.getOutputDashboardFile().getAbsolutePath());
} catch (IOException e) {
    throw new RuntimeException("Failed to write dashboard to file: " + configuration.getOutputDashboardFile(), e);
}
```

</details>


This class uses an inventory to generate a 'Vulnerability Assessment Dashboard' as single-page HTML file.



---

# Other standalone steps

## Advisor Periodic

<details>

<summary>Source Code for <code>AdvisorPeriodicEnrichment.performEnrichment(Inventory inventory)</code> </summary>

```java
final Map<String, Inventory> parsedReferenceInventories = new LinkedHashMap<>();

// reference inventory must be first for merging later on
if (configuration.hasInitialInventoryContextName()) {
    parsedReferenceInventories.put(configuration.getInitialInventoryContextName(), inventory);
}
parsedReferenceInventories.putAll(configuration.parseReferenceInventories());


final Map<String, VulnerabilityContextInventory> vParsedReferenceInventories = VulnerabilityContextInventory.fromInventories(parsedReferenceInventories);

final Inventory outputInventory = new Inventory();
final VulnerabilityContextInventory vOutputInventory = VulnerabilityContextInventory.fromInventory(outputInventory);

LOG.info("Listing all advisories for changed entries of {} since [{} --> {} / {}]",
        configuration.getAdvisoryProviders(), configuration.getChangedSinceTimestamp(),
        TimeUtils.formatNormalizedDate(new Date(configuration.getChangedSinceTimestamp())),
        TimeUtils.formatTimeUntilOrAgoDefault(configuration.getChangedSinceTimestamp() - System.currentTimeMillis()));

final InventoryInfo info = outputInventory.findOrCreateInventoryInfo(ADVISOR_PERIODIC_QUERY_KEY);
info.set(ADVISOR_PERIODIC_QUERY_RANGE_START_KEY, new SimpleDateFormat("yyyy-MM-dd").format(configuration.getChangedSinceTimestamp()));
info.set(ADVISOR_PERIODIC_QUERY_RANGE_END_KEY, new SimpleDateFormat("yyyy-MM-dd").format(System.currentTimeMillis()));

// set up the index for the advisory providers
final PeriodicDataSourcesOperations periodicDataSourcesOperations = new PeriodicDataSourcesOperations();
periodicDataSourcesOperations.addAdvisorIndexQueriesForContentIdentifiers(baseMirrorDirectory, configuration.getAdvisoryProviders());


final List<AdvisoryEntry> securityAdvisoriesUpdatedOrModifiedSince = periodicDataSourcesOperations.findSecurityAdvisoriesUpdatedOrModifiedSince(
        configuration.getChangedSinceTimestamp(),
        configuration.getAdvisoryProviders(),
        configuration.getIncludeAdvisoryTypes()
);
vOutputInventory.addAllAdvisories(securityAdvisoriesUpdatedOrModifiedSince);

// if there are reference inventories, mark the AdvisoryMetaData entries as [unaffected, new, in progress, reviewed] based on whether they are listed as reviewed or not.
periodicDataSourcesOperations.setSecurityAdvisoryReviewedStatusFromReferenceInventories(
        vOutputInventory.getSecurityAdvisories(),
        vParsedReferenceInventories.values()
);

this.filterInventoryDataPreMerge(vOutputInventory, periodicDataSourcesOperations);

this.mergeReferenceInventoriesToSourceInventory(vOutputInventory, parsedReferenceInventories, outputInventory);

// mark all the advisories that have been added by the merger as 'unclassified'
for (AdvisoryEntry securityAdvisory : vOutputInventory.getShallowCopySecurityAdvisories()) {
    if (securityAdvisory.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS) == null) {
        securityAdvisory.setAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS, AdvisoryMetaData.STATUS_VALUE_UNCLASSIFIED);
    }
}

this.filterInventoryDataPostMerge(vOutputInventory, periodicDataSourcesOperations);

vOutputInventory.writeBack(true);
this.logReviewStateCounts(vOutputInventory.getSecurityAdvisories());

// move all data from the output inventory to the original inventory so that the original inventory is enriched
super.moveInventoryData(outputInventory, inventory);
```

</details>




## Inventory Pipeline

<details>

<summary>Source Code for <code>InventoryEnrichmentPipeline.performEnrichment(Inventory inventory)</code> </summary>

```java
// this method will change the IDs of the enrichers to be unique, by appending a numerical suffix in case a duplicate exists
assignEffectiveIdsToEnrichers();

// copy over security policy configuration if not set on enricher
if (super.isSecurityPolicyConfigurationDefined()) {
    for (InventoryEnricher enricher : enrichers) {
        if (!enricher.isSecurityPolicyConfigurationDefined()) {
            enricher.setSecurityPolicyConfiguration(super.getSecurityPolicyConfiguration());
        }
    }
}

LOG.info("Enrichment order:");
for (InventoryEnricher inventoryEnricher : enrichers) {
    LOG.info(formatEnrichmentListEntry(inventoryEnricher, -1));
}

assertCorrectlyConfigured();

logCentralSecurityConfiguration();

RuntimeException enrichmentException = null;
InventoryEnricher failedEnricher = null;
// if resumeAtEnricher is null, do not skip any
boolean resumeAtEnricherFound = resumeAtEnricher == null;

final Map<InventoryEnricher, Long> enrichmentDurations = new LinkedHashMap<>();

for (InventoryEnricher enricher : enrichers) {
    if (!resumeAtEnricherFound) {
        if (enricher == resumeAtEnricher) {
            resumeAtEnricherFound = true;
        } else {
            continue;
        }
    }

    if (storeIntermediateStepsInInventoryInfo) {
        this.appendInventoryInfoStep(inventory, enricher);
    }

    final long startTime = TimeUtils.utcNow();

    try {
        enricher.performEnrichmentIfActive(inventory);

        progressListeners.forEach(l -> l.accept(enricher, inventory));
        if (writeIntermediateInventories && enricher.shouldWriteIntermediateInventory()) {
            this.writeInventoryToFileAsEnricher(enricher);
        }
    } catch (Exception e) {
        LOG.error("Failed to enrich inventory on step [{}], see stack trace below for more information.\n{}", enricher.getEnrichmentName(), e.getMessage());

        try {
            if (writeIntermediateInventories && enricher.shouldWriteIntermediateInventory()) {
                this.writeInventoryToFileAsEnricher(enricher);
            }
        } catch (Exception inventoryWriteException) {
            LOG.error("Failed to write intermediate inventory", e);
        }

        LOG.error(formatLogHeader("FAILED: " + enricher.getEnrichmentName()));
        enrichmentException = new RuntimeException("Failed to enrich inventory on step " + enricher.getEnrichmentName() + "\n" + e.getMessage(), e);
        failedEnricher = enricher;

        break;
    } finally {
        enrichmentDurations.put(enricher, TimeUtils.utcNow() - startTime);
    }
}

if (enrichmentException == null) {
    LOG.info("All enrichment steps have been applied successfully:");
} else {
    LOG.info("To resume from failed step, use id [{}]", failedEnricher.getConfiguration().getId());
}
for (InventoryEnricher enricher : enrichers) {
    if (enricher == failedEnricher) {
        LOG.info("Failed at:");
    }
    LOG.info(formatEnrichmentListEntry(enricher, enrichmentDurations.getOrDefault(enricher, 0L)));
}
LOG.info("");

if (enrichmentException != null) {
    LOG.error("Failed to enrich inventory: {}", enrichmentException.getMessage(), enrichmentException);
    throw enrichmentException;
}

{
    final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
    vInventory.calculateEffectiveCvssVectorsForVulnerabilities(super.getSecurityPolicyConfiguration());
    vInventory.writeBack();
    vInventory.writeAdditionalInformationBack(super.getSecurityPolicyConfiguration());
}

if (writeIntermediateInventories) {
    writeInventoryToFileAsEnricher(this);
}

if (inventoryResultFile != null) {
    try {
        if (!inventoryResultFile.getParentFile().exists()) {
            inventoryResultFile.getParentFile().mkdirs();
        }
        new InventoryWriter().writeInventory(inventory, inventoryResultFile);
    } catch (IOException e) {
        throw new RuntimeException("Failed to write inventory to " + inventoryResultFile, e);
    }
}

logInventoryResultStatistics(inventory);
```

</details>




---
