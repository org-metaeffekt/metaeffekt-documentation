> [Documentation](../../README.md) >
> [Vulnerability Management](../vulnerability-management.md) >
> [Inventory Enrichment Pipeline](inventory-enrichment-pipeline.md) >
> Inventory Enrichment Steps

# Inventory Enrichment Steps

> [Overview](#overview) -
> [POM Configuration](#pom-configuration) -
> [Steps](#product-identification)

## Overview

The inventory enrichment pipeline has already been described with a quick overview in the
[Inventory Enrichment Pipeline](inventory-enrichment-pipeline.md) chapter.
This chapter provides a detailed description of each step in the inventory enrichment pipeline.
While it is theoretically possible to construct a pipeline that runs the following steps in any order,
on a conceptual level, only a specific order makes sense.
This is why the steps are divided into separate phases, which are executed in a specific order, but within each phase,
the steps can be executed in any order.

In some cases, such as with the Vulnerability Details Fill phase,
a phase might have to run twice if certain conditions are met.
In order to reduce the length of the following list, these duplications have been omitted.
The descriptions when a phase has to run twice are included in the respective phase's description,
but the responsible Maven plugin manages this automatically, so that you, as a user, will not have to worry about this.

- **[Product Identification](#product-identification)**
  - [CPE URI derivation](#cpe-uri-derivation)
  - [Artifact Correlation YAML](#artifact-correlation-yaml)
  - [Package URL derivation](#package-url-derivation)
- **[Vulnerability Matching](#vulnerability-matching)**
  - [NVD CVE from CPE](#nvd-cve-from-cpe)
  - [MSRC Vulnerabilities by Products](#msrc-vulnerabilities-by-products)
  - [Custom Vulnerabilities from CPE](#custom-vulnerabilities-from-cpe)
  - [OSV Vulnerabilities](#osv-vulnerabilities)
  - [CSAF Vulnerabilities](#csaf-vulnerabilities)
- **[Vulnerability Details Filling](#vulnerability-details-filling)**
  - [NVD Vulnerability Details](#nvd-vulnerability-details)
  - [MSRC Vulnerability Details](#msrc-vulnerability-details)
  - [Custom Vulnerability Details](#custom-vulnerability-details)
  - [CAPEC Details](#capec-details)
  - [CWE Details](#cwe-details)
- **[Assessments](#assessments)**
  - [Vulnerability Status](#vulnerability-status)
  - [Vulnerability Keywords](#vulnerability-keywords)
- **[Security Advisory Matching](#security-advisory-matching)**
  - [CERT-FR Advisor Details](#cert-fr-advisor-details)
  - [CERT-SEI Advisor Details](#cert-sei-advisor-details)
  - [CERT-EU Advisor Details](#cert-eu-advisor-details)
  - [CSAF Advisor Details](#csaf-advisor-details)
  - [OSV Vulnerability Details](#osv-vulnerability-details)
- **[Vulnerability Prioritization](#vulnerability-prioritization)**
  - [EOL Date](#eol-date)
  - [EPSS Enrichment](#epss-enrichment)
  - [KEV Enrichment](#kev-enrichment)
- **[Inventory Post Processing](#inventory-post-processing)**
  - [Vulnerability Status Post Processing](#vulnerability-status-post-processing)
  - [Vulnerability Filtering](#vulnerability-filtering)
  - [Inventory Validation](#inventory-validation)
  - [Inventory Post Processing](#inventory-post-processing)
- **[Reporting](#reporting)**
  - [Vulnerability Assessment Dashboard](#vulnerability-assessment-dashboard)
- **[Standalone](#standalone)**
  - [Advisor periodic](#advisor-periodic)


## POM Configuration

The enrichment configuration is part of the `ae-inventory-enrichment-plugin` configuration in the Maven POM.
An example configuration with all available enrichment steps is provided below.

<details>

<summary>Click to show the full POM configuration with all configuration parameters</summary>

```xml
<plugins>
    <plugin>
        <groupId>com.metaeffekt.artifact.analysis</groupId>
        <artifactId>ae-inventory-enrichment-plugin</artifactId>
        <version>${ae.artifact.analysis.version}</version>

        <executions>
            <execution>
                <id>enrich-inventory</id>
                <goals>
                    <goal>enrich-inventory</goal>
                </goals>

                <configuration>
                    <!-- General Configuration -->
                    <mirrorDirectory>${database.path}</mirrorDirectory>

                    <inventoryInputFile>${inventory.path}</inventoryInputFile>
                    <inventoryOutputFile>${inventory.path}-result.xlsx</inventoryOutputFile>
                    <intermediateInventoriesDirectory>${inventory.path}/intermediate-inventories</intermediateInventoriesDirectory>

                    <writeIntermediateInventories>true</writeIntermediateInventories>
                    <storeIntermediateStepsInInventoryInfo>true</storeIntermediateStepsInInventoryInfo>

                    <!-- resume the pipeline at a specific step by its id -->
                    <!--<resumeAtEnrichment></resumeAtEnrichment>-->

                    <!-- Security Policy Configuration -->
                    <!--<securityPolicy></securityPolicy>-->
                    <!--<securityPolicyFile></securityPolicyFile>-->
                    <!--<securityPolicyOverwriteJson></securityPolicyOverwriteJson>-->


                    <!-- Product Identification -->
                    <cpeDerivationEnrichment>
                      <maxCorrelatedCpePerArtifact>2147483647</maxCorrelatedCpePerArtifact>
                      <!-- <requireSecondaryIndicationTermsLimiters/> --> <!-- type: List -->
                      <addDetailedMatchingInformation>false</addDetailedMatchingInformation>
                    </cpeDerivationEnrichment>
                    
                    <correlationYamlEnrichment>
                      <yamlFiles>
                        <!-- <file>...</file> -->
                      </yamlFiles>
                    </correlationYamlEnrichment>
                    
                    <purlDerivationEnrichment/>
                    
                    <!-- Vulnerability Matching -->
                    <nvdMatchCveFromCpeEnrichment/>
                    
                    <msVulnerabilitiesByProductEnrichment/>
                    
                    <customVulnerabilitiesFromCpeEnrichment/>
                    
                    <osvVulnerabilitiesEnrichment>
                      <githubReviewed>false</githubReviewed>
                      <includeAdvisoryProviders>[{"implementation":"OSV","name":"*"}]</includeAdvisoryProviders>
                      <excludeNvdEquivalent>true</excludeNvdEquivalent>
                    </osvVulnerabilitiesEnrichment>
                    
                    <csafVulnerabilitiesEnrichment>
                      <excludedCsafSources>
                        <!-- <excludedCsafSource>...</excludedCsafSource> -->
                      </excludedCsafSources>
                    </csafVulnerabilitiesEnrichment>
                    
                    <!-- Vulnerability Details Filling -->
                    <nvdCveFillDetailsEnrichment/>
                    
                    <msrcAdvisorFillDetailsEnrichment>
                      <excludeNvdEquivalent>true</excludeNvdEquivalent>
                    </msrcAdvisorFillDetailsEnrichment>
                    
                    <customVulnerabilitiesFillDetailsEnrichment>
                      <vulnerabilityFiles>
                        <!-- <file>...</file> -->
                      </vulnerabilityFiles>
                    </customVulnerabilitiesFillDetailsEnrichment>
                    
                    <capecFillDetailsEnrichment/>
                    
                    <cweFillDetailsEnrichment/>
                    
                    <!-- Assessments -->
                    <vulnerabilityStatusEnrichment>
                      <statusFiles>
                        <!-- <file>...</file> -->
                      </statusFiles>
                      <additionalStatus>
                        <!-- <status>...</status> -->
                      </additionalStatus>
                      <activeLabels>
                        <!-- <activeLabel>...</activeLabel> -->
                      </activeLabels>
                      <failOnValidationErrors>false</failOnValidationErrors>
                      <failOnAmbiguousMatchingInformation>false</failOnAmbiguousMatchingInformation>
                    </vulnerabilityStatusEnrichment>
                    
                    <vulnerabilityKeywordsEnrichment>
                      <yamlFiles>
                        <!-- <file>...</file> -->
                      </yamlFiles>
                      <activeLabels>
                        <!-- <activeLabel>...</activeLabel> -->
                      </activeLabels>
                      <failOnValidationErrors>false</failOnValidationErrors>
                    </vulnerabilityKeywordsEnrichment>
                    
                    <!-- Security Advisory Matching -->
                    <certFrAdvisorEnrichment/>
                    
                    <certSeiAdvisorEnrichment/>
                    
                    <certEuAdvisorEnrichment/>
                    
                    <csafAdvisorEnrichment/>
                    
                    <osvAdvisorFillDetailsEnrichment>
                      <includeAdvisoryProviders>[{"implementation":"OSV","name":"*"}]</includeAdvisoryProviders>
                      <lastCachedIncludeAdvisoryProviders>-1</lastCachedIncludeAdvisoryProviders>
                      <!-- <cachedIncludeAdvisoryProviders/> --> <!-- type: List -->
                      <excludeNvdEquivalent>true</excludeNvdEquivalent>
                    </osvAdvisorFillDetailsEnrichment>
                    
                    <!-- Vulnerability Prioritization -->
                    <eolEnrichment>
                      <warningThresholdDaysSupport>180</warningThresholdDaysSupport>
                      <warningThresholdDaysExtendedSupport>180</warningThresholdDaysExtendedSupport>
                    </eolEnrichment>
                    
                    <epssEnrichment/>
                    
                    <kevEnrichment/>
                    
                    <!-- Inventory Post Processing -->
                    <vulnerabilityStatusPostProcessingEnrichment/>
                    
                    <vulnerabilityFilterEnrichment>
                      <!-- <vulnerabilityIncludeFilter/> --> <!-- type: String -->
                      <!-- <vulnerabilityIncludeFilterAttribute/> --> <!-- type: FilterAttribute -->
                    </vulnerabilityFilterEnrichment>
                    
                    <inventoryValidationEnrichment>
                      <failOnValidationErrors>false</failOnValidationErrors>
                      <addAsCorrelationWarnings>true</addAsCorrelationWarnings>
                      <!-- <additionalCpeIsNotEffectiveInventoryValidator/> --> <!-- type: AdditionalCpeIsNotEffectiveInventoryValidator -->
                      <!-- <multipleArtifactsAndVersionsOnVulnerabilityInventoryValidator/> --> <!-- type: MultipleArtifactsAndVersionsOnVulnerabilityInventoryValidator -->
                      <!-- <artifactAndCpeVersionsDifferGreatlyInventoryValidator/> --> <!-- type: ArtifactAndCpeVersionsDifferGreatlyInventoryValidator -->
                      <!-- <vulnerabilityInvalidNameValidator/> --> <!-- type: VulnerabilityInvalidNameValidator -->
                      <additionalValidators>
                        <!-- <validator>...</validator> -->
                      </additionalValidators>
                    </inventoryValidationEnrichment>
                    
                    <inventoryPostProcessingEnrichment>
                      <includeAdvisoryProviders>[{"implementation":"OSV","name":"*"}]</includeAdvisoryProviders>
                      <lastCachedIncludeAdvisoryProviders>-1</lastCachedIncludeAdvisoryProviders>
                      <!-- <cachedIncludeAdvisoryProviders/> --> <!-- type: List -->
                      <excludeNvdEquivalent>true</excludeNvdEquivalent>
                    </inventoryPostProcessingEnrichment>
                    
                    <!-- Reporting -->
                    <vulnerabilityAssessmentDashboardEnrichment>
                      <maximumVulnerabilitiesPerDashboardCount>2147483647</maximumVulnerabilitiesPerDashboardCount>
                      <!-- <vulnerabilityIncludeFilter/> --> <!-- type: String -->
                      <!-- <vulnerabilityIncludeFilterAttribute/> --> <!-- type: FilterAttribute -->
                      <maximumCpeForTimelinesPerVulnerability>2147483647</maximumCpeForTimelinesPerVulnerability>
                      <maximumVulnerabilitiesPerTimeline>2147483647</maximumVulnerabilitiesPerTimeline>
                      <maximumVersionsPerTimeline>2147483647</maximumVersionsPerTimeline>
                      <maximumTimeSpentOnTimelines>2147483647</maximumTimeSpentOnTimelines>
                      <maximumTimeSpentPerTimeline>2147483647</maximumTimeSpentPerTimeline>
                      <vulnerabilityTimelinesGlobalEnabled>true</vulnerabilityTimelinesGlobalEnabled>
                      <vulnerabilityTimelineHideIrrelevantVersions>true</vulnerabilityTimelineHideIrrelevantVersions>
                      <failOnVulnerabilityWithoutSpecifiedRisk>true</failOnVulnerabilityWithoutSpecifiedRisk>
                      <failOnUnreviewedAdvisories>true</failOnUnreviewedAdvisories>
                      <!-- <svgDirectory/> --> <!-- type: File -->
                      <vulnerabilitySvgChartInterpolationMethod>BASE_METRICS</vulnerabilitySvgChartInterpolationMethod>
                      <detailLevels>
                        <!-- <level>...</level> -->
                      </detailLevels>
                      <failOnUnreviewedAdvisoriesTypes>[]</failOnUnreviewedAdvisoriesTypes>
                      <!-- <outputDashboardFile/> --> <!-- type: File -->
                    </vulnerabilityAssessmentDashboardEnrichment>

                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

</details>

<details>

<summary>Click to show the shortened POM configuration</summary>

```xml
<plugins>
    <plugin>
        <groupId>com.metaeffekt.artifact.analysis</groupId>
        <artifactId>ae-inventory-enrichment-plugin</artifactId>
        <version>${ae.artifact.analysis.version}</version>

        <executions>
            <execution>
                <id>enrich-inventory</id>
                <goals>
                    <goal>enrich-inventory</goal>
                </goals>

                <configuration>
                    <!-- General Configuration -->
                    <mirrorDirectory>${database.path}</mirrorDirectory>

                    <inventoryInputFile>${inventory.path}</inventoryInputFile>
                    <inventoryOutputFile>${inventory.path}-result.xlsx</inventoryOutputFile>
                    <intermediateInventoriesDirectory>${inventory.path}/intermediate-inventories</intermediateInventoriesDirectory>

                    <writeIntermediateInventories>true</writeIntermediateInventories>
                    <storeIntermediateStepsInInventoryInfo>true</storeIntermediateStepsInInventoryInfo>

                    <!-- resume the pipeline at a specific step by its id -->
                    <!--<resumeAtEnrichment></resumeAtEnrichment>-->

                    <!-- Security Policy Configuration -->
                    <!--<securityPolicy></securityPolicy>-->
                    <!--<securityPolicyFile></securityPolicyFile>-->
                    <!--<securityPolicyOverwriteJson></securityPolicyOverwriteJson>-->


                    <!-- Product Identification -->
                    <cpeDerivationEnrichment/>
                    <correlationYamlEnrichment/>
                    <purlDerivationEnrichment/>
                    
                    <!-- Vulnerability Matching -->
                    <nvdMatchCveFromCpeEnrichment/>
                    <msVulnerabilitiesByProductEnrichment/>
                    <customVulnerabilitiesFromCpeEnrichment/>
                    <osvVulnerabilitiesEnrichment/>
                    <csafVulnerabilitiesEnrichment/>
                    
                    <!-- Vulnerability Details Filling -->
                    <nvdCveFillDetailsEnrichment/>
                    <msrcAdvisorFillDetailsEnrichment/>
                    <customVulnerabilitiesFillDetailsEnrichment/>
                    <capecFillDetailsEnrichment/>
                    <cweFillDetailsEnrichment/>
                    
                    <!-- Assessments -->
                    <vulnerabilityStatusEnrichment/>
                    <vulnerabilityKeywordsEnrichment/>
                    
                    <!-- Security Advisory Matching -->
                    <certFrAdvisorEnrichment/>
                    <certSeiAdvisorEnrichment/>
                    <certEuAdvisorEnrichment/>
                    <csafAdvisorEnrichment/>
                    <osvAdvisorFillDetailsEnrichment/>
                    
                    <!-- Vulnerability Prioritization -->
                    <eolEnrichment/>
                    <epssEnrichment/>
                    <kevEnrichment/>
                    
                    <!-- Inventory Post Processing -->
                    <vulnerabilityStatusPostProcessingEnrichment/>
                    <vulnerabilityFilterEnrichment/>
                    <inventoryValidationEnrichment/>
                    <inventoryPostProcessingEnrichment/>
                    
                    <!-- Reporting -->
                    <vulnerabilityAssessmentDashboardEnrichment/>

                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

</details>

<details>

<summary>Click to show the full default security policy configuration</summary>

See
[the data class](https://github.com/org-metaeffekt/metaeffekt-core/blob/master/libraries/ae-inventory-processor/src/main/java/org/metaeffekt/core/inventory/processor/report/configuration/CentralSecurityPolicyConfiguration.java)
for more details on the individual parameters.

```json
{
    "includeAdvisoryTypes": ["all"],
    "includeScoreThreshold": -1,
    "contextCvssSelector": {
        "stats": [{
            "comparator": "EQUAL",
            "action": "RETURN_NULL",
            "attribute": "assessment",
            "value": 0
        }],
        "rules": [
            {
                "method": "ALL",
                "stats": [],
                "selector": [
                    {
                        "host": ["NVD"],
                        "issuerRole": ["CNA"],
                        "issuer": ["NVD"]
                    },
                    {
                        "host": ["Microsoft Corporation"],
                        "issuerRole": ["*"],
                        "issuer": ["*"]
                    },
                    {
                        "host": ["NVD"],
                        "issuerRole": ["CNA"],
                        "issuer": ["Microsoft Corporation"]
                    },
                    {
                        "host": ["GitHub, Inc."],
                        "issuerRole": ["*"],
                        "issuer": ["*"]
                    },
                    {
                        "host": ["NVD"],
                        "issuerRole": ["CNA"],
                        "issuer": ["GitHub, Inc."]
                    },
                    {
                        "host": ["OSV"],
                        "issuerRole": ["*"],
                        "issuer": ["GitHub, Inc."]
                    },
                    {
                        "host": ["OSV"],
                        "issuerRole": ["*"],
                        "issuer": ["*"]
                    },
                    {
                        "host": ["CSAF"],
                        "issuerRole": ["*"],
                        "issuer": ["*"]
                    },
                    {
                        "host": ["NVD"],
                        "issuerRole": ["*"],
                        "issuer": ["*"]
                    },
                    {
                        "host": ["CERT-SEI"],
                        "issuerRole": ["*"],
                        "issuer": ["*"]
                    },
                    {
                        "host": ["not:Assessment"],
                        "issuerRole": ["*"],
                        "issuer": ["*"]
                    }
                ],
                "vectorEval": []
            },
            {
                "method": "ALL",
                "stats": [{
                    "provider": "PRESENCE",
                    "attribute": "assessment",
                    "setType": "ADD"
                }],
                "selector": [{
                    "host": ["Assessment"],
                    "issuerRole": ["*"],
                    "issuer": ["all"]
                }],
                "vectorEval": []
            },
            {
                "method": "LOWER",
                "stats": [{
                    "provider": "PRESENCE",
                    "attribute": "assessment",
                    "setType": "ADD"
                }],
                "selector": [{
                    "host": ["Assessment"],
                    "issuerRole": ["*"],
                    "issuer": ["lower"]
                }],
                "vectorEval": []
            },
            {
                "method": "HIGHER",
                "stats": [{
                    "provider": "PRESENCE",
                    "attribute": "assessment",
                    "setType": "ADD"
                }],
                "selector": [{
                    "host": ["Assessment"],
                    "issuerRole": ["*"],
                    "issuer": ["higher"]
                }],
                "vectorEval": []
            },
            {
                "method": "LOWER_METRIC",
                "stats": [{
                    "provider": "PRESENCE",
                    "attribute": "assessment",
                    "setType": "ADD"
                }],
                "selector": [{
                    "host": ["Assessment"],
                    "issuerRole": ["*"],
                    "issuer": ["lower metric"]
                }],
                "vectorEval": []
            },
            {
                "method": "HIGHER_METRIC",
                "stats": [{
                    "provider": "PRESENCE",
                    "attribute": "assessment",
                    "setType": "ADD"
                }],
                "selector": [{
                    "host": ["Assessment"],
                    "issuerRole": ["*"],
                    "issuer": ["higher metric"]
                }],
                "vectorEval": []
            }
        ],
        "vectorEval": [{
            "and": ["not:IS_BASE_FULLY_DEFINED"],
            "action": "RETURN_NULL"
        }]
    },
    "includeVulnerabilitiesWithAdvisoryProviders": [{
        "implementation": "all",
        "name": "all"
    }],
    "jsonSchemaValidationErrorsHandling": "STRICT",
    "includeVulnerabilitiesWithAdvisoryReviewStatus": ["all"],
    "generateOverviewTablesForAdvisories": [],
    "priorityScoreConfiguration": {
        "vulnerabilityStatus": {
            "add": {},
            "active": true,
            "set": {
                "not applicable": 0,
                "void": 0
            }
        },
        "eol": {
            "noExtendedSupport": {
                "supportValid": 0,
                "supportExpired": 2,
                "supportEndingSoon": 1.5
            },
            "extendedSupport": {
                "supportEndingSoon": 0.5,
                "extendedSupportEndingSoon": 1.5,
                "extendedSupportValid": 1,
                "supportValid": 0,
                "extendedSupportExpired": 2
            },
            "active": true
        },
        "epss": {
            "active": true,
            "min": 0.1,
            "f": 0.5,
            "F": 3.5
        },
        "keywords": {
            "knee": 3,
            "max": 5,
            "active": true
        },
        "cvss": {
            "active": true,
            "min": 0,
            "f": 0,
            "F": 6
        },
        "kev": {
            "exploit": 3,
            "active": true,
            "ransomware": 0.5
        }
    },
    "vulnerabilityStatusDisplayMapperName": "default",
    "insignificantThreshold": 7,
    "cvssSeverityRanges": "None:pastel-gray::0.0,Low:strong-yellow:0.1:3.9,Medium:strong-light-orange:4.0:6.9,High:strong-dark-orange:7.0:8.9,Critical:strong-red:9.0:",
    "includeAdvisoryProviders": [{
        "implementation": "all",
        "name": "all"
    }],
    "epssSeverityRanges": ">0.8:strong-red:0.8:,>0.1:strong-light-orange:0.1:0.8,>0.01:strong-yellow:0.01:0.1,≤0.01:pastel-gray::0.01",
    "cvssVersionSelectionPolicy": ["LATEST"],
    "priorityScoreSeverityRanges": "none:pastel-gray::4.9,elevated:strong-light-orange:5.0:6.9,due:strong-dark-orange:7.0:8.9,escalate:strong-red:9.0:",
    "initialCvssSelector": {
        "stats": [],
        "rules": [{
            "method": "ALL",
            "stats": [],
            "selector": [
                {
                    "host": ["NVD"],
                    "issuerRole": ["CNA"],
                    "issuer": ["NVD"]
                },
                {
                    "host": ["Microsoft Corporation"],
                    "issuerRole": ["*"],
                    "issuer": ["*"]
                },
                {
                    "host": ["NVD"],
                    "issuerRole": ["CNA"],
                    "issuer": ["Microsoft Corporation"]
                },
                {
                    "host": ["GitHub, Inc."],
                    "issuerRole": ["*"],
                    "issuer": ["*"]
                },
                {
                    "host": ["NVD"],
                    "issuerRole": ["CNA"],
                    "issuer": ["GitHub, Inc."]
                },
                {
                    "host": ["OSV"],
                    "issuerRole": ["*"],
                    "issuer": ["GitHub, Inc."]
                },
                {
                    "host": ["OSV"],
                    "issuerRole": ["*"],
                    "issuer": ["*"]
                },
                {
                    "host": ["CSAF"],
                    "issuerRole": ["*"],
                    "issuer": ["*"]
                },
                {
                    "host": ["NVD"],
                    "issuerRole": ["*"],
                    "issuer": ["*"]
                },
                {
                    "host": ["CERT-SEI"],
                    "issuerRole": ["*"],
                    "issuer": ["*"]
                },
                {
                    "host": ["not:Assessment"],
                    "issuerRole": ["*"],
                    "issuer": ["*"]
                }
            ],
            "vectorEval": []
        }],
        "vectorEval": []
    }
}
```

</details>

---

# Product Identification

A challenge for the vulnerability matching is that every vulnerability and security advisory provider uses different
formats and methods of identifying products and versions in their knowledge database.
A couple of examples for actual product identification methods are:

- The [National Vulnerability Database (NVD)](https://nvd.nist.gov/vuln)
  uses the [Common Platform Enumeration (CPE)](https://cpe.mitre.org/specification) to identify products,
- [Microsoft Security Response Center (MSRC)](https://www.microsoft.com/en-us/msrc)
  uses a numeric registry with a number for each product and version,
- [GitHub Security Advisories (GHSA)](https://github.com/advisories)
  and others use [Package URLs (PURLs)](https://github.com/package-url/purl-spec),
- [End Of Life](https://endoflife.date) uses unique string identifiers for each product,
- and so on.

This diversity of product identifiers is not represented in the initial software component inventory.
Therefore, the first step in the vulnerability matching process is to attempt to automatically derive product
identifiers from the component metadata, including artifact names, versions, and vendor information.

The following two steps are always performed to enable and improve the matching accuracy:

## CPE URI derivation

`cpe-derived` / `cpeDerivationEnrichment` / `cpe-derivation`

<details>

<summary>Source Code for <code>CpeDerivationEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final Inventory inventory = subject.getAsInventory(this);

final AtomicInteger progress = new AtomicInteger(0);
final AtomicInteger skippedArtifacts = new AtomicInteger(0);

this.cpeDerivationUtilities.setConfiguration(this.configuration);

final List<Artifact> artifacts = inventory.getArtifacts();
final Map<Artifact, Long> startTimes = new HashMap<>();

for (final Artifact artifact : artifacts) {
    if (!artifact.is(InventoryAttribute.ACTIVATE_CPE_URI_DERIVATION.getKey(), true)) {
        skippedArtifacts.incrementAndGet();
        continue;
    }

    if (!isValidForEnrichment(artifact)) {
        LOG.info("Missing required information on artifact [{}], skipping CPE URI derivation", artifact.getId());

        new InventoryWarnings(inventory).addArtifactWarning(new InventoryWarningEntry<>(artifact,
                "Cannot perform CPE URI derivation, missing required information.",
                this.getEnrichmentName()
        ));

        skippedArtifacts.incrementAndGet();
        continue;
    }

    super.executor.submit(() -> {
        final int currentElement = progress.incrementAndGet();
        if (currentElement % 100 == 0 && currentElement > 0) {
            LOG.info("Deriving CPE URIs for artifact [{} / {}]", currentElement, inventory.getArtifacts().size());
        }

        synchronized (startTimes) {
            startTimes.put(artifact, System.currentTimeMillis());
        }

        this.cpeDerivationUtilities.deriveCpeUris(inventory, artifact);

        synchronized (startTimes) {
            startTimes.remove(artifact);
        }
    });
}

final TimerTask checkArtifactTimerTask = new TimerTask() {
    @Override
    public void run() {
        final long currentTime = System.currentTimeMillis();
        synchronized (startTimes) {
            final List<Map.Entry<Artifact, Long>> longRunningArtifacts = startTimes.entrySet().stream()
                    .filter(e -> currentTime - e.getValue() >= 30000)
                    .sorted((o1, o2) -> o2.getValue().compareTo(o1.getValue()))
                    .collect(Collectors.toList());
            if (!longRunningArtifacts.isEmpty()) {
                LOG.warn("CPE URI derivation is taking longer than 30 seconds for [{}] artifacts: {}", longRunningArtifacts.size(), longRunningArtifacts.stream().map(Map.Entry::getKey).map(Artifact::getId).collect(Collectors.joining(", ")));
            }
        }
    }
};

final Timer checkArtifactTimer = new Timer();
checkArtifactTimer.schedule(checkArtifactTimerTask, 30000, 30000);

super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Interrupted while waiting for CPE URI derivation to finish", e);
}

checkArtifactTimer.cancel();

if (skippedArtifacts.get() > 0) {
    LOG.info("Skipped [{}] artifacts due to missing required information or deactivation via [{}]", skippedArtifacts.get(), InventoryAttribute.ACTIVATE_CPE_URI_DERIVATION.getKey());
}
```

</details>


<p>CPE URIs are vendor-product pairs that apply to single (or sometimes to multiple) components.
In order to derive them for each artifact, the certain artifact attributes are used to search for vendors/products.
These CPEs are then appended to the <code>Derived CPE URIs</code> of the artifacts.
This step is based on the principle of allowing more false positives than false negatives, since it is more important to identify all potential vulnerabilities which can be filtered out in later steps
either manually or automatically than to potentially miss critical vulnerabilities.</p>
<p>Example:</p>
<ul>
<li>Artifact with Id=<code>gdk-pixbuf2-2.36.12</code>, Component=<code>gdk-pixbuf2</code>, Version=<code>2.36.12</code></li>
<li>derives these aliases:
<code>gdk_pixbuf, gdk_pixbuf2, gdkpixbuf2, gdkpixbuf, gdk pixbuf2, gdk-pixbuf2, gdk pixbuf, gdk-pixbuf</code></li>
<li>finding these products → vendors: <code>gdk_pixbuf -&gt; [redhat], gdkpixbuf -&gt; [gnome], gdk-pixbuf -&gt; [gnome]</code></li>
<li>which maps to these CPEs: <code>cpe:/a:gnome:gdk-pixbuf, cpe:/a:gnome:gdkpixbuf, cpe:/a:redhat:gdk_pixbuf</code></li>
</ul>

#### Configuration: CPE Derivation

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maxCorrelatedCpePerArtifact</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>requireSecondaryIndicationTermsLimiters</code></td><td><code>new ArrayList<>(Collections.singletonList(new NvdCpeApiVendorProductIndexQuery.MinTermsLimiter(60).toJson().toMap()))</code></td></tr><tr><td colspan=2>The list of terms limiters to be used for determining the secondary indication terms. If multiple are provided, they will be applied in the order they are provided. <p> Default value is: <code>[{"type":"MinTermsLimiter","minTerms":60}]</code> which uses the <code>NvdCpeApiVendorProductIndexQuery.MinTermsLimiter</code> with a minimum of 60 terms. <p> Available types can be found next to <code>NvdCpeApiVendorProductIndexQuery.TermsLimiter</code> and include: <ul>     <li><code>NvdCpeApiVendorProductIndexQuery.MinTermsLimiter</code></li>     <li><code>NvdCpeApiVendorProductIndexQuery.MaxTermsLimiter</code></li>     <li><code>NvdCpeApiVendorProductIndexQuery.TopPTermsLimiter</code></li>     <li><code>NvdCpeApiVendorProductIndexQuery.TopNTermsLimiter</code></li></td></tr><tr><td><code>addDetailedMatchingInformation</code></td><td><code>false</code></td></tr></table>



## Artifact Correlation YAML

`correlation` / `correlationYamlEnrichment` / `artifact-correlation`

<details>

<summary>Source Code for <code>ArtifactCorrelationEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final Inventory inventory = subject.getAsInventory(this);

LOG.info("Performing enrichment using [{}] yaml file{} or director{}", configuration.getYamlFiles().size(), configuration.getYamlFiles().size() == 1 ? "" : "s", configuration.getYamlFiles().size() == 1 ? "y" : "ies");

for (File file : configuration.getYamlFiles()) {
    ArtifactCorrelationUtil.addYamlToInventory(inventory, file, super.getSecurityPolicyConfiguration().getJsonSchemaValidationErrorsHandling());
}
```

</details>


<details>

<summary>Source Code for <code>ArtifactCorrelationUtil.addYamlToInventory(Inventory inventory, List dataEntries)</code> </summary>

```java
if (inventory == null) {
    LOG.error("Inventory is null, canceling enrichment");
    return;
}

long totalCount = 0;
int appliedArtifacts = 0;

final List<Artifact> artifacts = inventory.getArtifacts();

for (int i = 0; i < artifacts.size(); i++) {
    final Artifact artifact = artifacts.get(i);
    final long count = dataEntries.stream()
            .filter(d -> d.affects(artifact))
            .peek(d -> d.apply(artifact, inventory)) // do not remove, IntelliJ is incorrect
            .count();

    totalCount += count;
    appliedArtifacts += count > 0 ? 1 : 0;

    if (i % 100 == 0 && i > 0) {
        LOG.info("[{} / {}] Applied [{}] entries to [{}] artifacts", i, artifacts.size(), totalCount, appliedArtifacts);
    }
}

LOG.info("Applied [{}] entries to [{}] artifacts", totalCount, appliedArtifacts);

CommonEnumerationUtil.distinctAndSortedWithWildcards(inventory);
```

</details>


<p>The automatic <code>com.metaeffekt.artifact.enrichment.vulnerability.CpeDerivationEnrichment</code>
and other automatic product identifier matching algorithms have no way of reliably and correctly performing their
task perfectly in all cases for several reasons
(such as spelling mistakes in the product data on either side, differing naming conventions, multiple products with the same name, and so on).</p>
<p>To improve the quality of these steps and to enable matching via Microsoft, EOL and other data sources,
a custom data format is used (Correlation Files) to manually map the component metadata to the product identifiers.
More details on the <code>artifact-data</code> schema <a href="https://metaeffekt.com/schema/artifact-analysis">can be found here</a>.</p>

#### Configuration: Artifact Correlation

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>yamlFiles</code></td><td><code>new ArrayList<>()</code></td></tr></table>



## Package URL derivation

`purl-derived` / `purlDerivationEnrichment` / `package-url-derivation`

<details>

<summary>Source Code for <code>PackageUrlDerivationEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final Inventory inventory = subject.getAsInventory(this);

for (final Artifact artifact : inventory.getArtifacts()) {
    super.executor.submit(() -> {
        final Set<PackageURL> packageUrls = this.purlDetection.detectArtifactPurls(artifact);
        artifact.set(InventoryAttribute.DERIVED_PURLS, packageUrls.stream().map(PackageURL::toString).collect(Collectors.joining(", ")));
    });
}

super.executor.start();
try {
    super.executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Interrupted while waiting for Package URL derivation to finish", e);
}
```

</details>


See <a href="https://github.com/org-metaeffekt/metaeffekt-documentation/blob/main/metaeffekt-vulnerability-management/inventory-enrichment/purl/purl-derivation.md">https://github.com/org-metaeffekt/metaeffekt-documentation/blob/main/metaeffekt-vulnerability-management/inventory-enrichment/purl/purl-derivation.md</a> for more details.



---

# Vulnerability Matching

The next phase represents the main part of the inventory enrichment process, responsible for the actual matching process
of finding vulnerabilities from various sources to the products identified in the earlier steps.

It is important to note that _only the vulnerabilities themselves_ are identified during this phase, excluding any
vulnerability metadata such as descriptions or CVSS vectors.
This distinction between finding identifiers and adding details is made to allow for adding those details after any
amount of vulnerability identification steps exactly once,
instead of performing them after each one individually.

Each of the steps below uses a different method to identify vulnerabilities, since each source uses different formats
and methods to identify vulnerabilities.
But all of them have in common that they identify vulnerabilities based on the products present in the inventory.

## NVD CVE from CPE

`nvd-cve-from-cpe` / `nvdMatchCveFromCpeEnrichment` / `vulnerabilities-from-cpe`

<details>

<summary>Source Code for <code>NvdVulnerabilitiesFromCpeEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final AtomicInteger progress = new AtomicInteger(0);

final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
final List<Artifact> artifacts = vInventory.getInventory().getArtifacts();
for (final Artifact artifact : artifacts) {
    super.executor.submit(() -> {
        final int currentElement = progress.incrementAndGet();
        if (currentElement % 100 == 0 && currentElement > 0) {
            log.info("Collecting CVE from CPE for artifact [{} / {}]", currentElement, artifacts.size());
        }

        super.enrichVulnerabilitiesForCpe(vInventory, artifact);
    });
}

super.executor.setSize(16);
super.executor.setLogEveryPercent(10);
super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to join executor while waiting for NVD CVE from CPE enrichment to finish.", e);
}

vInventory.writeBack(super.securityPolicyConfiguration);
```

</details>


<details>

<summary>Source Code for <code>VulnerabilitiesFromCpeEnrichment.enrichVulnerabilitiesForCpe(VulnerabilityContextInventory vInventory, Artifact artifact)</code> </summary>

```java
final Map<Cpe, List<Vulnerability>> vulnerabilitiesForCpes = this.queryVulnerabilitiesForArtifact(vInventory, artifact);

// collect matched cpes
final Set<String> matchedCpes = new HashSet<>();
vulnerabilitiesForCpes.keySet().forEach(cpe -> matchedCpes.add(CommonEnumerationUtil.toCpe22UriOrFallbackToCpe23FS(cpe)));

// add matched cpes as field in the artifact
if (!matchedCpes.isEmpty()) {
    artifact.set(InventoryAttribute.MATCHED_CPES,
            matchedCpes.stream().filter(cpe -> cpe != null && !cpe.equals("null")).collect(Collectors.joining(", ")));
} else {
    artifact.set(InventoryAttribute.MATCHED_CPES, null);
}
```

</details>


<details>

<summary>Source Code for <code>VulnerabilitiesFromCpeEnrichment.queryVulnerabilitiesForArtifact(VulnerabilityContextInventory vInventory, Artifact artifact)</code> </summary>

```java
// represents return value: collects vulnerabilities for artifact
final Map<Cpe, List<Vulnerability>> aggregatedVulnerabilitiesForCpes = new LinkedHashMap<>();

// only used for tracking the amount of vulnerabilities for the config parameter
final Set<String> aggregatedVulnerabilities = new HashSet<>();

// The aggregation of CPEs is often version agnostic. This is why a specification on the artifact version is
// required below.
final List<Cpe> artifactCpes = CommonEnumerationUtil.parseEffectiveCpe(artifact);

// query CVEs for CPE with matching version
for (Cpe cpe : artifactCpes) {

    try {
        final Optional<Cpe> optionalQueryCpe = deriveQueryCpe(vInventory, this.getEnrichmentName(), artifact, cpe);
        if (!optionalQueryCpe.isPresent()) {
            continue;
        }
        final Cpe queryCpe = optionalQueryCpe.get();

        final Map<Vulnerability, VulnerableSoftwareVersionRangeCpe> vulnerabilitiesWithSources = getVulnerabilityQuery().findVulnerabilitiesByFlatAffectedConfigurationRetainSource(queryCpe);
        final List<Vulnerability> vulnerabilitiesForCpes = vulnerabilitiesWithSources.keySet().stream()
                .map(AmbDataClass::getId)
                .map(vInventory::findOrCreateVulnerabilityByName)
                .collect(Collectors.toList());

        if (!vulnerabilitiesForCpes.isEmpty()) {
            for (Vulnerability vulnerability : vulnerabilitiesForCpes) {
                final VulnerableSoftwareVersionRangeCpe affectedConfiguration = vulnerabilitiesWithSources.get(vulnerability);
                final DataSourceIndicator matchingSource = DataSourceIndicator.cpe(artifact, this.getVulnerabilitySource(), queryCpe, affectedConfiguration != null ? affectedConfiguration.toString() : null);
                vulnerability.addMatchingSource(matchingSource);
            }
        }

        aggregatedVulnerabilities.addAll(vulnerabilitiesForCpes.stream().map(Vulnerability::getId).collect(Collectors.toSet()));
        aggregatedVulnerabilitiesForCpes.put(cpe, vulnerabilitiesForCpes);

        if (aggregatedVulnerabilities.size() > configuration.getMaxCorrelatedVulnerabilitiesPerArtifact()) {
            break;
        }
    } catch (Exception e) {
        throw new RuntimeException("Failed to query vulnerabilities for artifact [" + artifact.getId() + "] on CPE [" + CommonEnumerationUtil.toCpe22UriOrFallbackToCpe23FS(cpe) + "]: " + e.getMessage(), e);
    }
}

if (aggregatedVulnerabilities.size() > configuration.getMaxCorrelatedVulnerabilitiesPerArtifact()) {
    LOG.warn("Found [{}] vulnerabilities for artifact [{}] but only the first [{}] will be considered.",
            aggregatedVulnerabilities.size(), artifact.getId(), configuration.getMaxCorrelatedVulnerabilitiesPerArtifact());

    vInventory.getInventoryWarnings().addArtifactWarning(new InventoryWarningEntry<>(artifact,
            "Found " + aggregatedVulnerabilities.size() + " vulnerabilities but only the first "
                    + configuration.getMaxCorrelatedVulnerabilitiesPerArtifact() + " will be considered.",
            this.getEnrichmentName()
    ));

    int count = 0;
    boolean clearAll = false;
    for (Map.Entry<Cpe, List<Vulnerability>> entry : aggregatedVulnerabilitiesForCpes.entrySet()) {
        final List<Vulnerability> vulnerabilities = entry.getValue();
        count += vulnerabilities.size();

        if (count > configuration.getMaxCorrelatedVulnerabilitiesPerArtifact()) {
            if (clearAll) {
                vulnerabilities.clear();
            } else {
                final int removeCount = count - configuration.getMaxCorrelatedVulnerabilitiesPerArtifact();
                vulnerabilities.subList(vulnerabilities.size() - removeCount, vulnerabilities.size()).clear();
                clearAll = true;
            }
        }
    }
}

final VulnerabilityTypeIdentifier<?> vulnerabilityIdentifier = this.getVulnerabilityQuery().getVulnerabilityType();
for (List<Vulnerability> vulnerabilities : aggregatedVulnerabilitiesForCpes.values()) {
    for (Vulnerability vulnerability : vulnerabilities) {
        vulnerability.setSourceIdentifier(vulnerabilityIdentifier);
    }
}

return aggregatedVulnerabilitiesForCpes;
```

</details>


<p>The NVD CVE from CPE enrichment step is responsible for linking vulnerabilities from the National Vulnerability
Database (NVD) to specific products (artifacts) identified in an inventory.
The process works by utilizing Common Platform Enumerations (CPEs) to identify which vulnerabilities (CVE entries)
affect each product based on its known CPEs.</p>

<b>What Happens During This Step</b>
<p>When this step begins, the system processes each product (artifact) in the inventory by first identifying its CPEs.
These CPEs are derived using the product&#39;s attributes and version information.
In case the CPE version does not match the artifact version, an algorithm is used to combine them in a meaningful way
or pick one of the two as the query version.
The CPEs are then used as queries to look up vulnerabilities from the NVD:
For each product, the system performs a query to retrieve a list of vulnerabilities that specifically match the
product&#39;s CPE and version.</p>
Once the query is executed, the system retrieves vulnerabilities and performs a secondary, more detailed version
comparison match against the product/CPE version to ensure only accurate matches are considered.
Along with this, the system also stores the CPEs and other data like version ranges that led to each vulnerability
match as metadata for the product, allowing for traceability in later steps.</p>
<p>Finally, all identified vulnerabilities are stored in the inventory, linked to their respective products.</p>

#### Configuration: Vulnerabilities from CPE

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maxCorrelatedVulnerabilitiesPerArtifact</code></td><td><code>Integer.MAX_VALUE</code></td></tr></table>



## MSRC Vulnerabilities by Products

`msrc-cve-from-product` / `msVulnerabilitiesByProductEnrichment` / `msrc-vulnerabilities-by-product`

<details>

<summary>Source Code for <code>MsrcVulnerabilitiesByProductEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final MsrcAdvisorIndexQuery msrcAdvisorQuery = this.msrcAdvisorQuery.get();
final MsrcKbChainIndexQuery msrcKbChainQuery = this.msrcKbChainQuery.get();

final VulnerabilityContextInventory vInventory = subject.getAsVInventory();

for (final Artifact artifact : vInventory.getInventory().getArtifacts()) {

    // find Microsoft product from artifact
    final String artifactMsProductIdOrName = artifact.get(InventoryAttribute.MS_PRODUCT_ID.getKey());
    if (artifactMsProductIdOrName == null) {
        continue;
    }

    final List<String> productList = Arrays.stream(artifactMsProductIdOrName.split(", ")).map(String::trim).collect(Collectors.toList());

    if (productList.size() >= 2) {
        LOG.warn("Multiple products found for artifact [{}], usually an artifact is only affected by a single product. Products: [{}]", artifact.getId(), artifactMsProductIdOrName);
    }

    for (String msProductIdOrName : productList) {
        final MsrcProduct msrcProduct = findProductFromIdOrName(msProductIdOrName);
        if (msrcProduct == null) {
            LOG.error("Skipping over MS Product ID [{}] from Artifact [{}] as it cannot be found in local index, make sure that the ID is correct", msProductIdOrName, artifact.getId());
            continue;
        }

        // extract KB Ids from artifact
        final Set<String> appliedMsKbIdentifiers = extractKbIdentifiers(artifact);


        // find Microsoft vulnerabilities affected by product
        final List<String> msAdvisoryIdsOnProductFromAdvisors = msrcAdvisorQuery.findByProduct(msrcProduct).stream()
                .map(MsrcAdvisorEntry::getId).collect(Collectors.toList());
        final Map<String, String> msVulnerabilitiesOnProductFromAdvisors = new HashMap<>();
        for (String advisoryId : msAdvisoryIdsOnProductFromAdvisors) {
            msVulnerabilitiesOnProductFromAdvisors.put(advisoryId.replace("MSRC-", ""), advisoryId);
        }

        final List<String> msVulnerabilitiesOnProductFromKbChains = msrcKbChainQuery.findVulnerabilitiesByProductId(msrcProduct.getId());

        final Set<String> allPotentialVulnerabilities = new HashSet<>();
        allPotentialVulnerabilities.addAll(msVulnerabilitiesOnProductFromAdvisors.keySet());
        allPotentialVulnerabilities.addAll(msVulnerabilitiesOnProductFromKbChains);


        msrcKbChainQuery.collectSupersedingKbIdentifiers(allPotentialVulnerabilities, msProductIdOrName, appliedMsKbIdentifiers);

        final Set<String> msVulnerabilitiesNotFixed = new HashSet<>();
        final Set<String> msAdvisoriesNotFixed = new HashSet<>();
        final Set<String> msVulnerabilitiesAndAdvisoriesFixed = new HashSet<>();

        for (String vulnerabilityId : allPotentialVulnerabilities) {
            final boolean isFixed = msrcKbChainQuery.isVulnerabilityFixed(vulnerabilityId, msrcProduct.getId(), appliedMsKbIdentifiers);

            if (isFixed) {
                msVulnerabilitiesAndAdvisoriesFixed.add(vulnerabilityId);
            } else {
                msVulnerabilitiesNotFixed.add(vulnerabilityId);

                final String advisoryId = msVulnerabilitiesOnProductFromAdvisors.get(vulnerabilityId);
                if (advisoryId != null) {
                    msAdvisoriesNotFixed.add(advisoryId);
                }
            }
        }


        // convert to vulnerability instances
        final DataSourceIndicator msrcProductDataSourceIndicator = DataSourceIndicator.msrcProduct(artifact, msrcProduct, appliedMsKbIdentifiers);

        for (String v : msVulnerabilitiesNotFixed) {
            final Vulnerability vulnerability = vInventory.findOrCreateVulnerabilityByName(v)
                    .addMatchingSource(msrcProductDataSourceIndicator);
            if (vulnerability.getSourceIdentifier() == null) {
                vulnerability.setSourceIdentifier(VulnerabilityTypeStore.CVE);
            }
        }

        for (String v : msAdvisoriesNotFixed) {
            vInventory.findOrCreateAdvisoryEntryByName(v, MsrcAdvisorEntry::new)
                    .addMatchingSource(msrcProductDataSourceIndicator);
        }

        for (String v : msVulnerabilitiesAndAdvisoriesFixed) {
            vInventory.findOrCreateWithoutAddingVulnerabilityByName(v)
                    .manuallyAffectsArtifact(InventoryAttribute.VULNERABILITIES_FIXED_BY_KB, artifact);
        }


        artifact.set(InventoryAttribute.MS_SUPERSEDED_KB_IDENTIFIER.getKey(), String.join(", ", appliedMsKbIdentifiers));

        LOG.info("Artifact [{}] with product [{}] ([{}]) and [{}] KB has [{} vulnerabilities] [{} advisories] [{} fixed by KB] from [{} & {} -> {}] vulnerabilities/advisories",
                artifact.getId(), msProductIdOrName, msrcProduct.getId(), appliedMsKbIdentifiers.size(),
                msVulnerabilitiesNotFixed.size(), msAdvisoriesNotFixed.size(), msVulnerabilitiesAndAdvisoriesFixed.size(),
                msVulnerabilitiesOnProductFromAdvisors.size(), msVulnerabilitiesOnProductFromKbChains.size(), allPotentialVulnerabilities.size());

    }
}
```

</details>


<p>The MSRC (Microsoft Security Response Center) Vulnerabilities by Products enrichment step is responsible for identifying vulnerabilities affecting Microsoft products within an inventory.
This process works by linking artifacts (products) to their associated vulnerabilities using Microsoft’s product and advisory databases.
The enrichment step uses various Microsoft data sources, including product IDs, advisories, and Knowledge Base (KB) chains, to ensure that relevant vulnerabilities, based on the product and its applied updates, are considered.</p>
<b>What Happens During This Step</b>
<p>When this step begins, the system first processes each artifact in the inventory to identify those associated with Microsoft products.
It does this by checking for a Microsoft Product ID or name within the artifact&#39;s metadata.
If an artifact contains such information, it is further analyzed to determine the specific Microsoft product it represents.
Once the product is identified, the system extracts any relevant KB identifiers from the artifact.
These KB identifiers represent updates or patches applied to the product and are relevant when determining whether a given vulnerability has already been resolved and should not be added to the inventory.</p>
<p>The system then queries the Microsoft advisory data source to retrieve potential vulnerabilities for the product.
First, it queries Microsoft advisories using the MSRC advisory index to find vulnerabilities linked to the product.
This part is simple, as advisories directly contain the affected products, with them being a unique numerical id.</p>
<p>Now the system can check these for any superseding KB identifiers, making sure that if the product has received newer updates, the patched vulnerabilities are filtered out.
This is done by following the KB chain, which is a list of KBs that are superseded by other KBs.
If any of the superseding KBs are found in the applied KB identifiers, the vulnerability is considered fixed.
Using this, vulnerabilities are classified into three categories:
those that remain applicable, those that are applicable advisories (Microsoft-internal <code>ADV</code>-identifiers), and those that have been fixed by the applied KB updates.</p>
<p>For applicable vulnerabilities, the system links them directly to the product (artifact) and stores them in the inventory.
For fixed vulnerabilities, the system marks them as resolved and notes the KB that addressed them.</p>



## Custom Vulnerabilities from CPE

`custom-vulnerabilities-from-cpe` / `customVulnerabilitiesFromCpeEnrichment` / `vulnerabilities-from-cpe`

<details>

<summary>Source Code for <code>CustomVulnerabilitiesFromCpeEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final Inventory inventory = subject.getAsInventory(this);

vulnerabilityQuery = new CustomVulnerabilityIndexQuery(getConfiguration().getVulnerabilityFiles());

final List<Artifact> artifacts = inventory.getArtifacts();
final VulnerabilityContextInventory vInventory = VulnerabilityContextInventory.fromInventory(inventory);
for (int i = 0, artifactsSize = artifacts.size(); i < artifactsSize; i++) {
    final Artifact artifact = artifacts.get(i);

    int finalI = i;
    super.executor.submit(() -> {
        LOG.info("Collecting vulnerabilities from CPE for artifact [{} / {}] [{}: {} {}]", finalI + 1, inventory.getArtifacts().size(), artifact.getId(), artifact.get(Artifact.Attribute.COMPONENT), artifact.get(Artifact.Attribute.VERSION));

        super.enrichVulnerabilitiesForCpe(vInventory, artifact);
    });
}

super.executor.setSize(16);
super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Interrupted while waiting for custom vulnerability enrichment to finish.", e);
}
```

</details>


#### Configuration: Vulnerabilities from CPE

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maxCorrelatedVulnerabilitiesPerArtifact</code></td><td><code>Integer.MAX_VALUE</code></td></tr></table>



## OSV Vulnerabilities

`osv-vulnerabilities` / `osvVulnerabilitiesEnrichment` / `osv-vulnerabilities`

<details>

<summary>Source Code for <code>OsvVulnerabilitiesEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();

LOG.info("Matching OSV vulnerabilities for [{}] artifacts", vInventory.getInventory().getArtifacts().size());

final List<AdvisoryTypeIdentifier<?>> providers = AdvisorPeriodicEnrichmentConfiguration.parseAdvisoryProviders(configuration.getIncludeAdvisoryProviders());
if (providers != null && !providers.isEmpty()) {
    if (providers.containsAll(AdvisoryTypeStore.get().osvValues())) {
        providers.clear();
    } else {
        LOG.info("Filtering for advisory providers: {}", providers);
    }
}

int addedAsVulnerabilitiesCount = 0;
int addedAsAdvisoryCount = 0;

for (Artifact artifact : vInventory.getInventory().getArtifacts()) {
    for (OsvAdvisorIndexQuery.OsvSearch search : OsvAdvisorIndexQuery.OsvSearch.fromArtifact(artifact)) {
        // apply additional configuration filters
        search.setGithubReviewed(configuration.isGithubReviewed());
        search.setProvider(providers);

        final Map<OsvAdvisorEntry, DataSourceIndicator> osvAdvisorEntries = osvAdvisorQuery.get().findByQuery(search);

        // differentiate entries based on whether they have CVEs or not.
        // we are mainly interested in the entries that have vulnerabilities in this step
        for (Map.Entry<OsvAdvisorEntry, DataSourceIndicator> matchedEntry : osvAdvisorEntries.entrySet()) {
            final OsvAdvisorEntry osvAdvisorEntry = matchedEntry.getKey();
            final DataSourceIndicator dataSourceIndicator = matchedEntry.getValue();

            final String nvdEquivalent = osvAdvisorEntry.getNvdEquivalent();
            final boolean hasNvdEquivalent = configuration.isExcludeNvdEquivalent() && StringUtils.hasText(nvdEquivalent);

            final Set<String> entryCves = osvAdvisorEntry.getReferencedVulnerabilities(VulnerabilityTypeStore.CVE);

            final boolean addAsAdvisory = entryCves.isEmpty() && !hasNvdEquivalent;

            if (addAsAdvisory) {
                addedAsAdvisoryCount++;

                final AdvisoryEntry advisoryEntry = vInventory.add(vInventory.findOrCreateAdvisoryEntryByName(osvAdvisorEntry.getId(), id -> osvAdvisorEntry)
                        .addMatchingSource(dataSourceIndicator));
                OsvVulnerabilitiesEnrichment.putRetainedVersions(osvAdvisorEntry, advisoryEntry);

            } else { // add vulnerabilities referenced by the advisory
                addedAsVulnerabilitiesCount++;

                for (String entryCve : entryCves) {
                    final Vulnerability vulnerability = vInventory
                            .findOrCreateVulnerabilityByName(entryCve)
                            .addMatchingSource(dataSourceIndicator);

                    OsvVulnerabilitiesEnrichment.putRetainedVersions(osvAdvisorEntry, vulnerability);

                    vulnerability.setSourceIdentifier(VulnerabilityTypeStore.CVE);
                    vulnerability.addNvdEquivalentAdvisory(osvAdvisorEntry.getSourceIdentifier(), osvAdvisorEntry.getId());

                    vInventory.add(vulnerability);
                }
            }
        }
    }
}

LOG.info("Processed [{}] matches as vulnerabilities and [{}] as advisories", addedAsVulnerabilitiesCount, addedAsAdvisoryCount);
```

</details>


See <a href="https://github.com/org-metaeffekt/metaeffekt-documentation/blob/main/metaeffekt-vulnerability-management/data-mirror/osv/osv.md">https://github.com/org-metaeffekt/metaeffekt-documentation/blob/main/metaeffekt-vulnerability-management/data-mirror/osv/osv.md</a> for more details.

#### Configuration: OSV Vulnerabilities

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>githubReviewed</code></td><td><code>false</code></td></tr><tr><td><code>includeAdvisoryProviders</code></td><td><code>new JSONArray()            .put(new JSONObject().put("name", "*").put("implementation", "OSV")).toString()</code></td></tr><tr><td><code>excludeNvdEquivalent</code></td><td><code>true</code></td></tr><tr><td colspan=2>Will prevent advisories being added to the inventory that have a corresponding NVD Equivalent. This will not prevent advisories already present on the inventory to have their details filled, only from adding further advisories.</td></tr></table>



## CSAF Vulnerabilities

`csaf-cve` / `csafVulnerabilitiesEnrichment` / `csaf-vulnerabilities`

<details>

<summary>Source Code for <code>CsafVulnerabilitiesEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
if(configuration.getExcludedCsafSources() != null){
    List<String> excludedCsafSources = configuration.getExcludedCsafSources().stream().map(String::trim).collect(Collectors.toList());
    List<String> parsedExcludedCsafSources = new ArrayList<>();
    if(!excludedCsafSources.isEmpty()){
        AdvisoryTypeStore advisoryTypeStore = AdvisoryTypeStore.get();
        log.info("Excluding the following csaf provider:");
        excludedCsafSources.forEach(s -> {
            AdvisoryTypeIdentifier<?> adv = advisoryTypeStore.fromNameAndImplementationWithoutCreation(s, "CSAF");
            if(adv == null) {
                log.info("unknown csaf provider: [{}]", s);
                parsedExcludedCsafSources.add(s);
            } else {
                log.info(adv.getWellFormedName());
                parsedExcludedCsafSources.add(adv.getName());
            }
        });
        CsafVulnerabilityIndexQuery.setExcludedSources(parsedExcludedCsafSources);
    } else {
        log.info("Not excluding any csaf providers");
    }
}

final VulnerabilityContextInventory vInventory = subject.getAsVInventory();

final Map<Vulnerability, List<DataSourceIndicator>> foundVulnerabilities = new HashMap<>();
for (Artifact artifact : vInventory.getInventory().getArtifacts()) {
    final Map<String, DataSourceIndicator> cves = new HashMap<>();

    cves.putAll(indexVulnerabilityQuery.findVulnerabilitiesByPurl(artifact));

    for (Cpe cpe : CommonEnumerationUtil.parseEffectiveCpe(artifact)) {
        cves.putAll(indexVulnerabilityQuery.findVulnerabilitiesByCpe(artifact, cpe));
    }

    for (Map.Entry<String, DataSourceIndicator> entry : cves.entrySet()) {
        if (entry.getKey() == null || entry.getKey().isEmpty()) {
            log.info("Skipping match. No Vulnerability ID: {}", entry);
            continue;
        }

        Vulnerability matchedVuln = vInventory.findOrCreateVulnerabilityByName(entry.getKey());
        matchedVuln.addMatchingSource(entry.getValue());
        matchedVuln.setSourceIdentifier(VulnerabilityTypeStore.CVE);

        foundVulnerabilities.computeIfAbsent(matchedVuln, k -> new ArrayList<>()).add(entry.getValue());
    }
}

//add all advisories which belong to the same document, with which the vulnerability was originally matched.
for (Map.Entry<Vulnerability, List<DataSourceIndicator>> vulnerabilityMatch : foundVulnerabilities.entrySet()) {
    Vulnerability vulnerability = vulnerabilityMatch.getKey();
    List<DataSourceIndicator> matchIndicators = vulnerabilityMatch.getValue();

    List<CsafAdvisoryEntry> matchedAdvisories = this.indexAdvisoryQuery.findByReferencedId(vulnerability.getId());

    for (CsafAdvisoryEntry advisorEntry : matchedAdvisories) {
        DataSourceIndicator dataSourceIndicator = matchIndicators.stream()
                .filter(matchIndicator -> matchIndicator.getMatchReason() instanceof DataSourceIndicator.ArtifactCsafReason && ((DataSourceIndicator.ArtifactCsafReason) matchIndicator.getMatchReason()).belongsToAdvisory(advisorEntry))
                .findFirst().orElse(null);
        if (dataSourceIndicator != null) {

            //creates a reduced advisory from the csafAdvisor and adds only the product-id specific fields, if the product id also exists in the matching reason of the vulnerability, inorder not to write six billion product-ids into the inventory
            CsafAdvisoryEntry reducedAdvisoryEntry = CsafAdvisoryEntry.createReducedAdvisory(advisorEntry);
            CsafAdvisoryEntry advisoryEntry = (CsafAdvisoryEntry) vInventory.findOrAppendAdvisoryEntryByAdvisoryEntry(reducedAdvisoryEntry);
            advisoryEntry.fillAdvisoryProductSpecific(advisorEntry, vulnerability, (DataSourceIndicator.ArtifactCsafReason) dataSourceIndicator.getMatchReason());
            vInventory.references(vulnerability, advisoryEntry);
        }
    }
}
```

</details>


#### Configuration: CSAF Vulnerabilities

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>excludedCsafSources</code></td><td><code>new ArrayList<>()</code></td></tr></table>



---

# Vulnerability Details Filling

As mentioned in the [Vulnerability Matching](#vulnerability-matching) section, only the vulnerabilities themselves are
identified during the matching process.
This phase is responsible for adding the details to the vulnerabilities identified in the previous phase.
This includes details like descriptions, CVSS vectors, references, and more.

The steps in this phase might have to be run multiple times in your pipeline, depending on whether you use the
assessments steps or similar steps that require the details to be present, but may add new vulnerabilities to the
inventory that then again require details to be filled.

## NVD Vulnerability Details

`details-vulnerability-nvd` / `nvdCveFillDetailsEnrichment` / `details-filling-nvd`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>




## MSRC Vulnerability Details

`details-vulnerability-msrc` / `msrcAdvisorFillDetailsEnrichment` / `details-filling-msrc`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>


#### Configuration: Details filling MSRC

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>excludeNvdEquivalent</code></td><td><code>true</code></td></tr><tr><td colspan=2>Will prevent advisories being added to the inventory that have a corresponding NVD Equivalent. This will not prevent advisories already present on the inventory to have their details filled, only from adding further advisories.</td></tr></table>



## Custom Vulnerability Details

`details-vulnerability-custom` / `customVulnerabilitiesFillDetailsEnrichment` / `custom-vulnerabilities-details-filling`

<details>

<summary>Source Code for <code>DetailsFillingEnrichmentCustom.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
vulnerabilityQuery = new CustomVulnerabilityIndexQuery(getConfiguration().getVulnerabilityFiles());
super.performEnrichment(subject);
```

</details>


#### Configuration: Custom Vulnerabilities Details filling

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>vulnerabilityFiles</code></td><td><code>new ArrayList<>()</code></td></tr></table>



## CAPEC Details

`details-vulnerability-capec` / `capecFillDetailsEnrichment` / `details-filling-capec`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>




## CWE Details

`details-vulnerability-cwe` / `cweFillDetailsEnrichment` / `details-filling-cwe`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>




---

# Assessments

To allow teams of assessors to evaluate the identified vulnerabilities and security advisories,
this phase allows for injecting assessments for vulnerabilities and security advisories into the inventory.
For this, the [Assessment File format](https://metaeffekt.com/schema/artifact-analysis) is used, see the link for
more details on how to create such files.
These assessments will show up in the generated reports and dashboards.

Since this step both requires vulnerability details to be present and may add new vulnerabilities to the inventory
(void vulnerabilities), the [Vulnerability Details Filling](#vulnerability-details-filling) phase has to be run before
and after this phase.

## Vulnerability Status

`status` / `vulnerabilityStatusEnrichment` / `vulnerability-status`

<details>

<summary>Source Code for <code>VulnerabilityStatusEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
try {
    LOG.info("");
    if (!configuration.getStatusFiles().isEmpty()) {
        LOG.info("Adding data from status files from:");
        configuration.getStatusFiles().stream().map(File::getAbsolutePath).map(f -> " - " + f).forEach(LOG::info);
    }
    if (!configuration.getAdditionalStatus().isEmpty()) {
        LOG.info("Adding data from [{}] additional assessment entries added programmatically", configuration.getAdditionalStatus().size());
    }

    final List<VulnerabilityAssessment> anyScopeAssessments = configuration.getAssessments();

    // log the status files found with metadata
    if (anyScopeAssessments.isEmpty()) {
        LOG.info("No assessment files found in provided directories");
    } else {
        LOG.info("Found [{}] assessment file{}",
                anyScopeAssessments.size(), anyScopeAssessments.size() == 1 ? "" : "s");
    }
    LOG.info("");

    final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
    final int vulnerabilityCountBefore = vInventory.getVulnerabilities().size();


    // filter out all INVENTORY and ARTIFACT scope entries
    final List<VulnerabilityAssessment> inventoryScopeStatus = anyScopeAssessments.stream()
            .filter(s -> s.isScope(VulnerabilityAssessment.Scope.INVENTORY))
            .collect(Collectors.toList());
    final List<VulnerabilityAssessment> vulnerabilityScopeStatus = anyScopeAssessments.stream()
            .filter(s -> s.isScope(VulnerabilityAssessment.Scope.VULNERABILITY))
            .collect(Collectors.toList());


    // do not yet add the vulnerabilities from the status files to the inventory, as INVENTORY scope statuses should not be applied on these
    if (!inventoryScopeStatus.isEmpty()) {
        LOG.info("Found [{}] status file{} with scope [{}]", inventoryScopeStatus.size(), inventoryScopeStatus.size() == 1 ? "" : "s", VulnerabilityAssessment.Scope.INVENTORY);

        for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
            addAssessmentEventsForVulnerability(vInventory, inventoryScopeStatus, vulnerability, false);
        }

        // add information about the inventory scope status files to the inventory info
        final InventoryInfo info = vInventory.getInventory().findOrCreateInventoryInfo(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_KEY);

        final JSONArray statusJson = inventoryScopeStatus.stream()
                .map(VulnerabilityAssessment::toJsonObject)
                .collect(CustomCollectors.toJsonArray());

        if (info.has(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY)) {
            final JSONArray existingStatusJson = new JSONArray(info.get(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY));
            for (int i = 0; i < existingStatusJson.length(); i++) {
                statusJson.put(existingStatusJson.get(i));
            }
        }

        info.set(InventoryEnricher.INVENTORY_INFO_VULNERABILITY_STATUS_INVENTORY_STATUSES_KEY, statusJson.toString());
    }


    // all vulnerabilities from the statuses that are non-existent in the inventory will be added as 'void' status entries later
    final Map<Vulnerability, File> createdVulnerabilitySources = new HashMap<>();
    for (VulnerabilityAssessment assessment : anyScopeAssessments) {
        if (assessment.getAffects() == null) continue;
        if (assessment.isIgnoreWhenVoid()) continue;

        for (String name : assessment.getAffects().listAffectedVulnerabilitiesWithoutWildcards()) {
            if (!vInventory.findVulnerabilityByName(name).isPresent()) {
                final Vulnerability vulnerability = vInventory.findOrCreateVulnerabilityByName(name);
                VulnerabilityTypeStore.get().inferSourceIdentifierFromIdIfAbsent(vulnerability);
                createdVulnerabilitySources.put(vulnerability, assessment.getSourceFile());
            }
        }
    }

    // add a matching source to all vulnerabilities that have been created by status files
    for (Map.Entry<Vulnerability, File> vulnerabilityFileEntry : createdVulnerabilitySources.entrySet()) {
        final Vulnerability vulnerability = vulnerabilityFileEntry.getKey();
        final File file = vulnerabilityFileEntry.getValue();

        vulnerability.addMatchingSource(DataSourceIndicator.assessmentStatus(file));
    }

    final int vulnerabilityCountAfter = vInventory.getVulnerabilities().size();

    LOG.info("Found [{}] status files with a total of [{}] affected vulnerabilities, applying to an inventory with [{}] vulnerabilities (merged & deduplicated total: [{}])",
            anyScopeAssessments.size(), vulnerabilityCountAfter - vulnerabilityCountBefore, vulnerabilityCountBefore, vulnerabilityCountAfter);


    // iterate over remaining vulnerabilities and apply the ARTIFACT status entries
    for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
        addAssessmentEventsForVulnerability(vInventory, vulnerabilityScopeStatus, vulnerability, createdVulnerabilitySources.containsKey(vulnerability));
    }
} catch (IOException e) {
    throw new IllegalStateException("Error while reading status files: " + e.getMessage(), e);
}
```

</details>


#### Configuration: Vulnerability Status

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>statusFiles</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>additionalStatus</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>activeLabels</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>failOnValidationErrors</code></td><td><code>false</code></td></tr><tr><td><code>failOnAmbiguousMatchingInformation</code></td><td><code>false</code></td></tr></table>



## Vulnerability Keywords

`vulnerability-keywords` / `vulnerabilityKeywordsEnrichment` / `vulnerability-keywords`

<details>

<summary>Source Code for <code>VulnerabilityKeywordsEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
LOG.info("Performing enrichment using [{}] yaml file{}", configuration.getYamlFiles().size(), configuration.getYamlFiles().size() == 1 ? "" : "s");

final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
final VulnerabilityKeywords keywords = configuration.makeKeywords(super.getSecurityPolicyConfiguration().getJsonSchemaValidationErrorsHandling());

for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    final List<KeywordSet> matchingKeywords = keywords.getMatching(
            vulnerability.getDescription(),
            String.join(", ", vulnerability.getCweIds())
    );

    if (!matchingKeywords.isEmpty()) {
        LOG.debug("[{}] matches [{}] keyword(s): {}", vulnerability.getId(), matchingKeywords.size(), matchingKeywords.stream().map(KeywordSet::getNameScore).collect(Collectors.joining(", ")));

        final boolean anyKeywordSetHasScore = matchingKeywords.stream().anyMatch(KeywordSet::hasScore);
        final Double totalKeywordsScore = anyKeywordSetHasScore
                ? matchingKeywords.stream().filter(KeywordSet::hasScore).mapToDouble(KeywordSet::getScore).sum()
                : null;
        vulnerability.setAdditionalAttribute(InventoryAttribute.KEYWORDS_SCORE, totalKeywordsScore != null ? String.valueOf(VulnerabilityAssessmentDashboard.roundOneDecimal(totalKeywordsScore)) : null);

        final JSONArray keywordsArray = KeywordSet.toFullInformationJson(matchingKeywords);
        vulnerability.setAdditionalAttribute(InventoryAttribute.KEYWORDS, keywordsArray.toString());

        vulnerability.getAssessmentEvents().addAll(collectAllAssessmentEvents(matchingKeywords));
    }
}
```

</details>


#### Configuration: Vulnerability Keywords

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>yamlFiles</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>activeLabels</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>addonVulnerabilityKeywords</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>failOnValidationErrors</code></td><td><code>false</code></td></tr></table>



---

# Security Advisory Matching

Once all vulnerabilities are known and have their details filled, the next phase is to match security advisories to the
vulnerabilities to support the assessment and remediation process.
For this, (as usual) each step uses a different method to identify relevant security advisories based on the
vulnerabilities and products present in the inventory.

## CERT-FR Advisor Details

`details-advisor-cert-fr` / `certFrAdvisorEnrichment` / `details-filling-advisor-cert-fr`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>




## CERT-SEI Advisor Details

`details-advisor-cert-sei` / `certSeiAdvisorEnrichment` / `details-filling-advisor-cert-sei`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>




## CERT-EU Advisor Details

`details-advisor-cert-eu` / `certEuAdvisorEnrichment` / `details-filling-advisor-cert-eu`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>




## CSAF Advisor Details

`details-advisor-csaf` / `csafAdvisorEnrichment` / `details-filling-advisor-csaf`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>




## OSV Vulnerability Details

`details-vulnerability-OSV` / `osvAdvisorFillDetailsEnrichment` / `details-filling-osv`

<details>

<summary>Source Code for <code>DetailsFillingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
preEnrichmentTasks(vInventory);

final AtomicInteger appliedVulnerabilities = new AtomicInteger(0);
final AtomicInteger appliedAdvisories = new AtomicInteger(0);

super.executor.setSize(16);

for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (isApplicable(vulnerability)) {
        appliedVulnerabilities.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnVulnerability(vInventory, vulnerability));
    }
}

LOG.info("Starting vulnerability details filling on [{} / {}] vulnerabilities", appliedVulnerabilities.get(), vInventory.getVulnerabilities().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}

for (AdvisoryEntry advisory : vInventory.getShallowCopySecurityAdvisories()) {
    if (isApplicable(advisory)) {
        appliedAdvisories.incrementAndGet();
        super.executor.submit(() -> fillDetailsOnAdvisory(vInventory, advisory));
    }
}

LOG.info("Starting advisory details filling on [{} / {}] advisories", appliedAdvisories.get(), vInventory.getSecurityAdvisories().size());

super.executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for vulnerability details filling.", e);
}
```

</details>


#### Configuration: Details filling OSV

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>includeAdvisoryProviders</code></td><td><code>new JSONArray()            .put(new JSONObject().put("name", "*").put("implementation", "OSV")).toString()</code></td></tr><tr><td><code>lastCachedIncludeAdvisoryProviders</code></td><td><code>-1</code></td></tr><tr><td><code>cachedIncludeAdvisoryProviders</code></td><td><code>null</code></td></tr><tr><td><code>excludeNvdEquivalent</code></td><td><code>true</code></td></tr><tr><td colspan=2>Will prevent advisories being added to the inventory that have a corresponding NVD Equivalent. This will not prevent advisories already present on the inventory to have their details filled, only from adding further advisories.</td></tr></table>



---

# Vulnerability Prioritization

The final phase that adds new data to the inventory is the vulnerability prioritization information.
It adds information that allows for the prioritization of vulnerabilities based on their current exploit state,
severity, and other factors by calculating a combined priority score for each vulnerability.
This score is displayed in the generated reports and dashboards.

## EOL Date

`eol-date` / `eolEnrichment` / `eol`

<details>

<summary>Source Code for <code>EolEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final Inventory inventory = subject.getAsInventory(this);

int count = 0;
final Map<String, Set<EolCycle>> matchedEolCyclesTracker = new HashMap<>();

for (Artifact artifact : inventory.getArtifacts()) {
    final Map<String, Set<EolCycle>> result = performEnrichmentOnSingleArtifact(artifact);
    if (result == null) continue;
    matchedEolCyclesTracker.putAll(result);
    count++;
}

LOG.info("Added EOL Information to [{}] artifacts for products: {}",
        count,
        matchedEolCyclesTracker.entrySet().stream().map(e -> e.getKey() + " (" + e.getValue().stream().map(EolCycle::getCycle).collect(Collectors.joining(", ")) + ")").collect(Collectors.joining(", ")));
```

</details>


<details>

<summary>Source Code for <code>EolEnrichment.performEnrichmentOnSingleArtifact(Artifact artifact)</code> </summary>

```java
if (!artifact.has(InventoryAttribute.EOL_ID.getKey())) {
    return null;
}

final String[] eolIds = artifact.get(InventoryAttribute.EOL_ID.getKey()).split(", ");
final Map<String, Set<EolCycle>> matchedEolCyclesTracker = new HashMap<>();

for (String eolId : eolIds) {
    final EolLifecycle lifecycle = this.eolIndexQuery.findCyclesByProduct(eolId);

    if (lifecycle == null || lifecycle.getCycles().isEmpty()) {
        LOG.warn("No EOL information found for product: {}", eolId);
        continue;
    }

    final String cycleQueryVersion = ObjectUtils.firstNonNull(
            artifact.get(InventoryAttribute.EOL_OVERWRITE_CYCLE_QUERY_VERSION),
            artifact.get(Artifact.Attribute.VERSION)
    );
    final String latestVersionQueryVersion = ObjectUtils.firstNonNull(
            artifact.get(InventoryAttribute.EOL_OVERWRITE_LATEST_VERSION_QUERY_VERSION),
            artifact.get(Artifact.Attribute.VERSION)
    );

    final EolCycle currentCycle = lifecycle.findCycleFromVersion(cycleQueryVersion);

    if (currentCycle == null) {
        if (cycleQueryVersion == null) {
            LOG.warn("Lifecycle found for product [{}], artifact query version [{}] [{}] is null on artifact [{}]", eolId, cycleQueryVersion, latestVersionQueryVersion, artifact.get(Artifact.Attribute.ID));
        } else {
            LOG.warn("Lifecycle found for product [{}], artifact query version [{}] [{}] on artifact [{}] cannot be found in cycle data", eolId, cycleQueryVersion, latestVersionQueryVersion, artifact.get(Artifact.Attribute.ID));
        }
        continue;
    }

    this.performEnrichmentOnArtifactAndCycle(lifecycle, artifact, currentCycle, latestVersionQueryVersion);
    matchedEolCyclesTracker.computeIfAbsent(eolId, k -> new HashSet<>()).add(currentCycle);
}

return matchedEolCyclesTracker;
```

</details>


<h3 id="interpreting-the-data">Interpreting the data</h3>
<p>The 6 values we actually use from the data source can either be a Boolean or a date:</p>
<ul>
<li>EOL (End of Life): Generally, whether something has reached the end-of-life state, i.e., both support and extended
support have expired.</li>
<li>Support: Whether the basic support is still valid.</li>
<li>Extended Support: Something like security support or similar, is usually either not set or equals the EOL date.</li>
<li>LTS (Long Term Support): If Boolean, whether the cycle is LTS; if Date, when the cycle becomes LTS.</li>
<li>Discontinued: Whether the cycle is explicitly marked as discontinued, is often not set.</li>
<li>Technical Guidance: When the technical guidance support ends, is often not set.</li>
</ul>
<p>If the value ist a date, it always indicates when this state will be reached. Except for LTS, reaching this date is
always something negative.</p>
<p>We can differentiate the lifecycle state of a product based on whether extended support is available or not. Here are
the two scenarios:</p>
<h4 id="scenario-1-extended-support-is-available">Scenario 1: Extended Support is Available</h4>
<ol>
<li>Green: EOL has not been reached, both support and extended support are still valid.</li>
<li>Light Green: Support ends in less than X months (configurable, default is 6 months).</li>
<li>Yellow: Support is no longer valid, but extended support is still in effect.</li>
<li>Orange: Extended support ends in less than X months (configurable, default is 6 months).</li>
<li>Red: EOL has been reached, extended support is no longer valid.</li>
</ol>
<h4 id="scenario-2-extended-support-is-not-available">Scenario 2: Extended Support is Not Available</h4>
<p>In this case, phases 3 and 4 are skipped and the cycle immediately reaches the end of life.</p>
<ol>
<li>Green: EOL has not been reached, support is still valid.</li>
<li>Orange: Support ends in less than X months (configurable, default is 6 months).</li>
<li>Red: EOL has been reached, support is no longer valid.</li>
</ol>

#### Configuration: EOL

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>warningThresholdDaysSupport</code></td><td><code>180</code></td></tr><tr><td><code>warningThresholdDaysExtendedSupport</code></td><td><code>180</code></td></tr></table>



## EPSS Enrichment

`epss` / `epssEnrichment` / `epss`

<details>

<summary>Source Code for <code>EpssEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();

log.info("Enriching inventory with EPSS data for [{}] vulnerabilities.", vInventory.getVulnerabilities().size());
final AtomicInteger amountEpss = new AtomicInteger(0);
for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    final Optional<EpssData> epssData = epssIndexQuery.getEpssData(vulnerability);
    if (!epssData.isPresent()) {
        log.info("No EPSS data found for vulnerability: {}", vulnerability.getId());
        continue;
    }
    vulnerability.setEpssData(epssData.get());
    amountEpss.incrementAndGet();
}
log.info("[{}] vulnerabilities enriched with EPSS data.", amountEpss.get());
```

</details>




## KEV Enrichment

`kev` / `kevEnrichment` / `kev`

<details>

<summary>Source Code for <code>KevEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
final KevIndexQuery kevIndexQuery = kevIndexQueryLazySupplier.get();

final Set<String> foundKevFromVulnerabilities = new LinkedHashSet<>();
for (final Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    kevIndexQuery.findKevDataForVulnerability(vulnerability.getId())
            .ifPresent(kevData -> {
                vulnerability.setKevData(kevData);
                foundKevFromVulnerabilities.add(vulnerability.getId());
            });
}

log.info("Found KEV information for [{}] vulnerabilities", foundKevFromVulnerabilities.size());
log.debug("Found KEV information for the following vulnerabilities: {}", foundKevFromVulnerabilities);
```

</details>




---

# Post Processing

A simple step that runs several check-ups and post-processing steps on the inventory to ensure that the inventory is
consistent and ready for the reporting phase.

## Vulnerability Status Post Processing

`status-post-processed` / `vulnerabilityStatusPostProcessingEnrichment` / `vulnerability-status-post-processing`

<details>

<summary>Source Code for <code>VulnerabilityStatusPostProcessingEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();

final VulnerabilityStatusPostProcessor processor = new VulnerabilityStatusPostProcessor();
processor.setMsrcProductIndexQuery(this.msrcProductIndexQuery);

for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    for (VulnerabilityAssessmentEvent event : vulnerability.getAssessmentEvents()) {
        processor.resolveVariablesHandler(vInventory, vulnerability, event.getMeasures(), event::setMeasures);
        processor.resolveVariablesHandler(vInventory, vulnerability, event.getRisk(), event::setRisk);
        processor.resolveVariablesHandler(vInventory, vulnerability, event.getRationale(), event::setRationale);
        processor.resolveVariablesHandler(vInventory, vulnerability, event.getAuthor(), event::setAuthor);

        for (VulnerabilityAssessmentEvent.CvssModificationsContainer container : event.getCvss()) {
            processor.resolveVariablesHandler(vInventory, vulnerability, container.getRationale(), container::setRationale);
        }
    }
}
```

</details>




## Vulnerability Filtering

`vulnerability-filter` / `vulnerabilityFilterEnrichment` / `vulnerability-filter`

<details>

<summary>Source Code for <code>VulnerabilityFilterEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final FilterAttribute filter = configuration.getVulnerabilityIncludeFilterAttribute();
if (filter == null) {
    LOG.warn("No vulnerability filter configured, skipping enrichment [{}]", getEnrichmentName());
    return;
}
LOG.info("");
LOG.info("Filtering vulnerabilities using {}", configuration.getVulnerabilityIncludeFilter());
LOG.info("Parsed vulnerability filter: {}", filter);

final VulnerabilityContextInventory vInventory = subject.getAsVInventory();
vInventory.calculateEffectiveCvssVectorsForVulnerabilities(super.getSecurityPolicyConfiguration());

final int sizeBefore = vInventory.getVulnerabilities().size();
for (Vulnerability vulnerability : vInventory.getShallowCopyVulnerabilities()) {
    if (!filter.matches(vulnerability)) {
        vInventory.remove(vulnerability);
    }
}

LOG.info("Filtered vulnerabilities [{} --> {}]", sizeBefore, vInventory.getVulnerabilities().size());
```

</details>


#### Configuration: Vulnerability Filter

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>vulnerabilityIncludeFilter</code></td><td><code>null</code></td></tr><tr><td><code>vulnerabilityIncludeFilterAttribute</code></td><td><code>null</code></td></tr></table>



## Inventory Validation

`inventory-validation` / `inventoryValidationEnrichment` / `validation`

<details>

<summary>Source Code for <code>InventoryValidationEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final Inventory inventory = subject.getAsInventory(this);

final List<InventoryValidator> validators = configuration.buildValidators();

final Map<InventoryValidator, List<InventoryValidationReason>> validationErrorReasons = new LinkedHashMap<>();

for (InventoryValidator validator : validators) {
    validator.beforeValidation(baseMirrorDirectory);

    LOG.info("Validating inventory with validator: [{}]", validator.getValidatorName());

    try {
        final List<InventoryValidationReason> reasons = validator.validate(inventory);

        for (InventoryValidationReason reason : reasons) {
            validationErrorReasons.computeIfAbsent(validator, k -> new ArrayList<>()).add(reason);
        }
    } catch (Exception e) {
        throw new IllegalStateException("Performing the validation failed for validator " + validator.getValidatorName() + ": " + e.getMessage(), e);
    }

    if (validationErrorReasons.getOrDefault(validator, Collections.emptyList()).isEmpty()) {
        LOG.info("No validation failures found");
    } else {
        LOG.warn("Found [{}] validation failures", validationErrorReasons.values().stream().mapToInt(List::size).sum());
    }
}

cachedValidationFailReasons.computeIfAbsent(inventory, k -> new ArrayList<>())
        .addAll(validationErrorReasons.values().stream().flatMap(Collection::stream).collect(Collectors.toList()));


if (!validationErrorReasons.isEmpty()) {
    final int count = validationErrorReasons.values().stream().mapToInt(List::size).sum();
    final String longDescriptions = buildValidationLongDescriptions(Collections.singletonList(validationErrorReasons));

    final String logMessage = "Inventory Validation failures in " + count + " instance" + (count == 1 ? "" : "s") + ":\n" +
            buildValidationFailReasonsReport(validationErrorReasons) +
            "\n" + longDescriptions + "\n";

    if (configuration.isFailOnValidationErrors()) {
        throw new IllegalStateException(logMessage);
    } else {
        if (configuration.isAddAsCorrelationWarnings()) {
            addInventoryWarningsToInventory(inventory, cachedValidationFailReasons.get(inventory));
        }
        LOG.error(logMessage);
    }
} else {
    LOG.info("Inventory Validation successful.");
}
```

</details>


#### Configuration: Inventory Validation

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>LOG</code></td><td><code>LoggerFactory.getLogger(InventoryValidationEnrichmentConfiguration.class)</code></td></tr><tr><td><code>failOnValidationErrors</code></td><td><code>false</code></td></tr><tr><td><code>addAsCorrelationWarnings</code></td><td><code>true</code></td></tr><tr><td><code>additionalCpeIsNotEffectiveInventoryValidator</code></td><td><code>          </code></td></tr><tr><td><code>multipleArtifactsAndVersionsOnVulnerabilityInventoryValidator</code></td><td><code>          </code></td></tr><tr><td><code>artifactAndCpeVersionsDifferGreatlyInventoryValidator</code></td><td><code>          </code></td></tr><tr><td><code>vulnerabilityInvalidNameValidator</code></td><td><code>          </code></td></tr><tr><td><code>additionalValidators</code></td><td><code>new ArrayList<>()</code></td></tr></table>



## Inventory Post Processing

`inventory-post-process` / `inventoryPostProcessingEnrichment` / `details-filling-osv`

<details>

<summary>Source Code for <code>InventoryPostProcessingEnrichment.performEnrichment(EnrichmentSubject inventory)</code> </summary>

```java
final VulnerabilityContextInventory vInventory = inventory.getAsVInventory();
for (AdvisoryEntry securityAdvisory : vInventory.getSecurityAdvisories()) {
    this.postProcessAdvisory(vInventory, securityAdvisory);
}
for (Vulnerability vulnerability : vInventory.getVulnerabilities()) {
    this.postProcessVulnerability(vInventory, vulnerability);
}
```

</details>


#### Configuration: Details filling OSV

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>includeAdvisoryProviders</code></td><td><code>new JSONArray()            .put(new JSONObject().put("name", "*").put("implementation", "OSV")).toString()</code></td></tr><tr><td><code>lastCachedIncludeAdvisoryProviders</code></td><td><code>-1</code></td></tr><tr><td><code>cachedIncludeAdvisoryProviders</code></td><td><code>null</code></td></tr><tr><td><code>excludeNvdEquivalent</code></td><td><code>true</code></td></tr><tr><td colspan=2>Will prevent advisories being added to the inventory that have a corresponding NVD Equivalent. This will not prevent advisories already present on the inventory to have their details filled, only from adding further advisories.</td></tr></table>



---

# Reporting

The final phase of the inventory enrichment pipeline is the reporting phase, which generates the Vulnerability
Assessment Dashboard.
This dashboard is a web-based HTML report that provides an overview of the vulnerabilities and security advisories
identified in an inventory.

An example of the dashboard for
[OpenSSL 3.0.6 can be found here](https://metaeffekt.com/security/dashboards/openssl-3.0.6-dashboard.html?sort=7&sortDir=false).

## Vulnerability Assessment Dashboard

`vulnerability-assessment-dashboard` / `vulnerabilityAssessmentDashboardEnrichment` / `vulnerability-assessment-dashboard`

<details>

<summary>Source Code for <code>VulnerabilityAssessmentDashboard.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
LOG.debug("Parsing inventory data");
final VulnerabilityContextInventory vInventory = subject.getAsVInventory();

LOG.debug("Baking effective CVSS vectors");
vInventory.calculateEffectiveCvssVectorsForVulnerabilities(super.getSecurityPolicyConfiguration());

LOG.debug("Using calculated values for potential vulnerability filtering");
final List<Vulnerability> effectiveVulnerabilities = VulnerabilityAssessmentDashboard.getEffectiveVulnerabilitiesAll(vInventory, configuration, super.getSecurityPolicyConfiguration());

LOG.info("Initializing dashboard");
final Dashboard dashboard = this.initializeDashboard(vInventory);

LOG.info("Starting dashboard generation");
final Map<Artifact, List<Vulnerability>> vulnerabilitiesPerArtifact = Vulnerability.groupVulnerabilitiesByArtifact(effectiveVulnerabilities);
final Map<Vulnerability, VadDetailLevelConfiguration> vulnerabilityDetails = this.determineVulnerabilityDetailLevels(effectiveVulnerabilities);

this.setFaviconDependingOnVulnerabilityPresence(dashboard, !effectiveVulnerabilities.isEmpty());

final VulnerabilityTimelineGeneratorResult vulnerabilityTimelines = generateApplicableVulnerabilityTimelines(effectiveVulnerabilities, vulnerabilityDetails);

LOG.info("Processing vulnerabilities...");

final Modal inventoryWarningsModal = createInventoryWarningsModal(vInventory.getInventory(), vulnerabilityDetails.keySet());
dashboard.addModal(inventoryWarningsModal);

LOG.info("");
for (Vulnerability vulnerability : effectiveVulnerabilities) {
    final VadDetailLevelConfiguration detailLevel = vulnerabilityDetails.get(vulnerability);

    super.executor.submit(() -> {
        LOG.debug("Processing vulnerability: [{}]", vulnerability.getId());
        try {
            dashboard.addSheet(createVulnerabilitySheet(vulnerability, effectiveVulnerabilities, vulnerabilityTimelines, detailLevel));
        } catch (Exception e) {
            LOG.error("Failed to create vulnerability sheet for vulnerability: {}", vulnerability.getId(), e);
            throw new RuntimeException("Failed to create vulnerability sheet for vulnerability: " + vulnerability.getId(), e);
        }
    });
}

executor.setSize(1);
executor.start();
try {
    executor.join();
} catch (InterruptedException e) {
    throw new RuntimeException("Failed to wait for all vulnerability sheets to be created", e);
}

dashboard.sortSheets(Comparator.comparing(sheet -> {
    final String id = sheet.getId();
    if (id.equalsIgnoreCase("inventory warnings")) {
        return "!!!inventory warnings";
    } else {
        return id;
    }
}));


LOG.info("Generating overview charts");
final VulnerabilityOverviewChartGenerator overviewChartGenerator = new VulnerabilityOverviewChartGenerator(vInventory, super.getSecurityPolicyConfiguration(), effectiveVulnerabilities, vulnerabilitiesPerArtifact);
final List<GeneratedChart> overviewCharts = overviewChartGenerator.generateOverviewCharts();

for (GeneratedChart overviewChart : overviewCharts) {
    overviewChart.writeSvgTo(configuration.getSvgDirectory());
}

dashboard.addModal(generateOverviewModal(overviewCharts));
dashboard.addModal(generateAssessmentEditorModal());

dashboard.addBottomLeftBadge(vInventory.getInventory().getArtifacts().size() + " artifact" + plural(vInventory.getInventory().getArtifacts().size()));
dashboard.addBottomLeftBadge(effectiveVulnerabilities.size() + " vulnerabilitie" + plural(effectiveVulnerabilities.size()));

final List<VulnerabilityPriorityCalculator.PriorityScoreResult> priorityScores = effectiveVulnerabilities.stream().map(vulnerability -> vulnerability.calculatePriorityScore(securityPolicyConfiguration)).collect(Collectors.toList());
final List<CvssSeverityRanges.SeverityRange> priorityScoreRanges = priorityScores.stream().map(VulnerabilityPriorityCalculator.PriorityScoreResult::getResultingSeverityRange).collect(Collectors.toList());
final CvssSeverityRanges.SeverityRange[] priorityScoreSeverityRanges = securityPolicyConfiguration.getPriorityScoreSeverityRanges().getRanges();
for (int i = 0; i < priorityScoreSeverityRanges.length - 1; i++) {
    final CvssSeverityRanges.SeverityRange severityRange = priorityScoreSeverityRanges[i];
    dashboard.addBottomLeftBadge(span(priorityScoreRanges.stream().filter(range -> range == severityRange).count() + " " + severityRange.getName()), i == 0 ? "danger" : "warning");
}

dashboard.addBottomLeftBadge(vInventory.getSecurityAdvisories().size() + " advisorie" + plural(vInventory.getSecurityAdvisories().size()));
{
    final int ignoredVulnerabilitiesCount = vInventory.getVulnerabilities().size() - effectiveVulnerabilities.size();
    if (ignoredVulnerabilitiesCount > 0) {
        dashboard.addBottomLeftBadge(ignoredVulnerabilitiesCount + " ignored");
    }
}
addAdditionalInventoryInformation(vInventory.getInventory(), dashboard);

// FIXME: implement missing behavior
// checkForFailReasons(statistics);

try {
    dashboard.generateIntoFile(configuration.getOutputDashboardFile());
    LOG.info("Wrote dashboard to file: {}", configuration.getOutputDashboardFile().getAbsolutePath());
} catch (IOException e) {
    throw new RuntimeException("Failed to write dashboard to file: " + configuration.getOutputDashboardFile(), e);
}
```

</details>


This class uses an inventory to generate a 'Vulnerability Assessment Dashboard' as single-page HTML file.

#### Configuration: Vulnerability Assessment Dashboard

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>LOG</code></td><td><code>LoggerFactory.getLogger(VulnerabilityAssessmentDashboardEnrichmentConfiguration.class)</code></td></tr><tr><td><code>maximumVulnerabilitiesPerDashboardCount</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>vulnerabilityIncludeFilter</code></td><td><code>null</code></td></tr><tr><td><code>vulnerabilityIncludeFilterAttribute</code></td><td><code>null</code></td></tr><tr><td><code>maximumCpeForTimelinesPerVulnerability</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>maximumVulnerabilitiesPerTimeline</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>maximumVersionsPerTimeline</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>maximumTimeSpentOnTimelines</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>maximumTimeSpentPerTimeline</code></td><td><code>Integer.MAX_VALUE</code></td></tr><tr><td><code>vulnerabilityTimelinesGlobalEnabled</code></td><td><code>true</code></td></tr><tr><td><code>vulnerabilityTimelineHideIrrelevantVersions</code></td><td><code>true</code></td></tr><tr><td><code>failOnVulnerabilityWithoutSpecifiedRisk</code></td><td><code>true</code></td></tr><tr><td><code>failOnUnreviewedAdvisories</code></td><td><code>true</code></td></tr><tr><td><code>svgDirectory</code></td><td><code>          </code></td></tr><tr><td><code>vulnerabilitySvgChartInterpolationMethod</code></td><td><code>VulnerabilityCvssSvgChartInterpolationMethod.BASE_METRICS</code></td></tr><tr><td><code>detailLevels</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>failOnUnreviewedAdvisoriesTypes</code></td><td><code>new JSONArray().toString()</code></td></tr><tr><td colspan=2>Represents a <code>List</code>&lt;<code>Map</code>&lt;<code>String</code>, <code>String</code>&gt;&gt;.<br> The key "name" is mandatory and can optionally be combined with an "implementation" value. If the implementation is not specified, the name will be used as the implementation. Each list entry represents a single advisory type. <p> Whether to fail if there are security advisories from certain providers that are not listed as reviewed in the status YAML files (<code>reviewed</code>). <p> Example: <pre>     [{"name":"CERT_FR"},      {"name":"CERT_SEI"},      {"name":"RHSA","implementation":"CSAF"}] </pre> <b>WARNING: This property is currently not implemented due to a lack of interest in this functionality.</b> It should probably be moved to the <code>InventoryValidationEnrichment</code> as a <code>VulnerabilityInventoryValidator</code>.</td></tr><tr><td><code>outputDashboardFile</code></td><td><code>null</code></td></tr></table>



---

# Other standalone steps

## Advisor periodic

`advisor-periodic` / `advisorPeriodicEnrichment` / `advisor-periodic`

<details>

<summary>Source Code for <code>AdvisorPeriodicEnrichment.performEnrichment(EnrichmentSubject subject)</code> </summary>

```java
final Inventory inventory = subject.getAsInventory(this);

final Map<String, Inventory> parsedReferenceInventories = new LinkedHashMap<>();

// reference inventory must be first for merging later on
if (configuration.hasInitialInventoryContextName()) {
    parsedReferenceInventories.put(configuration.getInitialInventoryContextName(), inventory);
}
parsedReferenceInventories.putAll(configuration.parseReferenceInventories());

if (parsedReferenceInventories.isEmpty()) {
    LOG.warn("No reference inventories have been provided.");
} else if (parsedReferenceInventories.size() == 1) {
    LOG.info("Using [{}] as the only reference inventory", parsedReferenceInventories.keySet().iterator().next());
} else {
    LOG.info("Using {} as the reference inventories", parsedReferenceInventories.keySet());
}

final Map<String, VulnerabilityContextInventory> vParsedReferenceInventories =
        VulnerabilityContextInventory.fromInventories(parsedReferenceInventories);

final Inventory outputInventory = new Inventory();

// transfer metadata from input inventory; please note that assets are not taken from the reference inventories
outputInventory.setAssetMetaData(inventory.getAssetMetaData());

final VulnerabilityContextInventory vOutputInventory =
        VulnerabilityContextInventory.fromInventory(outputInventory);

final PeriodicDataSourcesOperations.QueryTimePeriod queryTimePeriod = configuration.getAdvisoryQueryPeriod();
final List<AdvisoryTypeIdentifier<?>> includeAdvisoryProviders = AdvisorPeriodicEnrichmentConfiguration.parseAdvisoryProviders(securityPolicyConfiguration.getIncludeAdvisoryProviders());
LOG.info("Listing all advisories for changed entries of {} in period {}", includeAdvisoryProviders, queryTimePeriod);

final InventoryInfo info = outputInventory.findOrCreateInventoryInfo(ADVISOR_PERIODIC_QUERY_KEY);
info.set(ADVISOR_PERIODIC_QUERY_RANGE_START_KEY, new SimpleDateFormat("yyyy-MM-dd").format(queryTimePeriod.getStart()));
info.set(ADVISOR_PERIODIC_QUERY_RANGE_END_KEY, new SimpleDateFormat("yyyy-MM-dd").format(queryTimePeriod.getEnd()));
new ProcessorTimeTracker(inventory).addTimestamp(new ProcessTimeEntry(ProcessId.ADVISOR_PERIODIC_ENRICHMENT, TimeUtils.utcNow()));

// set up the index for the advisory providers
final PeriodicDataSourcesOperations periodicDataSourcesOperations = new PeriodicDataSourcesOperations();
periodicDataSourcesOperations.addAdvisorIndexQueriesForContentIdentifiers(baseMirrorDirectory, includeAdvisoryProviders);
periodicDataSourcesOperations.initializeNvdCveIndex(baseMirrorDirectory);

// perform query
final List<AdvisoryEntry> securityAdvisoriesUpdatedOrModifiedSince =
        periodicDataSourcesOperations.findSecurityAdvisoriesUpdatedOrModifiedSince(
                queryTimePeriod, includeAdvisoryProviders, securityPolicyConfiguration.getIncludeAdvisoryTypes());

// check whether nvd equivalent security advisories should be excluded
if (configuration.isFilterNvdEquivalent()) {
    securityAdvisoriesUpdatedOrModifiedSince.removeIf(adv -> StringUtils.hasText(adv.getNvdEquivalent()));
}

// add all found advisories to output inventory
vOutputInventory.addAllAdvisories(securityAdvisoriesUpdatedOrModifiedSince);

// if there are reference inventories, mark the AdvisoryMetaData entries as [unaffected, new, in progress, reviewed] based on whether they are listed as reviewed or not.
periodicDataSourcesOperations.setSecurityAdvisoryReviewedStatusFromReferenceInventories(
        vOutputInventory.getSecurityAdvisories(), vParsedReferenceInventories.values());

this.filterInventoryDataPreMerge(vOutputInventory, periodicDataSourcesOperations);

this.mergeReferenceInventoriesToSourceInventory(vOutputInventory, parsedReferenceInventories, outputInventory);

// mark all the advisories that have been added by the merger as 'unclassified'
for (AdvisoryEntry securityAdvisory : vOutputInventory.getShallowCopySecurityAdvisories()) {
    if (securityAdvisory.getAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS) == null) {
        securityAdvisory.setAdditionalAttribute(AdvisoryMetaData.Attribute.REVIEW_STATUS, AdvisoryMetaData.STATUS_VALUE_UNCLASSIFIED);
    }
}

periodicDataSourcesOperations.updateTimeSensitiveInformationOnVulnerabilities(vOutputInventory);

this.filterInventoryDataPostMerge(vOutputInventory, periodicDataSourcesOperations);

vOutputInventory.writeBack(super.securityPolicyConfiguration);
this.logReviewStateCounts(vOutputInventory.getSecurityAdvisories());

// move all data from the output inventory to the original inventory so that the original inventory is enriched
super.moveInventoryData(outputInventory, inventory);
```

</details>


See <a href="https://github.com/org-metaeffekt/metaeffekt-documentation/blob/main/metaeffekt-vulnerability-management/inventory-enrichment/advisor-periodic-data-flow.drawio.svg">data flow diagram</a>.
<p>
<b>Important Parameter combinations:</b>
<ul>
    <li>The parameters <code>AdvisorPeriodicEnrichmentConfiguration</code><code>#filterUnclassified</code> and
    <code>AdvisorPeriodicEnrichmentConfiguration</code><code>#filterUnaffectedVulnerabilities</code> must both be set to the
    correct value to correctly track vulnerabilities:</br>
    If <code>filterUnclassified</code> is set to false and
    <code>filterUnaffectedVulnerabilities</code> is set to true, vulnerabilities we might want to remove from an inventory
    will still be tracked, as they might still be affected by existing advisories.</li>
</ul>

#### Configuration: Advisor Periodic

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>LOG</code></td><td><code>LoggerFactory.getLogger(AdvisorPeriodicEnrichmentConfiguration.class)</code></td></tr><tr><td><code>changedSince</code></td><td><code>"3 months"</code></td></tr><tr><td colspan=2>A string that represents the start time for the period to query for advisories in. This parameter determines how far back in time advisories should be considered. The value can be a date in the format "yyyy-MM-dd" or a string like "3 months 5 hours".</td></tr><tr><td><code>changedUntil</code></td><td><code>"now"</code></td></tr><tr><td colspan=2>A string that represents the end time for the period to query for advisories in. See <code>AdvisorPeriodicEnrichmentConfiguration#changedSince</code> for more information. By default, this is set to "now", meaning the current time.</td></tr><tr><td><code>filterUnaffected</code></td><td><code>false</code></td></tr><tr><td colspan=2>Is applied after all relevant advisories have been found for the selected time period.<br> If set to true, advisories with the <code>AdvisoryMetaData#STATUS_VALUE_UNAFFECTED</code> status will be filtered out from the inventory.</td></tr><tr><td><code>filterUnclassified</code></td><td><code>false</code></td></tr><tr><td colspan=2>Is applied after all relevant advisories have been found for the selected time period.<br> If set to true, advisories with the <code>AdvisoryMetaData#STATUS_VALUE_UNCLASSIFIED</code> status will be filtered out from the inventory.</td></tr><tr><td><code>filterNvdEquivalent</code></td><td><code>true</code></td></tr><tr><td colspan=2>Whether to exclude all security advisories that have a "NVD Equivalent" vulnerability assigned.</td></tr><tr><td><code>filterUnaffectedVulnerabilities</code></td><td><code>false</code></td></tr><tr><td colspan=2>Is applied after all relevant advisories have been found for the selected time period and advisory filters have been applied.<br> If set to true, vulnerabilities that are not affected by any of the found advisories will be filtered out from the inventory.<br> Note: This is overwritten by the <code>AdvisorPeriodicEnrichmentConfiguration#includeVulnerabilitiesChangedSince</code> parameter.</td></tr><tr><td><code>filterVulnerabilitiesWithoutSpecifiedAdvisory</code></td><td><code>false</code></td></tr><tr><td colspan=2>Is applied after all relevant advisories have been found for the selected time period and advisory filters have been applied.<br> If set to true, vulnerabilities that do not have an advisory from the sources listen in the <code>org.metaeffekt.core.inventory.processor.report.configuration.CentralSecurityPolicyConfiguration#getIncludeVulnerabilitiesWithAdvisoryProviders</code> parameter will be filtered out from the inventory.<br> Note: This is overwritten by the <code>AdvisorPeriodicEnrichmentConfiguration#includeVulnerabilitiesChangedSince</code> parameter.</td></tr><tr><td><code>includeVulnerabilitiesChangedSince</code></td><td><code>null</code></td></tr><tr><td colspan=2>Can be set to a value similar to the <code>AdvisorPeriodicEnrichmentConfiguration#changedSince</code> value. This parameter will force all vulnerabilities from the source (<code>initial</code>) or reference inventories to be included that have been changed since the specified date, no matter if they are affected or would be filtered otherwise by the other parameters.<br> Example: "2023-11-08" or "3 months"</td></tr><tr><td><code>initialInventoryContextName</code></td><td><code>"initial"</code></td></tr><tr><td><code>referenceInventories</code></td><td><code>new ArrayList<>()</code></td></tr><tr><td><code>referenceInventoriesInventories</code></td><td><code>new HashMap<>()</code></td></tr></table>

#### Configuration: Vulnerabilities from CPE

<table><tr><th>Parameter</th><th>Default</th></tr><tr><td><code>maxCorrelatedVulnerabilitiesPerArtifact</code></td><td><code>Integer.MAX_VALUE</code></td></tr></table>



---
