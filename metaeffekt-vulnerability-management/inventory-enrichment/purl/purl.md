> [Documentation](../../../README.md) >
> [Vulnerability Management](../../vulnerability-management.md) >
> PURL

# Package URLs

> [Introduction](#introduction) -
> [Attributes](#purl-management)

## Introduction

PURL information on inventory artifacts can be used by the inventory enrichment in various ways.
Currently, the following steps in the software use PURLs:

- Open Source Vulnerabilities (OSV)
  - [Capabilities and integration](../../data-mirror/osv/osv.md)
  - [Process configuration](../inventory-enrichment-steps.md#package-url-derivation)

## Inventory Attributes

The following inventory artifact attributes are used for managing PURLs:

- `PURL`: Stores the set of PURLs defined by a user or automated process that created the inventory that should be enriched.
  If this value is set, the derivation of additional PURLs is skipped.
- `Inapplicable PURLs`: Allows users to specify PURLs that should be ignored for a particular artifact to enable false positive match prevention, for example via the correlation logic.
  Wildcards ("any value") are supported as well, see [Inapplicable PURLs](#inapplicable-purls) below for more information.
- `Derived PURLs`: Stores the set of PURLs automatically generated for an artifact by the [Purl Derivation](purl-derivation.md) enrichment step.

Internally, the `PurlUtil` class provides a centralized location for PURL-related logic, such as parsing, matching, and filtering.

### Inapplicable PURLs

The `Inapplicable PURLs` attribute accepts a comma-separated list of PURLs or PURL patterns.
These patterns function as a blocklist against the derived PURLs, discarding them if they match an entry in this list.

The matching logic supports wildcards and partial definitions:

- The asterisk character `*` or an empty value represent wildcard values to match any other value against.
  One exception is the *Type* segment, which does not support the asterisk; instead, use the keyword `any` to match all package types.
- An empty segment in the inapplicable PURL is treated as a wildcard.
  For example, a PURL defined without a namespace will match candidates with any namespace.
- The *Name* segment is matched case-insensitively.
- Qualifier matching is directional.
  If the Inapplicable PURL specifies qualifiers (e.g. `?distro=debian`), the candidate must match them exactly to be excluded.
  However, if the Inapplicable PURL does not have a given qualifier, it matches the candidate regardless of the candidate's qualifier.

The following table demonstrates how patterns in `Inapplicable PURLs` match against candidate PURLs:

| Inapplicable Pattern           | Candidate PURL                 | Result   | Reasoning                                            |
|:-------------------------------|:-------------------------------|:---------|:-----------------------------------------------------|
| `pkg:npm/*` or `pkg:npm`       | `pkg:npm/express`              | Match    | The wildcard matches any name within the `npm` type. |
| `pkg:maven/*/*` or `pkg:maven` | `pkg:maven/org.apache/commons` | Match    | Wildcards match both namespace and name.             |
| `pkg:any/abc`                  | `pkg:pypi/abc`                 | Match    | `any` matches the `pypi` type.                       |
| `pkg:pypi/flask`               | `pkg:pypi/Flask`               | Match    | Name matching is case-insensitive.                   |
| `pkg:pypi/flask`               | `pkg:pypi/flask?version=1.0`   | Match    | Pattern implies "any qualifier value".               |
| `pkg:pypi/flask?v=1`           | `pkg:pypi/flask`               | No Match | Candidate is missing the required qualifier.         |
| `pkg:any`                      | `pkg:pypi/flask`               | Match    | Matches any PURL regardless of content.              |

### Effective PURLs

Similar to the [Effective CPE Parser](../../other-topics/parsing-effective-cpe.md), the multiple PURL inventory attributes can be evaluated to determine an effective set of PURLs to be used by the inventory enrichment steps.
This data becomes relevant in all steps where PURL information from the artifacts is required.

In pseudocode, this process works as follows:

```
Effective PURLs = isset(PURL) ? (PURL) : (Derived PURLs - Inapplicable PURLs)
```

The logic follows this precedence ruleset:

1. If the `PURL` attribute is present, use it exclusively.
2. Otherwise, take the `Derived PURLs` and subtract any that match the `Inapplicable PURLs` using the rules defined in the chapter above.

After this, a filtering action is performed to remove duplicates and reorder the PURLs.

The above-mentioned [Purl Derivation](purl-derivation.md) enrichment step respects these rules as well.

#### Example 1: Precedence of explicit PURL

If the user manually defines a PURL, it overrides all derived logic.

- **PURL:** `pkg:generic/manual-entry`
- **Derived PURLs:** `pkg:npm/auto-detected`
- **Inapplicable PURLs:** `pkg:npm/*`

Result: `pkg:generic/manual-entry`

#### Example 2: Filtering Derived PURLs

If no explicit PURL is set, the inapplicable patterns are applied to the derived list.

- **PURL:** *(empty)*
- **Derived PURLs:**
  - `pkg:cpan/lib-a`
  - `pkg:npm/lib-b`
  - `pkg:maven/group/lib-c`
  - `pkg:pypi/lib-d?test=xy`
- **Inapplicable PURLs:**
  - `pkg:npm/*` (Filters out all NPM packages)
  - `pkg:any/lib-d` (Filters out `lib-d` regardless of type or qualifiers)

Result: `pkg:cpan/lib-a`, `pkg:maven/group/lib-c`

In this scenario, `pkg:npm/lib-b` is removed because it matches the `pkg:npm/*` pattern, and `pkg:pypi/lib-d?test=xy` is removed because `pkg:any/lib-d` matches the name `lib-d` regardless of the ecosystem or qualifiers.
