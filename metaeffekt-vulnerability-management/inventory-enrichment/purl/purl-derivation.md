> [Documentation](../../../README.md) >
> [Vulnerability Management](../../vulnerability-management.md) >
> [PURL](purl.md) >
> Derivation

# PURL Derivation

> [Introduction](#introduction) -
> [Strategy](#purl-derivation-strategy) -
> [Examples](#examples)

## Introduction

PURL information is being derived from the source artifacts if they do not provide any themselves in the [`PackageUrlDerivationEnrichment`](../inventory-enrichment-steps.md#package-url-derivation) pipeline step.
This step analyzes artifact metadata to derive a set of potential PURLs.

Other enrichment steps like the OSV matching may use these derived PURLs in addition to the PURLs provided by the input to query the OSV database.

The following inventory artifact attributes are used for this granular control:

- `PURL`: Stores the set of PURLs defined by a user or automated process that created the inventory that should be enriched.
  If this value is set, the derivation of additional PURLs is skipped.
- `Derived PURLs`: Stores the set of PURLs automatically generated for an artifact.
- `Inapplicable PURLs`: Allows users to specify PURLs that should be ignored for a particular artifact to enable false positive match prevention, for example via the correlation logic.

Internally, the `PurlUtil` class provides a centralized location for PURL-related logic, such as parsing, matching, and filtering.

## PURL Derivation Strategy

The derivation logic in `ArtifactPurlDetection` follows a multi-stage strategy to determine the most likely PURL types for an artifact:

1. The process first respects explicit information on the artifact.
    - If an artifact has a `PURL` attribute, it is used directly and derivation is skipped.
    - If an artifact has an `Ecosystem` attribute (e.g. `maven`, `npm`, `deb:debian`), that ecosystem is used as the primary candidate.
2. Heuristic-Based Detection: If no explicit directives are found, the system uses heuristics based on common artifact types.
    - `Type: python-module` -> `pypi`
    - `Component Source Type: jar-module` -> `maven`
    - `Type: web-module` or `nodejs-module` -> `npm`
    - Specialized logic for Linux packages looks for patterns in the version string (e.g., `-deb10u1` suggests `deb`, `.el9` suggests `rpm/redhat`)
    - ... more to be defined in the future ...
3. As a fallback, the system iterates through all known ecosystems.
   It uses a process of elimination, where each ecosystem has defined exclusion predicates.
   For example, the `composer` ecosystem requires a name in the format `vendor/package`.
   If an artifact's name does not match this format, `composer` is excluded as a possibility.
   This allows the system to generate a broad set of potential PURLs for artifacts with minimal information.

PURL Construction: Once potential PURL types are identified, the `ArtifactToPurlConverters` class constructs the final `PackageURL` objects.
This class contains specialized logic for different ecosystems, such as:

- Handling scoped NPM packages (e.g., `@angular/core`).
- Inferring a Maven `GroupId` from a JAR's filename if it is not explicitly provided.
- Splitting Composer package names into `vendor` and `package` components.

Finally, any PURLs matching patterns in the `Inapplicable PURLs` attribute are filtered out to produce the final set of effective PURLs for matching.
The patterns for the `Inapplicable PURLs` function allow wildcards similar to the `Inapplicable CPE URIs`, with `*` being the pattern to use for all fields except for the type, which is `any`: `pkg:any/*/*`.
Empty fields are treated as wildcards as well.

## Examples

### Example 1: Explicit Artifact Type (npm)

This example shows how a known `Type` attribute value triggers a specific PURL converter that handles special name formats.

- Input Artifact:
    - `Id`: `@angular/router-17.0.3`
    - `Version`: `17.0.3`
    - `Type`: `nodejs-module`

- Enrichment Process:
    1. The `PURL` attribute is empty, so derivation proceeds.
    2. It finds that `Type: nodejs-module` matches its heuristic for the `npm` ecosystem (Strategy 2). This is the only PURL type candidate.
    3. The `constructNpmPurl` method is invoked. It recognizes that the artifact ID `@angular/router` starts with `@`, indicating a scoped package.
    4. It splits the name into a `scope` (`@angular`) and a `name` (`router`).
    5. It combines these parts with the version to construct the final PURL.

- Resulting PURL:
  `pkg:npm/%40angular/router@17.0.3`

### Example 2: Heuristic-based Derivation with Group ID Inference (maven)

This example shows how the process constructs a PURL for a common Java artifact when the `Group Id` is provided.

- Input Artifact:
    - `Id`: `org.hibernate.orm.hibernate-core-6.4.4.Final.jar`
    - `Version`: `6.4.4.Final`
    - `Group Id`: `org.hibernate.orm`

- Enrichment Process:
    1. The `PURL`, `Ecosystem`, and `Type` attributes are empty.
    2. It sees that the artifact `Id` ends with `.jar` and the secondary requirement of having a `Group Id` is met, so it identifies `maven` as the PURL type candidate (Strategy 2).
    3. The `constructMavenPurl` method is called. It uses the provided `Group Id` (`org.hibernate.orm`).
    4. It cleans up the `artifactId` to be `hibernate-core` by computationally removing the provided `Group Id`, the `Version`, and the file extension from the original `Id` string.
    5. It assembles the PURL from the PURL type, the provided `Group Id`, the cleaned `artifactId`, and the `Version`.

- Resulting PURL:
  `pkg:maven/org.hibernate.orm/hibernate-core@6.4.4.Final`

### Example 3: Linux Package Detection from Version String (deb/ubuntu)

This example shows how the system identifies a Linux package and its distribution purely from the format of the version string.

- Input Artifact:
    - `Id`: `accountsservice-0.6.55-0ubuntu12~20.04.5`
    - `Version`: `0.6.55-0ubuntu12~20.04.5`

- Enrichment Process:
    1. No explicit `PURL`, `Ecosystem`, or `Type` is provided.
    2. Without added attributes or file extensions on the Id, it does not find an explicit match based on the artifact type.
    3. It proceeds to the `findLinuxTypes` logic.
    4. A method is called on the version string, finding the substring `ubuntu` within `0.6.55-0ubuntu12~20.04.5`.
    5. This match causes it to generate a PURL type candidate of `type: deb`, `namespace: ubuntu`.
    6. The `convertLinuxPurl` method uses the provided namespace (`ubuntu`), the artifact's ID-derived name (`accountsservice`), and the version to build the PURL.

- Resulting PURL:
  `pkg:deb/ubuntu/accountsservice@0.6.55-0ubuntu12~20.04.5`

### Example 4: Multiple Candidates and Filtering (deb)

This example shows the full pipeline, where multiple PURLs are generated and then filtered using the `Inapplicable PURLs` attribute.

- Input Artifact:
    - `Id`: `ansible-2.9.6+dfsg-1`
    - `Version`: `2.9.6+dfsg-1`
    - `Inapplicable PURLs`: `pkg:deb/ubuntu/*`

- Enrichment Process:
    1. No explicit `PURL`, `Ecosystem`, or `Type` is provided.
    2. It proceeds to the `findLinuxTypes` logic to check the version string.
    3. The version string `2.9.6+dfsg-1` contains `dfsg`, a marker common to both Debian and Ubuntu. The system generates two PURL type candidates: `type: deb, namespace: debian` and `type: deb, namespace: ubuntu`.
    4. The `convertLinuxPurl` method is called for both candidates, creating two potential PURLs.
    5. Before finalizing, the system applies the filter from the `Inapplicable PURLs` attribute.
    6. The pattern `pkg:deb/ubuntu/*` matches one of the candidates, which is then removed from the final result set.

- Resulting PURL:
  `pkg:deb/debian/ansible@2.9.6%2Bdfsg-1`

### Example 5: Path-based Name Inference (golang)

This example demonstrates how PURLs are constructed for ecosystems like Go, where the package identifier is a repository path.

- Input Artifact:
    - `Id`: `github.com/containerd/log`
    - `Version`: `v0.1.0`
    - `Ecosystem`: `golang`

- Enrichment Process:
    1. The enrichment reads the explicit `Ecosystem: golang` attribute (Strategy 1).
    2. The `constructPathBasedPurl` method is invoked for the `golang` type.
    3. This method takes the artifact `Id` (`github.com/containerd/log`) and splits it at the last `/`.
    4. It uses the part before the slash as the `namespace` (`github.com/containerd`) and the part after as the `name` (`log`).
    5. These components are assembled with the version to create the final PURL.

- Resulting PURL:
  `pkg:golang/github.com/containerd/log@v0.1.0`

### Example 6: Name Normalization (pypi)

This example demonstrates the derivation for a Python package, which includes name normalization as required by the PyPI ecosystem.

- Input Artifact:
    - `Id`: `ansible_core-2.11.12`
    - `Version`: `2.11.12`
    - `Type`: `python-module`

- Enrichment Process:
    1. The system finds that `Type: python-module` matches its heuristic for the `pypi` ecosystem (Strategy 2).
    2. The `constructPypiPurl` method is called for the `pypi` type.
    3. PyPI package names must be normalized by replacing underscores (`_`) and periods (`.`) with hyphens (`-`).
    4. The artifact `Id` `ansible_core` is normalized to `ansible-core`.
    5. The PURL is constructed using the normalized name and the version.

- Resulting PURL:
  `pkg:pypi/ansible-core@2.11.12`
